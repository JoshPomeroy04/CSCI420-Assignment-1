Locale getFallbackLocale();  String getMessage(String key, String... parameters); ResourceBundle getBundle(); }
protected void tryAggregateUpper(MavenProject prj) throws Exception { if (prj != null && prj.hasParent() && canAggregate()) { MavenProject parent = prj.getParent();
private String generateQuorumConfiguration() { int portQp1 = PortAssignment.unique(); int portQp2 = PortAssignment.unique(); int portQp3 = PortAssignment.unique(); int portLe1 = PortAssignment.unique(); int portLe2 = PortAssignment.unique(); int portLe3 = PortAssignment.unique(); return "server.1=127.0.0.1:" + (portQp1) + ":" + (portLe1) + ";" + clientPortQp1 + "\n" + "server.2=127.0.0.1:" + (portQp2) + ":" + (portLe2) + ";" + clientPortQp2 + "\n" +
ResourceMethod getResourceMethod(); void setResourceMethod(ResourceMethod resourceMethod); }
public boolean waitForQueues(long timeout, TimeUnit unit) { CountDownLatch blatch = broadcastOp(new BroadcastOpFactory(){ public Operation newOp(final MemcachedNode n, final CountDownLatch latch) { return new VersionOperationImpl( new OperationCallback() {
void set(final float floatVal) { type = ClassWriter.FLOAT; intVal = Float.floatToRawIntBits(floatVal); hashCode = 0x7FFFFFFF & (type + (int) floatVal); }
public void testNullList() throws Exception { String s = null; try { List<InetSocketAddress> addrs = AddrUtil.getAddresses(s);
private static byte[] certToTrustStoreBytes(X509Certificate cert, String keyPassword, KeyStore trustStore) throws IOException, GeneralSecurityException { char[] keyPasswordChars = keyPassword == null ? new char[0] : keyPassword.toCharArray(); trustStore.load(null, keyPasswordChars); trustStore.setCertificateEntry(cert.getSubjectDN().toString(), cert); ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); trustStore.store(outputStream, keyPasswordChars); outputStream.flush(); byte[] result = outputStream.toByteArray(); outputStream.close(); return result; }
public boolean isClientHostnameVerificationEnabled(ZKConfig config) { return isServerHostnameVerificationEnabled(config) && shouldVerifyClientHostname(); }
public void tearDown() throws Exception { logger.info("tearDown starting");
private Response makeTestHistoryResponse(TestHistory testHistory, Request request, String pageName) throws UnsupportedEncodingException { HtmlPage page = context.pageFactory.newPage(); page.setTitle("Test History"); page.setPageTitle(new PageTitle(PathParser.parse(pageName))); page.setNavTemplate("viewNav"); page.put("viewLocation", request.getResource()); page.put("testHistory", testHistory); page.setMainTemplate("testHistory"); SimpleResponse response = new SimpleResponse(); response.setContent(page.html()); return response; }
boolean isTimedOut(long ttlMillis);  boolean isTimedOutUnsent(); }
public boolean matchesFor(SymbolType symbolType) { return provider.matchesFor(symbolType); }
private boolean isCollapsed(String option) throws Exception { if(isSetup(option) && isSetupCollapsed()) return true; else if(isTeardown(option) && isTeardownCollapsed()) return true; else if("-c".equals(option)) return true; return false; }
long getAuthFailedCount();  long getNonMTLSLocalConnCount();  long getNonMTLSRemoteConnCount();  long getOutstandingRequests();  int getTickTime();  void setTickTime(int tickTime);  int getMaxClientCnxnsPerHost();  void setMaxClientCnxnsPerHost(int max);  int getMinSessionTimeout();  void setMinSessionTimeout(int min);  int getMaxSessionTimeout();  void setMaxSessionTimeout(int max); boolean getResponseCachingEnabled(); void setResponseCachingEnabled(boolean isEnabled);  int getConnectionMaxTokens(); void setConnectionMaxTokens(int val); int getConnectionTokenFillTime(); void setConnectionTokenFillTime(int val); int getConnectionTokenFillCount(); void setConnectionTokenFillCount(int val); int getConnectionFreezeTime(); void setConnectionFreezeTime(int val); double getConnectionDropIncrease(); void setConnectionDropIncrease(double val); double getConnectionDropDecrease(); void setConnectionDropDecrease(double val); double getConnectionDecreaseRatio(); void setConnectionDecreaseRatio(double val); int getCommitProcMaxReadBatchSize(); void setCommitProcMaxReadBatchSize(int size); int getCommitProcMaxCommitBatchSize(); void setCommitProcMaxCommitBatchSize(int size); int getRequestThrottleLimit(); void setRequestThrottleLimit(int requests); int getRequestThrottleStallTime(); void setRequestThrottleStallTime(int time); boolean getRequestThrottleDropStale(); void setRequestThrottleDropStale(boolean drop); int getThrottledOpWaitTime(); void setThrottledOpWaitTime(int val); boolean getRequestStaleLatencyCheck(); void setRequestStaleLatencyCheck(boolean check); boolean getRequestStaleConnectionCheck(); void setRequestStaleConnectionCheck(boolean check); int getLargeRequestMaxBytes(); void setLargeRequestMaxBytes(int bytes); int getLargeRequestThreshold(); void setLargeRequestThreshold(int threshold);  void resetStatistics();  void resetLatency();  void resetMaxLatency();  void resetFsyncThresholdExceedCount();  void resetNonMTLSConnCount();  void resetAuthFailedCount();  long getNumAliveConnections();  long getDataDirSize();  long getLogDirSize();  String getSecureClientPort();  String getSecureClientAddress();  long getTxnLogElapsedSyncTime();  int getJuteMaxBufferSize();  int getLastClientResponseSize();  int getMinClientResponseSize();  int getMaxClientResponseSize(); long getFlushDelay(); void setFlushDelay(long delay); long getMaxWriteQueuePollTime(); void setMaxWriteQueuePollTime(long delay); int getMaxBatchSize(); void setMaxBatchSize(int size);  int getMaxCnxns(); }
public static int signSafeMod(long dividend, int divisor){ int mod = (int) (dividend % divisor); if (mod < 0){ mod += divisor; } return mod;
public void forwardTo(String uri) { use(page()).forward(uri); }
protected void registerMetrics() { MetricsContext rootContext = ServerMetrics.getMetrics().getMetricsProvider().getRootContext(); final ZKDatabase zkdb = this.getZKDatabase(); final ServerStats stats = this.serverStats(); rootContext.registerGauge("avg_latency", stats::getAvgLatency); rootContext.registerGauge("max_latency", stats::getMaxLatency); rootContext.registerGauge("min_latency", stats::getMinLatency); rootContext.registerGauge("packets_received", stats::getPacketsReceived); rootContext.registerGauge("packets_sent", stats::getPacketsSent); rootContext.registerGauge("num_alive_connections", stats::getNumAliveClientConnections); rootContext.registerGauge("outstanding_requests", stats::getOutstandingRequests); rootContext.registerGauge("uptime", stats::getUptime); rootContext.registerGauge("znode_count", zkdb::getNodeCount); rootContext.registerGauge("watch_count", zkdb.getDataTree()::getWatchCount); rootContext.registerGauge("ephemerals_count", zkdb.getDataTree()::getEphemeralsCount); rootContext.registerGauge("approximate_data_size", zkdb.getDataTree()::cachedApproximateDataSize); rootContext.registerGauge("global_sessions", zkdb::getSessionCount); rootContext.registerGauge("local_sessions", this.getSessionTracker()::getLocalSessionCount); OSMXBean osMbean = new OSMXBean(); rootContext.registerGauge("open_file_descriptor_count", osMbean::getOpenFileDescriptorCount); rootContext.registerGauge("max_file_descriptor_count", osMbean::getMaxFileDescriptorCount); rootContext.registerGauge("connection_drop_probability", this::getConnectionDropChance); rootContext.registerGauge("last_client_response_size", stats.getClientResponseStats()::getLastBufferSize); rootContext.registerGauge("max_client_response_size", stats.getClientResponseStats()::getMaxBufferSize); rootContext.registerGauge("min_client_response_size", stats.getClientResponseStats()::getMinBufferSize); rootContext.registerGauge("outstanding_tls_handshake", this::getOutstandingHandshakeNum); rootContext.registerGauge("auth_failed_count", stats::getAuthFailedCount); rootContext.registerGauge("non_mtls_remote_conn_count", stats::getNonMTLSRemoteConnCount); rootContext.registerGauge("non_mtls_local_conn_count", stats::getNonMTLSLocalConnCount); }
private static List<ACL> removeDuplicates(final List<ACL> acls) { if (acls == null || acls.isEmpty()) { return Collections.emptyList(); }
public static QuorumPeer testingQuorumPeer() throws SaslException { return new QuorumPeer(); }
@Test public void translatesWikiWords() throws Exception { TestRoot root = new TestRoot(); WikiPage pageOne = root.makePage("PageOne"); WikiPage pageOneTwo = root.makePage(pageOne, "PageTwo"); WikiPage pageOneThree = root.makePage(pageOne, "PageThree"); ParserTest.assertTranslates(pageOne, "PageOne", "<a href=\"PageOne\">PageOne</a>" + HtmlElement.endl); ParserTest.assertTranslates(pageOneTwo, "PageTwo", "<a href=\"PageOne.PageTwo\">PageTwo</a>" + HtmlElement.endl); ParserTest.assertTranslates(pageOneThree, ".PageOne", "<a href=\"PageOne\">.PageOne</a>" + HtmlElement.endl); ParserTest.assertTranslates(pageOne, ">PageTwo", "<a href=\"PageOne.PageTwo\">&gt;PageTwo</a>" + HtmlElement.endl); }
public void testNotAuthenticated() { makeResponder(); assertEquals(UnauthorizedResponder.class, responderType); }
VersionInfo makeVersion(FileVersion... fileVersion) throws IOException;  VersionInfo addDirectory(final FileVersion filePath) throws IOException;  void rename(FileVersion fileVersion, File originalFile) throws IOException;  void delete(File... files) throws IOException; }
public void shouldPrunePrefixes() throws Exception { String content = runCreateFileAndGetContent(new String[]{"-baseDirectory:MasterFolder/TestFolder", ""}); assertSubString("content.txt\n", content); assertDoesntHaveRegexp("TestFolder/content.txt", content); }
Object[] deserialize(InputStream inputStream, String contentType, ResourceMethod method); }
public Object get(Object key) { key = convertKey(key); int hashCode = hash(key); HashEntry entry = data[hashIndex(hashCode, data.length)];
private void printDetails( DataTree dataTree, Map<Long, Integer> sessions, boolean dumpData, long fileNameZxid ) { long dtZxid = printZnodeDetails(dataTree, dumpData); printSessionDetails(dataTree, sessions); System.out.println(String.format("----%nLast zxid: 0x%s", Long.toHexString(Math.max(fileNameZxid, dtZxid)))); }
public void args(String[] args) throws Exception { CommandLine commandLine = new CommandLine("[-v] [-debug] [-xml file] [-suiteFilter filter] [-excludeSuiteFilter excludeFilter] host port pageName"); if (!commandLine.parse(args)) usage(); host = commandLine.getArgument("host"); port = Integer.parseInt(commandLine.getArgument("port")); pageName = commandLine.getArgument("pageName"); if (commandLine.hasOption("v")) verbose = true; if (commandLine.hasOption("debug")) debug = true; if (commandLine.hasOption("xml")) outputFileName = commandLine.getOptionArgument("xml", "file"); if (commandLine.hasOption("suiteFilter")) suiteFilter = commandLine.getOptionArgument("suiteFilter", "filter"); if (commandLine.hasOption("excludeSuiteFilter")) excludeSuiteFilter = commandLine.getOptionArgument("excludeSuiteFilter", "excludeFilter");
public void setUp() throws Exception { System.setProperty(QuorumPeer.CONFIG_KEY_MULTI_ADDRESS_ENABLED, "true"); ClientBase.setupTestEnv(); System.setProperty("zookeeper.DigestAuthenticationProvider.superDigest", "super:D/InIHSb7yEEbrWz8b9l71RjZJU="); QuorumPeerConfig.setReconfigEnabled(true);
public boolean equals(Object o) { if (!(o instanceof ExecutionReport)) return false; ExecutionReport e = (ExecutionReport) o; if (!StringUtil.stringsNullOrEqual(rootPath, e.rootPath)) return false; else if (!StringUtil.stringsNullOrEqual(version, e.version)) return false; else if (!DateTimeUtil.datesNullOrEqual(date, e.date)) return false; else if(!finalCounts.equals(e.finalCounts)) return false; return true; }
public Object intercept(Object instance, Method method, Object[] args, MethodProxy proxy) throws Throwable { Class<? extends Object> baseType = instance.getClass(); definingType = lookFor(baseType, baseType, method); currentMethod = method; return null; }
public void testGetBuilderForPEMFileType() { FileKeyStoreLoader.Builder<?> builder = FileKeyStoreLoaderBuilderProvider.getBuilderForKeyStoreFileType(KeyStoreFileType.PEM); assertTrue(builder instanceof PEMFileLoader.Builder); }
public void addGroup(PwGroupV3 group) { groups.addElement(group); }
public void enableRecv() { if (throttled.compareAndSet(true, false)) { LOG.debug("Sending unthrottle event {}", this);
public static void main(String[] args) throws IOException { Options options = parseCommandLine(args); if (options != null) { try {
public void serve(Socket s, long requestTimeout) { try { FitNesseExpediter sender = new FitNesseExpediter(s, context);
String getFullName(); String getPath(); String getFullPath(); String getContent(); boolean targetExists(String wikiWordPath); String makeFullPathOfTarget(String wikiWordPath); String findParentPath(String targetName); Maybe<SourcePage> findIncludedPage(String pageName); Collection<SourcePage> getChildren(); boolean hasProperty(String propertyKey); String getProperty(String propertyKey); String makeUrl(String wikiWordPath); List<Symbol> getSymbols(SymbolType symbolType); }
public void staticGlobalClockShouldAutomaticallyBeRestoredAfterConstructorParamsAreExhausted() throws Exception { clock = new TimeAlteringClock(0L); clock.currentClockTimeInMillis(); assertThat(Clock.currentTimeInMillis(), is(not(0L))); }
String getName(); void start() throws IOException; void bye() throws IOException, InterruptedException; void kill() throws IOException; void runTests(TestPage pageToTest) throws IOException, InterruptedException; boolean isSuccessfullyStarted(); void addTestSystemListener(TestSystemListener listener); }
Future<Boolean> append(long cas, String key, Object val); <T> Future<Boolean> append(long cas, String key, T val, Transcoder<T> tc); Future<Boolean> prepend(long cas, String key, Object val); <T> Future<Boolean> prepend(long cas, String key, T val, Transcoder<T> tc); <T> Future<CASResponse> asyncCAS(String key, long casId, T value, Transcoder<T> tc); Future<CASResponse> asyncCAS(String key, long casId, Object value); <T> CASResponse cas(String key, long casId, T value, Transcoder<T> tc); CASResponse cas(String key, long casId, Object value); <T> Future<Boolean> add(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> add(String key, int exp, Object o); <T> Future<Boolean> set(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> set(String key, int exp, Object o); <T> Future<Boolean> replace(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> replace(String key, int exp, Object o); <T> Future<T> asyncGet(String key, Transcoder<T> tc); Future<Object> asyncGet(String key); Future<CASValue<Object>> asyncGetAndTouch(final String key, final int exp); <T> Future<CASValue<T>> asyncGetAndTouch(final String key, final int exp, final Transcoder<T> tc); CASValue<Object> getAndTouch(String key, int exp); <T> CASValue<T> getAndTouch(String key, int exp, Transcoder<T> tc); <T> Future<CASValue<T>> asyncGets(String key, Transcoder<T> tc); Future<CASValue<Object>> asyncGets(String key); <T> CASValue<T> gets(String key, Transcoder<T> tc); CASValue<Object> gets(String key); <T> T get(String key, Transcoder<T> tc); Object get(String key); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Iterator<Transcoder<T>> tcs); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); BulkFuture<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> BulkFuture<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); BulkFuture<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc); Map<String, Object> getBulk(Collection<String> keys); <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys); Map<String, Object> getBulk(String... keys); <T> Future<Boolean> touch(final String key, final int exp, final Transcoder<T> tc); <T> Future<Boolean> touch(final String key, final int exp); Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, long by); long incr(String key, int by); long decr(String key, long by); long decr(String key, int by); long incr(String key, long by, long def, int exp); long incr(String key, int by, long def, int exp); long decr(String key, long by, long def, int exp); long decr(String key, int by, long def, int exp); Future<Long> asyncIncr(String key, long by); Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, long by); Future<Long> asyncDecr(String key, int by); long incr(String key, long by, long def); long incr(String key, int by, long def); long decr(String key, long by, long def); long decr(String key, int by, long def); Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs);  Set<String> listSaslMechanisms(); }
public void testSnapFilesLessThanToRetain() throws Exception { int nRecentCount = 4; int fileToPurgeCount = 2; AtomicInteger offset = new AtomicInteger(0); tmpDir = ClientBase.createTmpDir(); File version2 = new File(tmpDir.toString(), "version-2"); Assert.assertTrue("Failed to create version_2 dir:" + version2.toString(), version2.mkdir()); List<File> snapsToPurge = new ArrayList<File>(); List<File> logsToPurge = new ArrayList<File>(); List<File> snaps = new ArrayList<File>(); List<File> logs = new ArrayList<File>(); createDataDirFiles(offset, fileToPurgeCount, false, version2, snapsToPurge, logsToPurge); createDataDirFiles(offset, nRecentCount, false, version2, snaps, logs); logs.add(logsToPurge.remove(0));
public boolean exec() throws CliException { printDeprecatedWarning(); String path = args[1]; try { ZKUtil.deleteRecursive(zk, path); } catch (KeeperException|InterruptedException ex) { throw new CliWrapperException(ex); } return false; }
public void setResponseCachingEnabled(boolean isEnabled);  public int getConnectionMaxTokens(); public void setConnectionMaxTokens(int val); public int getConnectionTokenFillTime(); public void setConnectionTokenFillTime(int val); public int getConnectionTokenFillCount(); public void setConnectionTokenFillCount(int val); public int getConnectionFreezeTime(); public void setConnectionFreezeTime(int val); public double getConnectionDropIncrease(); public void setConnectionDropIncrease(double val); public double getConnectionDropDecrease(); public void setConnectionDropDecrease(double val); public double getConnectionDecreaseRatio(); public void setConnectionDecreaseRatio(double val);  public void resetStatistics();  public void resetLatency();  public void resetMaxLatency();  public void resetFsyncThresholdExceedCount();  public long getNumAliveConnections();  public long getDataDirSize();  public long getLogDirSize();  public String getSecureClientPort();  public String getSecureClientAddress();  public long getTxnLogElapsedSyncTime();  public int getJuteMaxBufferSize();  public int getLastClientResponseSize();  public int getMinClientResponseSize();  public int getMaxClientResponseSize(); public long getFlushDelay(); public void setFlushDelay(long delay); public long getMaxWriteQueuePollTime(); public void setMaxWriteQueuePollTime(long delay); public int getMaxBatchSize(); public void setMaxBatchSize(int size); }
@Test public void translatesStyle() { ParserTestHelper.assertTranslatesTo("!style_myStyle(wow zap)", "<span class=\"myStyle\">wow zap</span>"); ParserTestHelper.assertTranslatesTo("!style_myStyle[wow zap]", "<span class=\"myStyle\">wow zap</span>"); ParserTestHelper.assertTranslatesTo("!style_myStyle[)]", "<span class=\"myStyle\">)</span>"); ParserTestHelper.assertTranslatesTo("!style_myStyle{wow zap}", "<span class=\"myStyle\">wow zap</span>"); }
public static void createInitializeFile(File dir) throws IOException { File initFile = new File(dir, "initialize"); if (!initFile.exists()) { Assert.assertTrue(initFile.createNewFile());
public void testTtls() { long ttls[] = {100, 1, EphemeralType.TTL.maxValue()}; for (long ttl : ttls) { long ephemeralOwner = EphemeralType.TTL.toEphemeralOwner(ttl); Assert.assertEquals(EphemeralType.TTL, EphemeralType.get(ephemeralOwner)); Assert.assertEquals(ttl, EphemeralType.TTL.getValue(ephemeralOwner)); } EphemeralType.validateTTL(CreateMode.PERSISTENT_WITH_TTL, 100); EphemeralType.validateTTL(CreateMode.PERSISTENT_SEQUENTIAL_WITH_TTL, 100); try { EphemeralType.validateTTL(CreateMode.EPHEMERAL, 100);
public void testOffer1() throws Exception { String dir = "/testOffer1"; String testString = "Hello World"; final int numClients = 1; ZooKeeper[] clients = new ZooKeeper[numClients]; DistributedQueue[] queueHandles = new DistributedQueue[numClients]; for (int i = 0; i < clients.length; i++) { clients[i] = createClient(); queueHandles[i] = new DistributedQueue(clients[i], dir, null); } queueHandles[0].offer(testString.getBytes()); byte[] dequeuedBytes = queueHandles[0].remove(); assertEquals(new String(dequeuedBytes), testString); }
public DERObject toASN1Object() { ASN1EncodableVector v = new ASN1EncodableVector(); v.add(algId); v.add(new DEROctetString(digest)); return new DERSequence(v); }
public Set<Watcher> materialize( Watcher.Event.KeeperState state, Watcher.Event.EventType type, String clientPath ) { final Set<Watcher> result = new HashSet<>(); switch (type) { case None: if (defaultWatcher != null) { result.add(defaultWatcher); } boolean clear = disableAutoWatchReset && state != Watcher.Event.KeeperState.SyncConnected; synchronized (dataWatches) { for (Set<Watcher> ws : dataWatches.values()) { result.addAll(ws); } if (clear) { dataWatches.clear(); } } synchronized (existWatches) { for (Set<Watcher> ws : existWatches.values()) { result.addAll(ws); } if (clear) { existWatches.clear(); } } synchronized (childWatches) { for (Set<Watcher> ws : childWatches.values()) { result.addAll(ws); } if (clear) { childWatches.clear(); } } synchronized (persistentWatches) { for (Set<Watcher> ws: persistentWatches.values()) { result.addAll(ws); } } synchronized (persistentRecursiveWatches) { for (Set<Watcher> ws: persistentRecursiveWatches.values()) { result.addAll(ws); } } return result; case NodeDataChanged: case NodeCreated: synchronized (dataWatches) { addTo(dataWatches.remove(clientPath), result); } synchronized (existWatches) { addTo(existWatches.remove(clientPath), result); } addPersistentWatches(clientPath, type, result); break; case NodeChildrenChanged: synchronized (childWatches) { addTo(childWatches.remove(clientPath), result); } addPersistentWatches(clientPath, type, result); break; case NodeDeleted: synchronized (dataWatches) { addTo(dataWatches.remove(clientPath), result); }
long getFsyncThresholdExceedCount();  long getOutstandingRequests();  int getTickTime();  void setTickTime(int tickTime);  int getMaxClientCnxnsPerHost();  void setMaxClientCnxnsPerHost(int max);  int getMinSessionTimeout();  void setMinSessionTimeout(int min);  int getMaxSessionTimeout();  void setMaxSessionTimeout(int max); boolean getResponseCachingEnabled(); void setResponseCachingEnabled(boolean isEnabled);  int getConnectionMaxTokens(); void setConnectionMaxTokens(int val); int getConnectionTokenFillTime(); void setConnectionTokenFillTime(int val); int getConnectionTokenFillCount(); void setConnectionTokenFillCount(int val); int getConnectionFreezeTime(); void setConnectionFreezeTime(int val); double getConnectionDropIncrease(); void setConnectionDropIncrease(double val); double getConnectionDropDecrease(); void setConnectionDropDecrease(double val); double getConnectionDecreaseRatio(); void setConnectionDecreaseRatio(double val); int getCommitProcMaxReadBatchSize(); void setCommitProcMaxReadBatchSize(int size); int getCommitProcMaxCommitBatchSize(); void setCommitProcMaxCommitBatchSize(int size); int getRequestThrottleLimit(); void setRequestThrottleLimit(int requests); int getRequestThrottleStallTime(); void setRequestThrottleStallTime(int time); boolean getRequestThrottleDropStale(); void setRequestThrottleDropStale(boolean drop); boolean getRequestStaleLatencyCheck(); void setRequestStaleLatencyCheck(boolean check); boolean getRequestStaleConnectionCheck(); void setRequestStaleConnectionCheck(boolean check); int getLargeRequestMaxBytes(); void setLargeRequestMaxBytes(int bytes); int getLargeRequestThreshold(); void setLargeRequestThreshold(int threshold);  void resetStatistics();  void resetLatency();  void resetMaxLatency();  void resetFsyncThresholdExceedCount();  long getNumAliveConnections();  long getDataDirSize();  long getLogDirSize();  String getSecureClientPort();  String getSecureClientAddress();  long getTxnLogElapsedSyncTime();  int getJuteMaxBufferSize();  int getLastClientResponseSize();  int getMinClientResponseSize();  int getMaxClientResponseSize(); long getFlushDelay(); void setFlushDelay(long delay); long getMaxWriteQueuePollTime(); void setMaxWriteQueuePollTime(long delay); int getMaxBatchSize(); void setMaxBatchSize(int size); }
public void testStop() throws Exception { formatter.setExecutionLogAndTrackingId("2", new CompositeExecutionLog(root.addChildPage("ErrorLogs"))); formatter.announceNumberTestsToRun(1); formatter.testStarted(page); formatter.testComplete(page, new TestSummary(4, 1, 0, 0)); formatter.allTestingComplete();
public Maybe<Integer> match(ScanString input, SymbolStream symbols, int offset) { int size = 0; while (true) { char candidate = input.charAt(offset + size); if (candidate == 0) return Maybe.noInteger; if (contains(terminators, candidate)) break; size++; } return size > 0 ? new Maybe<>(size + 1) : Maybe.noInteger; }
protected void done() {
protected X509AuthenticationProvider createProvider(X509Certificate trustedCert) { return new X509AuthenticationProvider( new TestTrustManager(trustedCert),
public boolean execute() throws KeeperException, InterruptedException { zookeeper.delete(id, -1); return Boolean.TRUE; }
private void initializeWidget(ParentWidget parent, Matcher matcher) throws Exception { includeOption = getOption(matcher); pageName = getPageName(matcher); includingPage = parent.getWikiPage(); parentPage = includingPage.getParent(); includedPage = getIncludedPage(); }
public void setup() { this.converter = new EnumConverter(); this.errors = new ArrayList<ValidationMessage>(); this.bundle = ResourceBundle.getBundle("messages"); }
public void finalizeContext(final HttpContext context) { RequestHandle handle = (RequestHandle) context.removeAttribute("request-handle"); if (handle != null) { handle.cancel();
public void removeWatches(String path, Watcher watcher, WatcherType watcherType, boolean local, VoidCallback cb, Object ctx) { final String clientPath = path; PathUtils.validatePath(clientPath);
private void checkCounts(TestSummary testSummary, Element countsElement) throws Exception { assertEquals(testSummary.right + "", XmlUtil.getTextValue(countsElement, "right")); assertEquals(testSummary.wrong + "", XmlUtil.getTextValue(countsElement, "wrong")); assertEquals(testSummary.ignores + "", XmlUtil.getTextValue(countsElement, "ignores")); assertEquals(testSummary.exceptions + "", XmlUtil.getTextValue(countsElement, "exceptions")); }
public Calendar convert(String value, Class type, ResourceBundle bundle) { if (value == null || value.equals("")) { return null; } Locale locale = jstlWrapper.findLocale(request); if (locale == null) { locale = Locale.getDefault(); } DateFormat format = DateFormat.getDateInstance(DateFormat.SHORT, locale); try { Date date = format.parse(value);
private HtmlTag makeSaveButton() { HtmlTag saveButton = HtmlUtil.makeInputTag("submit", "save", "Save"); saveButton.addAttribute("tabindex", "2"); saveButton.addAttribute("accesskey", "s"); return saveButton; }
public void onClick(View v) { GroupEditActivity.Launch(GroupActivity.this); }
public Object[] anArrayOfPoint() { return new Object[] { new Point(0,0), new Point(5,5) }; }
BlockingQueue<Operation> createOperationQueue();  BlockingQueue<Operation> createReadOperationQueue();  BlockingQueue<Operation> createWriteOperationQueue();  NodeLocator createLocator(List<MemcachedNode> nodes);  OperationFactory getOperationFactory();  long getOperationTimeout();  boolean isDaemon(); }
public void sendSync(FollowerHandler f, Request r){ if(f != null){ QuorumPacket qp = new QuorumPacket(Leader.SYNC, 0, null, null);
private void traceAdminServer(String urlStr) throws IOException { HttpURLConnection conn = (HttpURLConnection) new URL(urlStr).openConnection(); conn.setRequestMethod("TRACE"); conn.connect(); assertEquals(HttpURLConnection.HTTP_FORBIDDEN, conn.getResponseCode()); }
<T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); BulkFuture<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> BulkFuture<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); BulkFuture<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc); Map<String, Object> getBulk(Collection<String> keys); <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys); Map<String, Object> getBulk(String... keys); <T> Future<Boolean> touch(final String key, final int exp, final Transcoder<T> tc); <T> Future<Boolean> touch(final String key, final int exp); Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, long by); long incr(String key, int by); long decr(String key, long by); long decr(String key, int by); long incr(String key, long by, long def, int exp); long incr(String key, int by, long def, int exp); long decr(String key, long by, long def, int exp); long decr(String key, int by, long def, int exp); Future<Long> asyncIncr(String key, long by); Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, long by); Future<Long> asyncDecr(String key, int by); long incr(String key, long by, long def); long incr(String key, int by, long def); long decr(String key, long by, long def); long decr(String key, int by, long def); Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs);  Set<String> listSaslMechanisms(); }
public void createSessionTracker() { sessionTracker = new LearnerSessionTracker( this,
public void testDistributionFromChangesProvider() throws Exception { final String input = "release distribution=production\n" + " * change1\n" + " * change2\n" + "release distribution=staging, date=14:00 13.01.2007, version=12324, urgency=low, by=tcurdt@joost.com\n" + " * change1\n" + " * change2\n" + "release distribution=development, date=12:00 10.01.2007, version=10324, urgency=low, by=tcurdt@joost.com\n" + " * change1\n" + " * change2\n"; BinaryPackageControlFile packageControlFile = new BinaryPackageControlFile(); packageControlFile.set("Package", "package"); packageControlFile.set("Version", "version"); packageControlFile.set("Date", "Mon, 20 Aug 2007 15:25:57 +0200"); final TextfileChangesProvider provider = new TextfileChangesProvider(new ByteArrayInputStream(input.getBytes("UTF-8")), packageControlFile); final ChangeSet[] changeSets = provider.getChangesSets(); assertNotNull(changeSets); assertEquals(3, changeSets.length); assertEquals("production", changeSets[0].getDistribution()); assertEquals("staging", changeSets[1].getDistribution()); assertEquals("development", changeSets[2].getDistribution()); }
public void shouldReturnCreatedInstance() { when(factory.openSession()).thenReturn(session); SessionCreator creator = new SessionCreator(factory); creator.create(); assertEquals(session, creator.getInstance()); }
public SlimCommandRunningClient build() throws IOException { CommandRunner commandRunner; if (manualStart) { commandRunner = new MockCommandRunner(); } else { commandRunner = new CommandRunner(buildCommand(), "", descriptor.createClasspathEnvironment(descriptor.getClassPath())); } return new SlimCommandRunningClient(descriptor.getTestRunner(), commandRunner, determineSlimHost(), getSlimPort()); }
WikiPage addChildPage(String name); boolean hasChildPage(String name); WikiPage getChildPage(String name); void removeChildPage(String name);  List<WikiPage> getChildren(); String getName(); PageData getData();  Collection<VersionInfo> getVersions(); WikiPage getVersion(String versionName); String getHtml();  VersionInfo commit(PageData data); PageCrawler getPageCrawler(); String getVariable(String name); }
public void writeLedgerConfig(StatCallback callback, Object ctx) { bk.getZkHandle().setData(StringUtils.getLedgerNodePath(ledgerId), metadata.serialize(), -1, callback, ctx);
public String toString() { StringBuilder sb = new StringBuilder(); if (topic != null) sb.append("Topic: " + topic.toStringUtf8()); if (subscriberId != null) sb.append(PubSubData.COMMA).append("SubscriberId: " + subscriberId.toStringUtf8()); if (msg != null) sb.append(PubSubData.COMMA).append("Message: " + msg); return sb.toString(); }
public void shouldInvokePrimitiveConverter() throws OgnlException { mockery.checking(new Expectations() { { one(converters).to(int.class, null); will(returnValue(converter)); one(converter).convert("2"); will(returnValue(2)); } }); Map context = Ognl.createDefaultContext(myCat); Ognl.setTypeConverter(context, controller); Ognl.setValue("length", context, myCat, "2"); assertThat(myCat.length, is(equalTo(2))); mockery.assertIsSatisfied(); }
public void testAbortExistingFileAfterFlush() throws IOException { FileOutputStream fos1 = new FileOutputStream(dstFile); fos1.write(TEST_STRING.getBytes()); fos1.close(); AtomicFileOutputStream fos2 = new AtomicFileOutputStream(dstFile); fos2.write(TEST_STRING_2.getBytes()); fos2.flush(); fos2.abort();
public void execute() throws InterceptionException { logger.debug("executing stack VRaptor2RequestExecution"); interceptorStack.add(ResourceLookupInterceptor.class); interceptorStack.add(FlashInterceptor.class); interceptorStack.add(InterceptorListPriorToExecutionExtractor.class); interceptorStack.add(DownloadInterceptor.class); interceptorStack.add(MultipartInterceptor.class); interceptorStack.add(instantiator); interceptorStack.add(ParametersInstantiatorInterceptor.class); if (shouldRegisterHibernateValidator) { interceptorStack.add(HibernateValidatorPluginInterceptor.class); } interceptorStack.add(ValidatorInterceptor.class); interceptorStack.add(ExecuteMethodInterceptor.class); interceptorStack.add(OutjectResult.class); interceptorStack.add(OutjectionInterceptor.class); interceptorStack.add(AjaxInterceptor.class); interceptorStack.add(ViewInterceptor.class); interceptorStack.next(null, null); }
private void sampleGauges() { rootContext.gauges.values() .forEach(PrometheusGaugeWrapper::sample); rootContext.gaugeSets.values() .forEach(PrometheusLabelledGaugeWrapper::sample);
public void testStarted(WikiTestPage testPage) { testResponse = new TestExecutionReport(); WikiPage sourcePage = testPage.getSourcePage(); setPageForHistory(sourcePage); testResponse.rootPath = sourcePage.getName(); super.testStarted(testPage); }
public void testDoenstChokeOnMissingPassword() throws Exception { appendToMessage("GET /abc?something HTTP/1.1\r\n"); appendToMessage("Authorization: Basic " + Base64.encode("Aladin") + "\r\n"); appendToMessage("\r\n"); parseMessage(); request.getCredentials(); }
public void shouldComplainAboutInvalidNumber() { converter.convert("---", Double.class); }
public T call() throws Exception { T result = null; HttpSessionMock session = new HttpSessionMock(context, "session" + ++counter); HttpServletRequestMock httpRequest = new HttpServletRequestMock(session); HttpServletResponse response = mockery.mock(HttpServletResponse.class, "response" + counter); RequestInfo request = new RequestInfo(context, httpRequest, response); VRaptorRequestHolder.setRequestForCurrentThread(request); RequestContextListener contextListener = new RequestContextListener(); contextListener.requestInitialized(new ServletRequestEvent(context, httpRequest)); result = execution.execute(request, counter); contextListener.requestDestroyed(new ServletRequestEvent(context, httpRequest)); VRaptorRequestHolder.resetRequestForCurrentThread(); return result; }
public void parenRegexp() throws Exception { String r = StyleWidget.ParenFormat.REGEXP; assertTrue(Pattern.matches(r, "!style_x(my text)")); assertTrue(Pattern.matches(r, "!style_style(my text)")); assertFalse(Pattern.matches(r, "!style(Hi)")); assertFalse(Pattern.matches(r, "!style_(Hi)")); assertFalse(Pattern.matches(r, "!style_myStyle(hi))")); }
public void restartAllServersAndClients(Watcher watcher) throws IOException, InterruptedException { for (MainThread t : mt) { if (!t.isAlive()) { t.start(); } } for (int i = 0; i < zk.length; i++) { restartClient(i, watcher);
public void passingMessage() throws Exception { assertExpectationMessage("expected", "expected", "!style_pass(!-expected-!)"); }
protected File destinationFile() { return new File(destination, filename); }
WikiPage getParent(); boolean isRoot(); WikiPage addChildPage(String name); boolean hasChildPage(String name); WikiPage getChildPage(String name); void removeChildPage(String name); List<WikiPage> getChildren(); String getName(); PageData getData(); ReadOnlyPageData readOnlyData(); Collection<VersionInfo> getVersions(); PageData getDataVersion(String versionName); VersionInfo commit(PageData data); PageCrawler getPageCrawler(); WikiPage getHeaderPage(); WikiPage getFooterPage(); }
private void makeTestResponse(String pageName) throws Exception { root = InMemoryPage.makeRoot("RooT"); FitNesseContext context = FitNesseUtil.makeTestContext(root); PageBuilder pageBuilder = new PageBuilder(); page = pageBuilder.addPage(root, PathParser.parse(pageName), "original content"); PageData data = page.getData(); WikiPageProperties properties = data.getProperties(); properties.set(PageData.PropertySUITES, "New Page tags"); data.setContent("new stuff"); VersionInfo commitRecord = last(page.getVersions()); oldVersion = commitRecord.getName(); page.commit(data); MockRequest request = new MockRequest(); request.setResource(pageName); request.addInput("version", oldVersion); Responder responder = new VersionResponder(); response = (SimpleResponse) responder.makeResponse(context, request); }
protected PageData makePageData() { PageData pageData = new PageData(this); pageData.setContent("!contents"); pageData.removeAttribute(PageData.PropertyEDIT); pageData.removeAttribute(PageData.PropertyPROPERTIES); pageData.removeAttribute(PageData.PropertyVERSIONS); pageData.removeAttribute(PageData.PropertyREFACTOR); pageData.setAttribute(PageType.SUITE.toString(), Boolean.toString(true)); return pageData; }
private void process(List<Op> ops) throws Exception { pLatch = new CountDownLatch(1); processor = new PrepRequestProcessor(zks, new MyRequestProcessor()); Record record = new MultiOperationRecord(ops); Request req = createRequest(record, OpCode.multi, false); processor.pRequest(req); assertTrue("request hasn't been processed in chain", pLatch.await(5, TimeUnit.SECONDS)); }
public String toTarget(Translator translator, Symbol symbol) { String body = translator.translate(symbol.childAt(0)); String locale = symbol.getVariable(EVALUATOR_LOCALE, ""); Maybe<String> formatLocale = locale.length() > 0 ? new Maybe<>(locale) : Maybe.noString; Maybe<String> result = new FormattedExpression(body, formatLocale).evaluate(); if (result.isNothing()) return translator.formatMessage(result.because()); return result.getValue(); }
public void testAssertionVerified(Assertion assertion, TestResult testResult) { formatters.testAssertionVerified(assertion, testResult); }
public void processResult(int rc, String path, Object ctx) { try { safeProcessResult(rc, path, ctx);
Future<Boolean> set(String key, int exp, Object o); <T> Future<Boolean> replace(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> replace(String key, int exp, Object o); <T> Future<T> asyncGet(String key, Transcoder<T> tc); Future<Object> asyncGet(String key); <T> Future<CASValue<T>> asyncGets(String key, Transcoder<T> tc); Future<CASValue<Object>> asyncGets(String key); <T> CASValue<T> gets(String key, Transcoder<T> tc) throws OperationTimeoutException; CASValue<Object> gets(String key) throws OperationTimeoutException; <T> T get(String key, Transcoder<T> tc) throws OperationTimeoutException; Object get(String key) throws OperationTimeoutException; <T> Future<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); Future<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> Future<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); Future<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc) throws OperationTimeoutException; Map<String, Object> getBulk(Collection<String> keys) throws OperationTimeoutException; <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys) throws OperationTimeoutException; Map<String, Object> getBulk(String... keys) throws OperationTimeoutException; Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, int by) throws OperationTimeoutException; long decr(String key, int by) throws OperationTimeoutException; long incr(String key, int by, long def, int exp) throws OperationTimeoutException; long decr(String key, int by, long def, int exp) throws OperationTimeoutException; Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, int by); long incr(String key, int by, long def) throws OperationTimeoutException; long decr(String key, int by, long def) throws OperationTimeoutException; Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs);  void authenticate(String mechs[], CallbackHandler cbh) throws OperationException;  Set<String> listSaslMechanisms(); }
public String genJavaHashCode(String fname) { return " ret = (int) (" + fname + "^(" + fname + ">>>32));\n"; }
private void printSessionDetails(DataTree dataTree, Map<Long, Integer> sessions) { System.out.println("Session Details (sid, timeout, ephemeralCount):"); for (Map.Entry<Long, Integer> e : sessions.entrySet()) { long sid = e.getKey();
public void testRunnerCSharp() throws Exception { String specifiedPageText = "!define TEST_RUNNER {..\\fitnesse\\fitsharp\\Runner.exe}"; WikiPage specifiedPage = makeTestPage(specifiedPageText); Descriptor descriptor = new WikiPageDescriptor(specifiedPage.readOnlyData(), false, false, getClassPath(specifiedPage)); MockClientBuilder clientBuilder = new MockClientBuilder(descriptor); assertEquals("..\\fitnesse\\fitsharp\\Runner.exe", clientBuilder.getTestRunner()); }
private Symbol makeListBody(Parser parser) { while (parser.peek(new SymbolType[] {SymbolType.Whitespace}).size() > 0) { parser.moveNext(1); } return parser.parseTo(SymbolType.Newline, 1); }
WikiPage getChildPage(String name);  @Deprecated void removeChildPage(String name);  void remove();  List<WikiPage> getChildren(); String getName(); PageData getData();  Collection<VersionInfo> getVersions(); WikiPage getVersion(String versionName); String getHtml();  VersionInfo commit(PageData data); PageCrawler getPageCrawler(); String getVariable(String name); }
public AbstractInsnNode clone(final Map labels) { return new IntInsnNode(opcode, operand); }
protected Constructor<?> handleConstructorCacheMiss(Class<?> clazz, Object[] args) { return super.getConstructor(clazz, args); }
public String toTarget(Translator translator, Symbol symbol) { ContentsItemBuilder itemBuilder = new ContentsItemBuilder(symbol, 1); HtmlTag contentsDiv = HtmlUtil.makeDivTag("contents"); contentsDiv.add(HtmlUtil.makeBold("Contents:")); HtmlTag div = itemBuilder.buildLevel(translator.getPage(), contentsDiv); return div.html(); }
public void testLoadKeyStoreWithWrongFileType() throws Exception {
public HierarchicalStreamWriter createWriter(Writer writer) { return new JsonWriter(writer, JsonWriter.DROP_ROOT_MODE); }
private void generateTestResultFile(TestExecutionReport testResponse, File resultFile) throws Exception { VelocityContext velocityContext = new VelocityContext(); velocityContext.put("response", testResponse); FitNesseContext context = new FitNesseContext(); Template template = VelocityFactory.getVelocityEngine().getTemplate("testResults.vm"); FileWriter fileWriter = new FileWriter(resultFile); template.merge(velocityContext, fileWriter); fileWriter.close(); }
public void setup() { this.mockery = new Mockery(); this.request = mockery.mock(MutableRequest.class); this.response = mockery.mock(MutableResponse.class); this.session = mockery.mock(HttpSession.class); this.method = mockery.mock(ResourceMethod.class); this.resource = mockery.mock(ResourceClass.class); this.config = mockery.mock(Config.class); this.resolver = mockery.mock(PathResolver.class); this.dispatcher = mockery.mock(RequestDispatcher.class); this.info = mockery.mock(MethodInfo.class); mockery.checking(new Expectations() { { allowing(request).getParameterMap(); will(returnValue(new HashMap<String, Object>())); allowing(request).getSession(); will(returnValue(session)); allowing(session).getAttribute("org.vraptor.scope.ScopeType_FLASH"); will(returnValue(new HashMap<String, Object>())); allowing(info).getResourceMethod(); will(returnValue(method)); allowing(method).getResource(); will(returnValue(resource)); allowing(info).getResult(); will(returnValue("ok")); } }); this.webRequest = new RequestInfo(context, request, response); DefaultPageResult delegate = new DefaultPageResult(request, response, info, resolver, null, null); this.result = new ViewsPropertiesPageResult(this.config, this.resolver, this.info, this.webRequest, info, null, delegate); }
public void setUp() throws Exception { context = FitNesseUtil.makeTestContext(); root = context.getRootPage(); request = new MockRequest(); responder = new AccountResponder(); }
public ResourceMethod translate(RequestInfo info) throws ResourceNotFoundException, MethodNotAllowedException { return null; }
public void oneRowThatImplicitlyFails() throws Exception { assertTableResults("|2|4|\n", asList(
public static void writeParse(File report, Parse parse) throws UnsupportedEncodingException, FileNotFoundException { PrintWriter output = new PrintWriter(new OutputStreamWriter(new FileOutputStream(report), ASCII_ENCODING)); parse.print(output); output.close(); }
private Collection<PluginFeatureFactory> findPluginFeatureFactories() throws PluginException { List<PluginFeatureFactory> factories = new ArrayList<>(PropertyBasedPluginFeatureFactory.loadFromProperties(componentFactory)); for (PluginFeatureFactory factory : ServiceLoader.load(PluginFeatureFactory.class, classLoader)) { factories.add(factory); } return factories; }
public boolean stopHasBeenRequested() { return (Boolean) callMethod("stopHasBeenRequested"); }
public void addToNextPending(Request req) { this.nextPending.set(req); }
public Operation newOp(final MemcachedNode n, final CountDownLatch latch) { return opFact.flush(delay, new OperationCallback(){ public void receivedStatus(String line) {
BlockingQueue<Operation> createReadOperationQueue();  BlockingQueue<Operation> createWriteOperationQueue();  long getOpQueueMaxBlockTime();  NodeLocator createLocator(List<MemcachedNode> nodes);  OperationFactory getOperationFactory();  long getOperationTimeout();  boolean isDaemon();  boolean useNagleAlgorithm();  Collection<ConnectionObserver> getInitialObservers();  FailureMode getFailureMode();  Transcoder<Object> getDefaultTranscoder();  boolean shouldOptimize();  int getReadBufSize();  HashAlgorithm getHashAlg();  long getMaxReconnectDelay();  AuthDescriptor getAuthDescriptor();  int getTimeoutExceptionThreshold();  MetricType enableMetrics();  MetricCollector getMetricCollector(); }
public void register(Class requiredType, Class componentType) { boundClasses.add(requiredType); logger.debug("Binding {} to {}", requiredType, componentType); bindToConstructor(requiredType, componentType); registerFactory(componentType); }
public <T> boolean that(String category, String reason, T actual, Matcher<? super T> matcher) { if (!matcher.matches(actual)) { if (reason != null) { errors.add(new ValidationMessage(getString(reason), category)); } else { Description description = new ResourceBundleDescription(bundle); description.appendDescriptionOf(matcher); errors.add(new ValidationMessage(description.toString(), category)); } return false; } return true; }
public void gotData(String k, int flags, long cas, byte[] data) { assert key.equals(k) : "Wrong key returned"; assert cas > 0 : "CAS was less than zero: " + cas; val=new CASValue(cas, transcoder.decode(new CachedData(flags, data)));
public <T> If<T> that(T instance) { return new If<T>(instance, this); }
CASOperation cas(StoreType t, String key, long casId, int flags, int exp, byte[] data, OperationCallback cb);  VersionOperation version(OperationCallback cb);  SASLMechsOperation saslMechs(OperationCallback cb);  SASLAuthOperation saslAuth(String[] mech, String serverName, Map<String, ?> props, CallbackHandler cbh, OperationCallback cb);  SASLStepOperation saslStep(String[] mech, String challenge, String serverName, Map<String, ?> props, CallbackHandler cbh, OperationCallback cb);  Collection<Operation> clone(KeyedOperation op); }
public CASOperation cas(String key, long casId, int flags, byte[] data, OperationCallback cb) { return new StoreOperationImpl(StoreType.set, key, flags, 0, data, casId, cb);
boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs);  void authenticate(String mechs[], CallbackHandler cbh) throws OperationException; }
protected void includeTearDowns(StringBuilder decoratedContent) { includeTearDown(getTearDown(), decoratedContent); }
public static FitNesseContext makeTestContext(WikiPage root, int port) { return makeTestContext(root, createTemporaryFolder(), FitNesseUtil.base, port, new PromiscuousAuthenticator()); }
private void respondsWith(List<Object> expected) { expectedResults.addAll(expected); List<Object> result = executor.execute(statements); Map<String, Object> expectedMap = SlimClient.resultToMap(expectedResults); Map<String, Object> resultMap = SlimClient.resultToMap(result); assertEquals(expectedMap, resultMap); }
public static <T> T profile(Operation<T> op, long timeout, String message) throws Exception { long start = System.currentTimeMillis(); T res = op.execute(); long end = System.currentTimeMillis(); if (end - start > timeout) { LOG.warn("Elapsed "+(end - start) + " ms: " + message); } return res; }
public void testParseSpace() { assertEquals("a",ListTree.parse("<i>a </i>").text()); }
public void classicRoundUp() throws Exception { assertTrue(approximatelyEqual("3.05", "3.049")); }
public void doesNotIncludeInvalidPageNames() throws Exception { TestRoot root = new TestRoot(); WikiPage parent = root.makePage("ParentPage", "stuff"); WikiPage currentPage = root.makePage(parent, "PageOne", "!include not.a.wiki.page"); ParserTestHelper.assertTranslatesTo(currentPage, "<span class=\"red\">Page include failed because the page not.a.wiki.page does not have a valid WikiPage name.\n</span>"); }
void cleanup() { connectLock.lock(); try { if (connectFuture != null) { connectFuture.cancel(); connectFuture = null; } if (channel != null) { channel.close().awaitUninterruptibly(); channel = null; } } finally { connectLock.unlock(); } Iterator<Packet> iter = outgoingQueue.iterator(); while (iter.hasNext()) { Packet p = iter.next();
public void testClientRetry() throws IOException, InterruptedException, TimeoutException{ CountdownWatcher cdw1 = new CountdownWatcher(); CountdownWatcher cdw2 = new CountdownWatcher(); ZooKeeper zk = new ZooKeeper(hostPort, 10000, cdw1); try { cdw1.waitForConnected(CONNECTION_TIMEOUT);
public void testAddFailWhenPageAlreadyHasChild() throws Exception { pageOne.addChildPage("SymLink"); request.addInput("linkName", "SymLink"); request.addInput("linkPath", "PageTwo"); Response response = responder.makeResponse(new FitNesseContext(root), request); assertEquals(412, response.getStatus()); String content = ((SimpleResponse)response).getContent(); assertSubString("already has a child named SymLink", content); assertSubString("Error Occured", content); }
public static Database GetDb1(Context ctx) throws IOException, InvalidKeyFileException, InvalidPasswordException { return GetDb1(ctx, false); }
public void shouldUseHeadersToHttpResponse() throws IOException { JFreeChartDownload chartDownload = new JFreeChartDownload(chart, width, height); mockery.checking(new Expectations() { { one(response).getOutputStream(); will(returnValue(socketStream)); one(response).setHeader("Content-type", "image/png"); ignoring(anything()); } }); chartDownload.write(response); Assert.assertArrayEquals(bytes, outputStream.toByteArray()); }
public static FitNesseContext makeTestContext(FitNesseContext context, Authenticator authenticator) { Builder builder = new Builder(context); builder.authenticator = authenticator; return builder.createFitNesseContext(); }
public void shouldConvertToZeroWhenEmpty() { assertThat((Float) converter.convert("", float.class), is(equalTo(0F))); }
public void initialize() { int size=KeyUtil.getKeyBytes(key).length + OVERHEAD; ByteBuffer b=ByteBuffer.allocate(size); setArguments(b, mutator.name(), key, amount); b.flip(); setBuffer(b); }
public boolean isUserInRole(String s) {
public void processResult(int rc, String path, Object ctx, byte data[], Stat stat) {
public void testUndecodeableSerialized() throws Exception { CachedData cd=new CachedData(WhalinTranscoder.SERIALIZED, tu.encodeInt(Integer.MAX_VALUE), tc.getMaxSize()); assertNull(tc.decode(cd)); }
public void testGetRootPagePath() { FitNesseContext context = FitNesseUtil.makeTestContext(null); assertEquals(context.rootPath + File.separator + "TestDir", context.getRootPagePath()); }
public void scala2_13_should_generate_release() { assertEquals( asList("-release", "8"), ScalaMojoSupport.computeBytecodeVersionOptions("1.8", null, new VersionNumber("2.13.10"))); assertEquals( asList("-release", "8"), ScalaMojoSupport.computeBytecodeVersionOptions("1.8", "8", new VersionNumber("2.13.10"))); assertEquals( asList("-release", "11"), ScalaMojoSupport.computeBytecodeVersionOptions("1.8", "11", new VersionNumber("2.13.10"))); assertEquals( asList("-release", "17"),
private void cleanup() { if (!channelClosed.compareAndSet(false, true)) { return; } disconnected.set(true); onClosing(); }
private String makeLinkToNonExistentWikiPage(String text, String qualifiedName) { HtmlText htmlText = new HtmlText(text); HtmlTag link = new HtmlTag("a", "[?]"); link.addAttribute("title", "create page"); link.addAttribute("href", qualifiedName + "?edit&nonExistent=true"); return htmlText.html() + link.htmlInline(); }
void resetLatency();  void resetMaxLatency();  void resetFsyncThresholdExceedCount();  long getNumAliveConnections();  long getDataDirSize();  long getLogDirSize();  String getSecureClientPort();  String getSecureClientAddress();  long getTxnLogElapsedSyncTime();  int getJuteMaxBufferSize();  int getLastClientResponseSize();  int getMinClientResponseSize();  int getMaxClientResponseSize(); long getFlushDelay(); void setFlushDelay(long delay); long getMaxWriteQueuePollTime(); void setMaxWriteQueuePollTime(long delay); int getMaxBatchSize(); void setMaxBatchSize(int size);  int getMaxCnxns(); }
void setTranscoder(Transcoder<Object> tc); Transcoder<Object> getTranscoder(); Future<Boolean> append(long cas, String key, Object val); <T> Future<Boolean> append(long cas, String key, T val, Transcoder<T> tc); Future<Boolean> prepend(long cas, String key, Object val); <T> Future<Boolean> prepend(long cas, String key, T val, Transcoder<T> tc); <T> Future<CASResponse> asyncCAS(String key, long casId, T value, Transcoder<T> tc); Future<CASResponse> asyncCAS(String key, long casId, Object value); <T> CASResponse cas(String key, long casId, T value, Transcoder<T> tc) throws OperationTimeoutException; CASResponse cas(String key, long casId, Object value) throws OperationTimeoutException; <T> Future<Boolean> add(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> add(String key, int exp, Object o); <T> Future<Boolean> set(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> set(String key, int exp, Object o); <T> Future<Boolean> replace(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> replace(String key, int exp, Object o); <T> Future<T> asyncGet(String key, Transcoder<T> tc); Future<Object> asyncGet(String key); <T> Future<CASValue<T>> asyncGets(String key, Transcoder<T> tc); Future<CASValue<Object>> asyncGets(String key); <T> CASValue<T> gets(String key, Transcoder<T> tc) throws OperationTimeoutException; CASValue<Object> gets(String key) throws OperationTimeoutException; <T> T get(String key, Transcoder<T> tc) throws OperationTimeoutException; Object get(String key) throws OperationTimeoutException; <T> Future<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); Future<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> Future<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); Future<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc) throws OperationTimeoutException; Map<String, Object> getBulk(Collection<String> keys) throws OperationTimeoutException; <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys) throws OperationTimeoutException; Map<String, Object> getBulk(String... keys) throws OperationTimeoutException; Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, int by) throws OperationTimeoutException; long decr(String key, int by) throws OperationTimeoutException; Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, int by); long incr(String key, int by, long def) throws OperationTimeoutException; long decr(String key, int by, long def) throws OperationTimeoutException; Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); }
protected void checkScalaVersion() throws Exception { if (checkMultipleScalaVersions) { checkCorrectVersionsOfScalaLibrary(findScalaVersion().toString());
public void functionCallWithOneArgument() throws Exception { buildInstructionsFor("|function|arg|\n"); List<CallInstruction> expectedInstructions = asList( new CallInstruction("htmlScriptTable_id_0", "htmlScriptTableActor", "function", new Object[]{"arg"}) ); assertEquals(expectedInstructions, instructions()); }
private byte[] readContentBytes(final File input) throws IOException { FileInputStream inputStream = null; try { final byte[] bytes = new byte[(int) input.length()];
public void processEvent(String nodePath, String eventType, Map<String, String> eventInfo); }
public void testFail() throws Exception { QuorumBase qb = new QuorumBase(); qb.setUp(); System.out.println("Comment: the servers are at " + qb.hostPort); ZooKeeper zk = qb.createClient(); zk.create("/test", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); zk.close(); QuorumBase.shutdown(qb.s1); QuorumBase.shutdown(qb.s2); QuorumBase.shutdown(qb.s3); QuorumBase.shutdown(qb.s4); QuorumBase.shutdown(qb.s5); String hp = qb.hostPort.split(",")[0]; ZooKeeperServer zks = new ZooKeeperServer(qb.s1.getTxnFactory().getSnapDir(), qb.s1.getTxnFactory().getDataDir(), 3000); final int PORT = Integer.parseInt(hp.split(":")[1]); ServerCnxnFactory factory = ServerCnxnFactory.createFactory(PORT, -1); factory.startup(zks); System.out.println("Comment: starting factory"); Assert.assertTrue("waiting for server up", ClientBase.waitForServerUp("127.0.0.1:" + PORT, QuorumTest.CONNECTION_TIMEOUT)); factory.shutdown(); Assert.assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + PORT, QuorumTest.CONNECTION_TIMEOUT)); System.out.println("Comment: shutting down standalone"); }
private void makeTables(String tableText) throws Exception { WikiPageUtil.setPageContents(root, tableText); TableScanner ts = new HtmlTableScanner(root.getData().getHtml()); Table t = ts.getTable(0); st = new ScenarioTable(t, "s_id", this); t = ts.getTable(1); script = new ScriptTable(t, "id", this); instructions.addAll(st.getInstructions()); instructions.addAll(script.getInstructions()); }
public String loadContentFilter() throws Exception { ContentFilter filter = (ContentFilter) createComponent(CONTENT_FILTER); if(filter != null) { SaveResponder.contentFilter = filter; return "\tContent filter installed: " + filter.getClass().getName() + "\n"; } return ""; }
public void remove() { } @Path("/clients/head") @Head public void head() { } public void add() { } @Path("/protectMe") protected void protectMe() { } @Path("/staticMe") public static void staticMe() { } } @Test public void shouldFindAPublicNonStaticNonAnnotatedMethodWithTheSameNameAsTheGivenId() throws SecurityException, NoSuchMethodException { ResourceMethod method = lookuper.methodFor("/add", "POST"); assertThat(method, is(VRaptorMatchers.resourceMethod(Clients.class.getMethod("add")))); mockery.assertIsSatisfied(); } @Test public void shouldIgnoreAResourceWithTheWrongWebMethod() throws SecurityException, NoSuchMethodException { ResourceMethod method = lookuper.methodFor("/clients/remove", "POST"); assertThat(method, is(Matchers.nullValue())); mockery.assertIsSatisfied(); } @Test public void shouldAcceptAResultWithASpecificWebMethod() throws SecurityException, NoSuchMethodException { ResourceMethod method = lookuper.methodFor("/clients/head", "HEAD"); assertThat(method, is(VRaptorMatchers.resourceMethod(Clients.class.getMethod("head")))); mockery.assertIsSatisfied(); } }
protected void assertOrderedNodeNames(String[] names, String[] expected) { int size = names.length; Assert.assertEquals("The two arrays should be the same size!", names.length, expected.length); SortedSet<ZNodeName> nodeNames = new TreeSet<ZNodeName>(); for (String name : names) { nodeNames.add(new ZNodeName(name)); } int index = 0; for (ZNodeName nodeName : nodeNames) { String name = nodeName.getName();
int getColumnCountInRow(int row); void substitute(int col, int row, String content); int addRow(List<String> list); void addColumnToRow(int row, String content); void appendChildTable(int row, Table table); void updateContent(int row, TestResult testResult); void updateContent(int col, int row, SlimTestResult testResult); void updateContent(int col, int row, SlimExceptionResult exceptionResult); Table asTemplate(CellContentSubstitution substitution) throws SyntaxError;
public void testArgsJustUser() throws Exception { password = new Password(); boolean valid = password.args(new String[] {"splinter"}); assertTrue(valid); assertEquals("splinter", password.getUsername()); assertEquals("passwords.txt", password.getFilename()); }
public TransitionBuilder transition(String name); <T> T transition(Class<T> type); public StateBuilder state(String name); public List<Transition> getTransitions(); public List<State> getStates();  public void clear(); }
public void testGatherXRefTestPages() throws Exception { WikiPage testPage = crawler.addPage(root, PathParser.parse("SomePage"), "!see PageA\n!see PageB"); WikiPage pageA = crawler.addPage(root, PathParser.parse("PageA")); WikiPage pageB = crawler.addPage(root, PathParser.parse("PageB")); List<?> xrefTestPages = SuiteResponder.gatherCrossReferencedTestPages(testPage, root); assertEquals(2, xrefTestPages.size()); assertTrue(xrefTestPages.contains(pageA)); assertTrue(xrefTestPages.contains(pageB)); }
String getProperty(String propertyKey); String makeUrl(String wikiWordPath); }
private boolean hasFractionalSeconds() { return time.indexOf('.') == 14; }
public void testMakeResponse() throws Exception { MockRequest request = new MockRequest(); ByteArrayOutputStream output = new ByteArrayOutputStream(); FitProtocol.writeData(result1.toString(), output); FitProtocol.writeData(result2.toString(), output); FitProtocol.writeCounts(new Counts(5, 5, 5, 5), output); request.addInput("results", output.toString()); Response response = responder.makeResponse(context, request); MockResponseSender sender = new MockResponseSender(); sender.doSending(response); String html = sender.sentData(); assertSubString("Mock Results", html);
public void testBigContent() throws Exception { StringBuffer buffer = new StringBuffer(); for (int i = 0; i < 1000; i++) buffer.append("abcdefghijklmnopqrstuvwxyz"); WikiPageUtil.addPage(root, PathParser.parse("BigPage"), buffer.toString()); String content = root.getChildPage("BigPage").getData().getContent(); assertTrue(buffer.toString().equals(content)); }
PagesByTestSystem partition(Function<List<WikiPage>, ? extends PagesByTestSystem> factory, List<WikiPage> pages, int partitionCount, int partitionIndex);  PagePositions findPagePositions(Function<List<WikiPage>, ? extends PagesByTestSystem> factory, List<WikiPage> pages, int partitionCount); }
private Response generateHtmlSuiteExecutionResponse(Request request, SuiteExecutionReport report) throws Exception { page.setTitle("Suite Execution Report"); page.setNavTemplate("viewNav"); page.put("viewLocation", request.getResource()); page.put("suiteExecutionReport", report); page.setMainTemplate("suiteExecutionReport"); return makeResponse(); }
public void testNoGzip() throws IOException, InvalidDBException { Context ctx = getContext(); AssetManager am = ctx.getAssets(); InputStream is = am.open("no-encrypt.kdbx", AssetManager.ACCESS_STREAMING); ImporterV4 importer = new ImporterV4(); importer.openDatabase(is, "12345", ""); is.close();
public void setup() { slimTestSystem.addTestSystemListener(listener); slimTestSystem.newTestPage(); }
public MessageSeqId getCurrentSeqIdForTopic(ByteString topic) throws ServerNotResponsibleForTopicException { return realPersistenceManager.getCurrentSeqIdForTopic(topic); }
public void setUp() throws Exception { makeSampleFiles(); testDir = new File("testDir"); }
public void testRemoveAllWatchers(boolean useAsync) throws IOException, InterruptedException, KeeperException { zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); MyWatcher w1 = new MyWatcher("/node1", 2); MyWatcher w2 = new MyWatcher("/node1", 2); LOG.info("Adding data watcher {} on path {}", w1, "/node1"); assertNotNull(zk2.exists("/node1", w1), "Didn't set data watches"); LOG.info("Adding data watcher {} on path {}", w2, "/node1"); assertNotNull(zk2.exists("/node1", w2), "Didn't set data watches"); LOG.info("Adding child watcher {} on path {}", w1, "/node1"); zk2.getChildren("/node1", w1); LOG.info("Adding child watcher {} on path {}", w2, "/node1"); zk2.getChildren("/node1", w2); removeWatches(zk2, "/node1", w1, WatcherType.Any, false, Code.OK, useAsync); removeWatches(zk2, "/node1", w2, WatcherType.Any, false, Code.OK, useAsync); zk1.create("/node1/child", null, Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL); assertTrue(w1.matches(), "Didn't remove data watcher"); assertTrue(w2.matches(), "Didn't remove child watcher"); }
public void setup() throws NoSuchMethodException { this.mockery = new Mockery(); this.provider = mockery.mock(ParametersProvider.class); this.requestResult = new RequestResult(); this.stack = mockery.mock(InterceptorStack.class); this.parameters = mockery.mock(MethodParameters.class); }
private static void deserializeTree(int depth, int width, int len) throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException { BinaryInputArchive ia; int count; { DataTree tree = new DataTree(); SerializationPerfTest.createNodes(tree, "/", depth, width, tree.getNode("/").stat.getCversion(), new byte[len]); count = tree.getNodeCount(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); BinaryOutputArchive oa = BinaryOutputArchive.getArchive(baos); tree.serialize(oa, "test"); baos.flush(); ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ia = BinaryInputArchive.getArchive(bais); } DataTree dserTree = new DataTree(); System.gc(); long start = System.nanoTime(); dserTree.deserialize(ia, "test"); long end = System.nanoTime(); long durationms = (end - start) / 1000000L; long pernodeus = ((end - start) / 1000L) / count; assertEquals(count, dserTree.getNodeCount()); LOG.info( "Deserialized {} nodes in {} ms ({}us/node), depth={} width={} datalen={}",
public void setUp() throws Exception { root = new FileSystemPage(FitNesseUtil.base, rootName); context = FitNesseUtil.makeTestContext(root); FileUtil.makeDir(FitNesseUtil.base); pageOne = WikiPageUtil.addPage(root, PathParser.parse("PageOne"), "some content"); pageTwo = WikiPageUtil.addPage(pageOne, PathParser.parse("PageTwo"), "page two content"); updater = new UpdaterBase(context); update = makeUpdate();
public void list() throws IOException, ServletException { result.include("dogs", Arrays.asList("lulu", "pluto"));
public void testLoadCertificateFromTrustStore( X509KeyType caKeyType, X509KeyType certKeyType, String keyPassword, Integer paramIndex) throws Exception { init(caKeyType, certKeyType, keyPassword, paramIndex); List<X509Certificate> certs = PemReader.readCertificateChain(x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM)); assertEquals(1, certs.size()); assertEquals(x509TestContext.getTrustStoreCertificate(), certs.get(0)); }
boolean isServerRequired();  CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs); }
static long decodeLong(byte[] data, int i) { return (data[i ] & 0xff) << 56
private void pauseAccept(long millisecs) { acceptKey.interestOps(0); try { selector.select(millisecs);
public void produce( final DataConsumer pReceiver ) throws IOException { String fileName; if (destinationName != null && destinationName.trim().length() > 0) { fileName = destinationName.trim(); } else { fileName = file.getName(); } TarEntry entry = new TarEntry(fileName); entry.setUserId(0); entry.setUserName("root"); entry.setGroupId(0); entry.setGroupName("root"); entry.setMode(TarEntry.DEFAULT_FILE_MODE); entry = map(entry); entry.setSize(file.length()); final InputStream inputStream = new FileInputStream(file); try { pReceiver.onEachFile(inputStream, entry.getName(), entry.getLinkName(), entry.getUserName(), entry.getUserId(), entry.getGroupName(), entry.getGroupId(), entry.getMode(), entry.getSize());
public String makeHtml(FitNesseContext context) throws Exception { WikiPage page = pageData.getWikiPage(); HtmlPage html = context.htmlPageFactory.newPage(); WikiPagePath fullPath = page.getPageCrawler().getFullPath(page); String fullPathName = PathParser.render(fullPath); html.title.use(fullPathName); html.header.use(HtmlUtil.makeBreadCrumbsWithCurrentPageNotLinked( fullPathName ) ); html.actions.use(HtmlUtil.makeActions(pageData)); html.main.use(HtmlUtil.addHeaderAndFooter(page, SetupTeardownIncluder.render(pageData) ) ); handleSpecialProperties(html, page); return html.html(); }
public void shutdown() { try { ss.close(); clear(); this.interrupt(); this.join(); } catch (InterruptedException e) { LOG.warn("Ignoring interrupted exception during shutdown", e); } catch (Exception e) { LOG.warn("Ignoring unexpected exception during shutdown", e); } if (zks != null) { zks.shutdown();
private void wrapScript(File destFile, boolean mavenProjectDependency) throws IOException { destFile.delete(); FileOutputStream fileOutputStream = new FileOutputStream(destFile); PrintStream out = new PrintStream(fileOutputStream, false, encoding); BufferedReader reader = null; try { if (scriptFile != null) {
public static Parser makeEnds(WikiPage currentPage, Scanner scanner, SymbolProvider provider, SymbolType[] types) { provider.addTypes(types); return new Parser(currentPage, scanner, provider, emptyTypes, emptyTypes, types); }
public Object intercept(Object proxy, Method method, Object[] args, final MethodProxy methodProxy) { if (OBJECT_METHODS.contains(method)) { try {
protected byte[] compress(byte[] in) { if(in == null) { throw new NullPointerException("Can't compress null"); } ByteArrayOutputStream bos=new ByteArrayOutputStream(); GZIPOutputStream gz=null; try { gz = new GZIPOutputStream(bos); gz.write(in); } catch (IOException e) { throw new RuntimeException("IO exception compressing data", e); } finally { CloseUtil.close(gz); CloseUtil.close(bos); } byte[] rv=bos.toByteArray(); getLogger().debug("Compressed %d bytes to %d", in.length, rv.length); return rv; }
public static boolean changesShouldBeMerged(long thisEditTime, long ticket, PageData data) { return new MergeDeterminer(thisEditTime, ticket, data).shouldMerge(); }
private void refreshList() { @SuppressWarnings("unchecked") ArrayAdapter<String> adapter = (ArrayAdapter<String>) getListAdapter(); adapter.notifyDataSetChanged(); /*
public long currentClockTimeInMillis() { return theConstantTime; }
public void processResult(int rc, String path, Object ctx); } interface MultiCallback extends AsyncCallback { public void processResult(int rc, String path, Object ctx, List<OpResult> opResults); } }
public void testSpacesInFileName() throws Exception { String restoredPath = FileResponder.restoreRealSpacesInFileName("files/test%20File%20With%20Spaces%20In%20Name"); assertEquals("files/test File With Spaces In Name", restoredPath); request.setResource("files/file4%20with%20spaces.txt"); responder = (FileResponder) FileResponder.makeResponder(request, SampleFileUtility.base); assertEquals("files/file4 with spaces.txt", responder.resource); }
void endRecord(String tag) throws IOException; Index startVector(String tag) throws IOException; void endVector(String tag) throws IOException; Index startMap(String tag) throws IOException; void endMap(String tag) throws IOException; }
WikiPage findAncestorWithName(WikiPage page, String name); WikiPage getClosestInheritedPage(WikiPage context, String pageName); }
public void testACLCreatedDuringFuzzySnapshotSync() throws IOException { DataTree leaderDataTree = new DataTree();
public void shouldBeAbleToDealWithGenericCollection() throws SecurityException, NoSuchMethodException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { Class<?> type = creator.typeFor(mockery.method(DogAlike.class.getDeclaredMethod("eat", List.class))); Method getter = type.getDeclaredMethod("getListOfString"); Assert.assertTrue(getter.getGenericReturnType() instanceof ParameterizedType); ParameterizedType returnType = (ParameterizedType) getter.getGenericReturnType(); Assert.assertTrue(List.class.isAssignableFrom((Class) returnType.getRawType())); Type firstType = returnType.getActualTypeArguments()[0]; Assert.assertTrue(String.class.isAssignableFrom((Class) firstType)); mockery.assertIsSatisfied(); }
protected static String replace(String value, String mark, String replacement) { return value.replaceAll(mark, Matcher.quoteReplacement(replacement)); }
public void shouldForwardToDefaultViewWithAlias() throws Exception { serialization.from(new Object(), "Abc"); verify(pageResult).defaultView(); }
public void testDoenstChokeOnMissingPassword() throws Exception { startParsing(); writeToPipe("GET /abc?something HTTP/1.1\r\n"); writeToPipe("Authorization: Basic " + Base64.encode("Aladin") + "\r\n"); writeToPipe("\r\n"); finishParsing(); try { request.getCredentials();
public boolean startsLine(int startAt) { return startsLine(startAt, "\n"); }
public void addsTheErrorsOnTheResult() { try { validator.add(A_MESSAGE); validator.onErrorUse(Results.logic()).forwardTo(MyComponent.class).logic(); } catch (ValidationException e) { } verify(result).include(eq("errors"), argThat(is(not(empty())))); }
public void debugTest() throws Exception { request.addInput("debug", ""); doSimpleRun(passFixtureTable()); assertTrue(results.contains(">Tests Executed OK<")); assertTrue(results.contains("\\\"ok\\\"")); assertTrue("should be fast test", responder.isDebug()); }
public SignatureVisitor visitTypeArgument(final char tag) { if (argumentStack % 2 == 0) { ++argumentStack; declaration.append('<'); } else { declaration.append(", "); } if (tag == EXTENDS) { declaration.append("? extends "); } else if (tag == SUPER) { declaration.append("? super "); } startType(); return this; }
private String renderHierarchicalTOCWidget() throws Exception { return new TOCWidget(new WidgetRoot(parent), "!contents -R\n").render(); }
void writeDEREncoded( OutputStream out, int tag, byte[] bytes) throws IOException { out.write(tag); writeLength(out, bytes.length); out.write(bytes); }
public void testLoad() throws Exception {
public void addFactory(TestRunFactory factory) { testRunFactories.add(0, factory); }
public void evaluateExpectation(Object returnValue) { SlimTable parent = scriptTable.getParent(); ExecutionResult testStatus = ((ScenarioTestContext) scriptTable.getTestContext()).getExecutionResult(); parent.getTable().setTestStatusOnRow(getRow(), testStatus); }
public InputStream getData() throws IOException { if (data != null) return new ByteArrayInputStream(data);
public TestSummary run(String pageName, String pageType, String suiteFilter, String excludeSuiteFilter, int port) throws Exception{ JavaFormatter testFormatter=JavaFormatter.getInstance(pageName); testFormatter.setResultsRepository(new JavaFormatter.FolderResultsRepository(outputPath)); testFormatter.setListener(resultListener); Arguments arguments=new Arguments(); arguments.setDaysTillVersionsExpire("0"); arguments.setInstallOnly(false); arguments.setOmitUpdates(true); arguments.setPort(String.valueOf(port)); arguments.setRootPath(fitNesseRootPath); arguments.setCommand(getCommand(pageName, pageType, suiteFilter, excludeSuiteFilter)); new FitNesseMain().launchFitNesse(arguments); return testFormatter.getTotalSummary(); }
public static String formatDate(Date date) { final DateFormat format = createDateFormat(); return format.format(date); }
public void resetLatency();  public void resetMaxLatency();  public long getNumAliveConnections();  public long getDataDirSize();  public long getLogDirSize();  public String getSecureClientPort();  public String getSecureClientAddress();  public long getTxnLogElapsedSyncTime();  public int getJuteMaxBufferSize(); }
private void reinsertPagesViaSetUpTearDownGroups(Map<String, LinkedList<WikiPage>> pageSetUpTearDownGroups) throws Exception { Set groups = pageSetUpTearDownGroups.keySet(); for (Object group : groups) { String setUpAndTearDownGroupKey = group.toString();
RouteBuilder ofType(Class<?> type); RouteBuilder matching(String regex); } <T> T is(final Class<T> type); void is(Class<?> type, Method method);  RouteBuilder with(HttpMethod method);  RouteBuilder with(Set<HttpMethod> methods);  RouteBuilder withPriority(int priority); Route build(); }
public ListTree filesSameAs(File file1, File file2) throws IOException { if (file1.isDirectory()) if (file2.isDirectory()) return dirySameAs(file1,file2); else return error(file1,"One is a folder"); return filesSame(file1,file2); }
public void testNoDuplicates() throws Exception { RecentChanges.updateRecentChanges(page1.getData()); RecentChanges.updateRecentChanges(page1.getData()); WikiPage recentChanges = rootPage.getChildPage("RecentChanges"); List<String> lines = RecentChanges.getRecentChangesLines(recentChanges.getData()); assertEquals(1, lines.size()); assertHasRegexp("PageOne", lines.get(0)); }
public static TypeAdapter on(Fixture fixture, Method method) { TypeAdapter a = on(fixture, method.getReturnType()); a.target = fixture; a.method = method; return a; }
ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets(); }
public void testSetReuseAddress() throws IOException { boolean reuseAddress = serverSideSocket.getReuseAddress(); reuseAddress = !reuseAddress; serverSideSocket.setReuseAddress(reuseAddress); Assert.assertFalse(serverSideSocket.isModeKnown()); Assert.assertEquals(reuseAddress, serverSideSocket.getReuseAddress()); }
public void makeDeb() throws PackagingException { if (control == null || !control.isDirectory()) { throw new PackagingException( "\"" + control + "\" is not a valid 'control' directory)"); } if (changesIn != null) { if (!changesIn.isFile() || !changesIn.canRead()) { throw new PackagingException( "The 'changesIn' setting needs to point to a readable file. " + changesIn + " was not found/readable."); } if (changesOut == null) { throw new PackagingException( "A 'changesIn' without a 'changesOut' does not make much sense."); } if (!isPossibleOutput(changesOut)) { throw new PackagingException( "Cannot write the output for 'changesOut' to " + changesOut); } if (changesSave != null && !isPossibleOutput(changesSave)) { throw new PackagingException( "Cannot write the output for 'changesSave' to " + changesSave); } } else { if (changesOut != null || changesSave != null) { throw new PackagingException( "The 'changesOut' or 'changesSave' settings may only be used when there is a 'changesIn' specified."); } } if (Compression.toEnum(compression) == null) { throw new PackagingException("The compression method '" + compression + "' is not supported (expected 'none', 'gzip' or 'bzip2')"); } if (deb == null) { throw new PackagingException( "You need to specify where the deb file is supposed to be created."); } final File[] controlFiles = control.listFiles(); final DataProducer[] data = new DataProducer[dataProducers.size()]; dataProducers.toArray(data); final Processor processor = new Processor(console, variableResolver); final BinaryPackageControlFile packageControlFile; try { console.info("Creating debian package: " + deb); packageControlFile = processor.createDeb(controlFiles, data, deb, Compression.toEnum(compression)); } catch (Exception e) { throw new PackagingException("Failed to create debian package " + deb, e); } final TextfileChangesProvider changesProvider; try { if (changesOut == null) { return; } console.info("Creating changes file: " + changesOut);
public void execute(RevisionController revisionController, String... filePath) throws RevisionControlException { revisionController.update(filePath); }
private String getSocketOutput(String requestLine, WikiPage page) throws Exception { MockSocket s = new MockSocket(requestLine); FitNesseServer server = new FitNesseServer(context); server.serve(s, 1000); String output = s.getOutput(); return output; }
public FitTestSystem create(Descriptor descriptor, TestSystemListener testSystemListener) throws IOException { int port = Integer.parseInt(descriptor.getVariable("FITNESSE_PORT")); FitTestSystem testSystem = new InProcessFitTestSystem(descriptor, port, testSystemListener); testSystem.build(); return testSystem; }
public void testFNV1A64() { HashMap<String, Long> exp = new HashMap<String, Long>(); exp.put("", 0x84222325L); exp.put(" ", 0x8601817fL); exp.put("hello world!", 0xcd5a2672L); exp.put("Lorem ipsum dolor sit amet, consectetuer adipiscing elit.", 0xbec309a8L); exp.put("wd:com.google", 0x097b3f26L); exp.put("wd:com.google ", 0x1c6c1732L); for (Map.Entry<String, Long> me : exp.entrySet()) { assertHash(HashAlgorithm.FNV1A_64_HASH, me.getKey(),
Future<Boolean> replace(String key, int exp, Object o); <T> Future<T> asyncGet(String key, Transcoder<T> tc); Future<Object> asyncGet(String key); Future<CASValue<Object>> asyncGetAndTouch(final String key, final int exp); <T> Future<CASValue<T>> asyncGetAndTouch(final String key, final int exp, final Transcoder<T> tc); CASValue<Object> getAndTouch(String key, int exp); <T> CASValue<T> getAndTouch(String key, int exp, Transcoder<T> tc); <T> Future<CASValue<T>> asyncGets(String key, Transcoder<T> tc); Future<CASValue<Object>> asyncGets(String key); <T> CASValue<T> gets(String key, Transcoder<T> tc); CASValue<Object> gets(String key); <T> T get(String key, Transcoder<T> tc); Object get(String key); <T> BulkFuture<Map<String, T>> asyncGetBulk(Iterator<String> keys, Iterator<Transcoder<T>> tcs); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Iterator<Transcoder<T>> tcs); <T> BulkFuture<Map<String, T>> asyncGetBulk(Iterator<String> keys, Transcoder<T> tc); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); BulkFuture<Map<String, Object>> asyncGetBulk(Iterator<String> keys); BulkFuture<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> BulkFuture<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); BulkFuture<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Iterator<String> keys, Transcoder<T> tc); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc); Map<String, Object> getBulk(Iterator<String> keys); Map<String, Object> getBulk(Collection<String> keys); <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys); Map<String, Object> getBulk(String... keys); <T> Future<Boolean> touch(final String key, final int exp, final Transcoder<T> tc); <T> Future<Boolean> touch(final String key, final int exp); Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, long by); long incr(String key, int by); long decr(String key, long by); long decr(String key, int by); long incr(String key, long by, long def, int exp); long incr(String key, int by, long def, int exp); long decr(String key, long by, long def, int exp); long decr(String key, int by, long def, int exp); Future<Long> asyncIncr(String key, long by); Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, long by); Future<Long> asyncDecr(String key, int by); long incr(String key, long by, long def); long incr(String key, int by, long def); long decr(String key, long by, long def); long decr(String key, int by, long def); Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs);  Set<String> listSaslMechanisms(); }
protected ListExecutor getListExecutor() throws Exception { SlimFactory slimFactory = JavaSlimFactory.createJavaSlimFactory(); return slimFactory.getListExecutor(); }
public abstract void addArgs(String... args);  public abstract void addOption(String key, String value);  public abstract void addOption(String key, File value);  public abstract void addOption(String key, boolean value);  public abstract void redirectToLog();
public void testChild() throws IOException, KeeperException, InterruptedException { String name = "/foo"; zk.create(name, name.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); String childname = name + "/bar"; zk.create(childname, childname.getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL); Stat stat = new Stat(); List<String> s = zk.getChildren(name, false, stat); assertEquals(stat.getCzxid(), stat.getMzxid()); assertEquals(stat.getCzxid() + 1, stat.getPzxid()); assertEquals(stat.getCtime(), stat.getMtime()); assertEquals(1, stat.getCversion()); assertEquals(0, stat.getVersion()); assertEquals(0, stat.getAversion()); assertEquals(0, stat.getEphemeralOwner()); assertEquals(name.length(), stat.getDataLength()); assertEquals(1, stat.getNumChildren()); assertEquals(s.size(), stat.getNumChildren()); s = zk.getChildren(childname, false, stat); assertEquals(stat.getCzxid(), stat.getMzxid()); assertEquals(stat.getCzxid(), stat.getPzxid()); assertEquals(stat.getCtime(), stat.getMtime()); assertEquals(0, stat.getCversion()); assertEquals(0, stat.getVersion()); assertEquals(0, stat.getAversion()); assertEquals(zk.getSessionId(), stat.getEphemeralOwner()); assertEquals(childname.length(), stat.getDataLength()); assertEquals(0, stat.getNumChildren()); assertEquals(s.size(), stat.getNumChildren()); }
public boolean isEnd() { return currentToken == endToken; } public boolean isType(TokenType type) { return currentToken.getType() == type; }
public void testClasspathWithVariable() throws Exception { WikiPage root = InMemoryPage.makeRoot("RooT"); WikiPage page = crawler.addPage(root, PathParser.parse("ClassPath"), "!define PATH {/my/path}\n!path ${PATH}.jar"); List<?> paths = page.getData().getClasspaths(); assertEquals("/my/path.jar", paths.get(0).toString()); PageData data = root.getData(); data.setContent("!define PATH {/my/path}\n"); root.commit(data); page = crawler.addPage(root, PathParser.parse("ClassPath2"), "!path ${PATH}.jar"); paths = page.getData().getClasspaths(); assertEquals("/my/path.jar", paths.get(0).toString()); }
public void scansLists() { ParserTest.assertScansTokenType(" * item", SymbolType.UnorderedList, true); ParserTest.assertScansTokenType(" * item", SymbolType.UnorderedList, true); ParserTest.assertScansTokenType("* item", SymbolType.UnorderedList, false); ParserTest.assertScansTokenType(" 1 item", SymbolType.OrderedList, true); ParserTest.assertScansTokenType(" 9 item", SymbolType.OrderedList, true); ParserTest.assertScansTokenType("1 item", SymbolType.OrderedList, false); }
@Test public void scansVariables() { ParserTest.assertScansTokenType("${x}", TokenType.Variable, true); }
public void testAttributeButtons() throws Exception { crawler.addPage(root, PathParser.parse("NormalPage")); WikiPage noButtonsPage = crawler.addPage(root, PathParser.parse("NoButtonPage")); for(int i = 0; i < WikiPage.NON_SECURITY_ATTRIBUTES.length; i++) { String attribute = WikiPage.NON_SECURITY_ATTRIBUTES[i]; PageData data = noButtonsPage.getData(); data.removeAttribute(attribute); noButtonsPage.commit(data); } SimpleResponse response = requestPage("NormalPage"); assertSubString("<!--Edit button-->", response.getContent()); assertSubString("<!--Search button-->", response.getContent()); assertSubString("<!--Versions button-->", response.getContent()); assertNotSubString("<!--Suite button-->", response.getContent()); assertNotSubString("<!--Test button-->", response.getContent()); response = requestPage("NoButtonPage"); assertNotSubString("<!--Edit button-->", response.getContent()); assertNotSubString("<!--Search button-->", response.getContent()); assertNotSubString("<!--Versions button-->", response.getContent()); assertNotSubString("<!--Suite button-->", response.getContent()); assertNotSubString("<!--Test button-->", response.getContent()); }
public void testSetupDecoratorShouldThrowInvalidInputExceptionIfDataTypeAndDeltaValueDoNotMatch() throws ParseException { assertInvalidInputException(new String[] {"Column1", "double", "xyz"}, "value 'xyz' is not of type 'double'"); assertInvalidInputException(new String[] {"Column1", "int", "1.2"}, "value '1.2' is not of type 'int'");
public void testVariableSubstitution() throws Exception { Map<String, String> map = new HashMap<String, String>(); map.put("VERSION", "1.2"); map.put("MAINTAINER", "Torsten Curdt <tcurdt@vafer.org>"); String controlFile = "Version: [[VERSION]]\n" + "Maintainer: [[MAINTAINER]]\n" + "NoResolve1: test[[test\n" + "NoResolve2: [[test]]\n"; FilteredFile filteredFile = new FilteredFile(new ByteArrayInputStream(controlFile.getBytes()), new MapVariableResolver(map)); BinaryPackageControlFile d = new BinaryPackageControlFile(filteredFile.toString()); assertEquals("1.2", d.get("Version")); assertEquals("Torsten Curdt <tcurdt@vafer.org>", d.get("Maintainer")); assertEquals("test[[test", d.get("NoResolve1")); assertEquals("[[test]]", d.get("NoResolve2")); }
protected void addStopLink(String stopResponderId) throws IOException { String link = "?responder=stoptest&id=" + stopResponderId; HtmlTag status = HtmlUtil.makeSilentLink(link, new RawHtml("Stop Test")); status.addAttribute("class", "stop"); writeData(HtmlUtil.makeReplaceElementScript("test-action", status.html()).html()); }
private void sendSaslPacket(ClientCnxn cnxn) throws SaslException { LOG.debug("ClientCnxn:sendSaslPacket:length={}", saslToken.length); GetSASLRequest request = new GetSASLRequest(); request.setToken(createSaslToken()); SetSASLResponse response = new SetSASLResponse(); ServerSaslResponseCallback cb = new ServerSaslResponseCallback(); try { cnxn.sendPacket(request, response, cb, ZooDefs.OpCode.sasl);
public Maybe<Integer> match(ScanString input, SymbolStream symbols, int offset) { int size = 0; while (input.charAt(offset + size) == delimiter) size++; return size > 0 ? new Maybe<Integer>(size) : Maybe.noInteger; }
private byte[] receive(DataInputStream din) throws IOException { QuorumAuthPacket authPacket = new QuorumAuthPacket(); BinaryInputArchive bia = BinaryInputArchive.getArchive(din); authPacket.deserialize(bia, QuorumAuth.QUORUM_AUTH_MESSAGE_TAG); return authPacket.getToken(); }
public void build(Translator translator, Symbol symbol, HtmlTag tag) { tag.addAttribute(name, prefix + (index < 0 ? symbol.getContent() : translator.translate(symbol.childAt(index))));
public String toString() { Converter converter = ConverterSupport.getConverter(type); if (converter != null) return converter.toString(value); if (value == null) return "null";
protected void initClient(ConnectionFactory cf) throws Exception { client=new MemcachedClient(cf, AddrUtil.getAddresses("127.0.0.1:64213"));
public boolean isDistributed() { return quorumVerifier != null && (!standaloneEnabled || quorumVerifier.getVotingMembers().size() > 1); }
private static <T> Class<T> forName(String className) throws PluginException { try {
public void jdkSplit() throws Exception { LevelState previous = new LevelState(); previous = assertLevelState("/home/hub/p/eee/src/main/scala:-1: info: compiling", previous, Level.INFO, null); previous = assertLevelState("Compiling 128 source files to /home/hub/p/eee/target/classes at 1312794546514", previous, Level.INFO, null); previous = assertLevelState("Recompiling 1 files", previous, Level.INFO, null); previous = assertLevelState("/home/hub/p/eee/src/main/scala/Service.scala:72: error: type mismatch;", previous, Level.ERROR, "^"); previous = assertLevelState("found : Unit", previous, Level.ERROR, "^"); previous = assertLevelState("required: () => Any", previous, Level.ERROR, "^"); previous = assertLevelState("f()", previous, Level.ERROR, "^"); previous = assertLevelState(" ^", previous, Level.ERROR, null); previous = assertLevelState( "/home/hub/p/eee/src/main/scala/src/main/scala/Service.scala:79: error: type mismatch;", previous, Level.ERROR, "^"); previous = assertLevelState("found : Unit", previous, Level.ERROR, "^"); previous = assertLevelState("required: () => Any", previous, Level.ERROR, "^"); previous = assertLevelState("f()", previous, Level.ERROR, "^"); previous = assertLevelState("^", previous, Level.ERROR, null); previous = assertLevelState("two errors found", previous, Level.ERROR, null); previous = assertLevelState("------------------------------------------------------------------------", previous, Level.INFO, null); previous = assertLevelState("BUILD ERROR", previous, Level.ERROR, null); previous = assertLevelState("------------------------------------------------------------------------", previous, Level.INFO, null); previous = assertLevelState( "wrap: org.apache.commons.exec.ExecuteException: Process exited with an error: 1(Exit value: 1)", previous,
@Test public void scansDefine() { ParserTestHelper.assertScansTokenType("!define x {y}", "Define", true); ParserTestHelper.assertScansTokenType("|!define x {y}|/n", "Define", true); }
private void registerRequestScopedComponentsOn(DefaultListableBeanFactory beanFactory) { registerOn(beanFactory, ParametersInstantiatorInterceptor.class); registerOn(beanFactory, InterceptorListPriorToExecutionExtractor.class); registerOn(beanFactory, URLParameterExtractorInterceptor.class); registerOn(beanFactory, DefaultInterceptorStack.class); registerOn(beanFactory, DefaultRequestExecution.class); registerOn(beanFactory, ResourceLookupInterceptor.class); registerOn(beanFactory, InstantiateInterceptor.class); registerOn(beanFactory, DefaultResult.class); registerOn(beanFactory, ExecuteMethodInterceptor.class); registerOn(beanFactory, DefaultPageResult.class); registerOn(beanFactory, ForwardToDefaultViewInterceptor.class); registerOn(beanFactory, DefaultLogicResult.class); registerOn(beanFactory, OgnlParametersProvider.class); registerOn(beanFactory, DefaultMethodInfo.class); registerOn(beanFactory, DefaultValidator.class); registerOn(beanFactory, DefaultLogicResult.class); registerOn(beanFactory, DefaultResourceNotFoundHandler.class); registerOn(beanFactory, VRaptorRequestProvider.class, true); registerOn(beanFactory, HttpServletRequestProvider.class, true); registerOn(beanFactory, HttpServletResponseProvider.class, true); registerOn(beanFactory, HttpSessionProvider.class, true); registerOn(beanFactory, JstlLocalization.class); beanFactory.registerSingleton(SpringBasedContainer.class.getName(), container); }
public void testRestore() throws Exception {
public void testSubscribe() throws Exception { configProvider.subscribe(DEFAULT_BUCKET_NAME, reconfigurable); }
public void testPrunesSuites() throws Exception { SuiteFilter filter = new SuiteFilter(null, null, null, null); WikiPage prunedSuite = WikiPageUtil.addPage(root, PathParser.parse("MySuite"), "the suite"); PageData data = prunedSuite.getData(); data.setAttribute(PageData.PropertyPRUNE); data.setAttribute("Suite"); prunedSuite.commit(data); assertFalse(filter.getFilterForTestsInSuite(prunedSuite).hasMatchingTests()); assertTrue(filter.getFilterForTestsInSuite(root).hasMatchingTests()); }
public void init() { for (Class<?> requiredType : applicationScoped.keySet()) { Class<?> type = applicationScoped.get(requiredType); logger.debug("Initializing application scope with " + type); this.appContainer.addComponent(type); } componentFactoryRegistry = appContainer.getComponent(ComponentFactoryRegistry.class); registerComponentFactories(appContainer, componentFactoryRegistry.getApplicationScopedComponentFactoryMap()); logger.debug("Session components to initialize: " + sessionScoped.keySet()); logger.debug("Requets components to initialize: " + requestScoped.keySet()); this.initialized = true; }
public void testCAS() throws Exception { final String key = "castestkey";
public ResourceBundle stubResourceBundle(final IogiParametersProviderTest iogiParametersProviderTest, final String key, final String value) { return new ResourceBundle(){ @Override
public void shouldUseTheProvidedConverterDuringFirstRequest() { Converter found = converters.to(CachedConvertersTest.class); assertThat(found, is(equalTo(this.converter))); mockery.assertIsSatisfied(); }
MemcachedNode createMemcachedNode(SocketAddress sa, SocketChannel c, int bufSize);  BlockingQueue<Operation> createOperationQueue();  BlockingQueue<Operation> createReadOperationQueue();  BlockingQueue<Operation> createWriteOperationQueue();  long getOpQueueMaxBlockTime();  NodeLocator createLocator(List<MemcachedNode> nodes);  OperationFactory getOperationFactory();  long getOperationTimeout();  boolean isDaemon();  boolean useNagleAlgorithm();  Collection<ConnectionObserver> getInitialObservers();  FailureMode getFailureMode();  Transcoder<Object> getDefaultTranscoder();  boolean shouldOptimize();  int getReadBufSize();  HashAlgorithm getHashAlg();  long getMaxReconnectDelay();  AuthDescriptor getAuthDescriptor();  int getTimeoutExceptionThreshold();  MetricType enableMetrics();  MetricCollector getMetricCollector(); }
public RunStory runStory(PageFactory factory){ findElement(By.linkText("Run Story")).click(); return factory.runStory(); }
private FitNesseContext initContext(String rootPath, int port) { Builder builder = new Builder(); WikiPageFactory wikiPageFactory = new FileSystemPageFactory(); builder.port = port; builder.rootPath = rootPath; builder.rootDirectoryName = "FitNesseRoot"; builder.root = wikiPageFactory.makeRootPage(builder.rootPath, builder.rootDirectoryName); builder.logger = null; builder.authenticator = new PromiscuousAuthenticator(); return builder.createFitNesseContext(); }
protected void decodePayload(byte[] pl) { final short keylen = (short) decodeShort(pl, 2); keystate = (byte) decodeByte(pl, keylen+4); retCas = (long) decodeLong(pl, keylen+5); ObserveResponse r = ObserveResponse.values()[keystate]; ((ObserveOperation.Callback) getCallback()).gotData(key, retCas, r); getCallback().receivedStatus(STATUS_OK); }
protected VelocityContext updateVelocityContext() throws Exception { velocityContext.put("title", title); velocityContext.put("bodyClass", bodyClass); makeSidebarSection(); velocityContext.put("headerSection", header.html()); if (mainTemplate != null) { velocityContext.put("mainTemplate", mainTemplate); } else { velocityContext.put("mainSection", main.html()); } return velocityContext; }
private boolean isCellStartAt(Parser parser, int position) { return parser.isTypeAt(position, Table.symbolType) || parser.isTypeAt(position, SymbolType.EndCell); }
public SignatureVisitor visitArrayType() { buf.append('['); return this; }
public void accept(final MethodVisitor cv) { cv.visitFieldInsn(opcode, owner, name, desc); }
public void run() { ConcurrencyUtils.put(queue, Either.of(resultOfOperation, (PubSubException) null));
public String makeLinkToExistingWikiPage(WikiPage page, String qualifiedName, String name) { HtmlTag link = new HtmlTag("a", new HtmlText(formatWikiWord(page, name))); link.addAttribute("href", qualifiedName); return link.html(); }
public void shouldObeyPriorityOfRoutes() throws Exception { final Route first = mockery.mock(Route.class, "first"); final Route second = mockery.mock(Route.class, "second"); final Route third = mockery.mock(Route.class, "third"); final Sequence handle = mockery.sequence("invocation"); final Sequence allowed = mockery.sequence("allowed"); mockery.checking(new Expectations() { { allowing(first).getPriority(); will(returnValue(Path.HIGH)); allowing(second).getPriority(); will(returnValue(Path.DEFAULT)); allowing(third).getPriority(); will(returnValue(Path.LOW)); allowing(first).canHandle(with(any(String.class))); will(returnValue(false)); inSequence(handle); allowing(second).canHandle(with(any(String.class))); will(returnValue(false)); inSequence(handle); allowing(third).canHandle(with(any(String.class))); will(returnValue(true)); inSequence(handle); EnumSet<HttpMethod> get = EnumSet.of(HttpMethod.GET); allowing(first).allowedMethods(); will(returnValue(get)); inSequence(allowed); allowing(second).allowedMethods(); will(returnValue(get)); inSequence(allowed); allowing(third).allowedMethods(); will(returnValue(get)); inSequence(allowed); ignoring(anything()); } }); router.add(third); router.add(first); router.add(second); router.parse("anything", HttpMethod.GET, request); mockery.assertIsSatisfied(); }
public void testButtons() throws Exception { request.setResource("files/testDir/"); Responder responder = FileResponder.makeResponder(request, SampleFileUtility.base); response = (SimpleResponse) responder.makeResponse(context, request); assertHasRegexp("Upload", response.getContent()); assertHasRegexp("Create", response.getContent()); }
public int read( byte[] b, int off, int len ) throws IOException { return delegate.read(b, off, len); }
public BulkFuture<Map<String, Object>> asyncGetBulk( Iterator<String> keyIter) { return asyncGetBulk(keyIter, transcoder); }
private void executeTestSystemPages(List<TestPage> pagesInTestSystem, TestSystem testSystem) throws TestExecutionException { for (TestPage testPage : pagesInTestSystem) { testsInProgressCount++;
public static void deleteFileSystemDirectory(File current) throws IOException { for (File child : listFiles(current)) { deleteFileSystemDirectory(child); } deleteFile(current); }
public boolean hasPlugin(String type) { return this.plugins.contains(type); }
protected final UriBasedRoute routeFor(String uri) { UriBasedRoute rule = new UriBasedRoute(router.getProxifier(), uri); this.rules.add(rule); return rule; }
public void testPageMatchWithNullSuites() throws Exception { List<String> pageTypes = Arrays.asList("Test"); Map<String, Boolean> requestInputs = new HashMap<String, Boolean>(); searcher = new AttributeWikiPageFinder(pageTypes, requestInputs, null, false, false); assertTrue(searcher.pageMatches(page)); setUpSuitesProperty(page, "SuiteTest"); assertTrue(searcher.pageMatches(page)); }
public List<Route> rulesFor(ResourceClass resource) { List<Route> routes = new ArrayList<Route>(); Class<?> baseType = resource.getType(); registerRulesFor(baseType, baseType, routes); return routes; }
public synchronized boolean shouldFailNextRequest() { if (remainingRequestsToFail == 0) { return false; }
public void oneInputArgWithTrailingName() throws Exception { makeScenarioTable("|scenario|myScenario|input|trailer|\n"); assertEquals("MyScenarioTrailer", st.getName()); Set<String> inputs = st.getInputs(); assertEquals(1, inputs.size()); assertTrue(inputs.contains("input")); assertEquals(0, st.getOutputs().size()); assertFalse(st.isParameterized()); }
private void loadFile(File file) throws FileNotFoundException, IOException { FileReader fileReader = new FileReader(file); BufferedReader reader = new BufferedReader(fileReader); while (true) { String line = reader.readLine(); if (line == null) { break; } if (line.contains("<converter>")) { line = line.substring(line.indexOf("<converter>") + 11, line.lastIndexOf("</converter>")); logger.info("Vraptor 2 converter found - remember to migrate to vraptor3 : " + line); this.converters.add(line); } } fileReader.close(); reader.close(); }
public WikiPage getFooterPage() throws Exception;
private void checkCounts(TestSystemBase.TestSummary testSummary, Element countsElement) throws Exception { assertEquals(testSummary.right + "", XmlUtil.getTextValue(countsElement, "right")); assertEquals(testSummary.wrong + "", XmlUtil.getTextValue(countsElement, "wrong")); assertEquals(testSummary.ignores + "", XmlUtil.getTextValue(countsElement, "ignores")); assertEquals(testSummary.exceptions + "", XmlUtil.getTextValue(countsElement, "exceptions")); }
public void testGetPageTree() throws Exception { Document doc = importer.getPageTree(); assertNotNull(doc); String xml = XmlUtil.xmlAsString(doc); assertSubString("PageOne", xml); assertSubString("PageTwo", xml); }
public void definesManyTablesCurlyOnEndOfLineSpacesBefore() { checkMultipleTables(" ", 15); }
public void shouldRegisterComponentUsingAllPossibleSupertypes() { mockery.checking(new Expectations() {{ one(scanner).getTypesWithAnnotation(Component.class); will(returnValue(Collections.singletonList(ArrayListSubclass.class))); one(registry).register(ArrayListSubclass.class, ArrayListSubclass.class); one(registry).register(ArrayList.class, ArrayListSubclass.class); one(registry).register(List.class, ArrayListSubclass.class); one(registry).register(Collection.class, ArrayListSubclass.class); one(registry).register(Iterable.class, ArrayListSubclass.class); one(registry).register(Cloneable.class, ArrayListSubclass.class); one(registry).register(Serializable.class, ArrayListSubclass.class); one(registry).register(RandomAccess.class, ArrayListSubclass.class); one(registry).register(AbstractList.class, ArrayListSubclass.class); one(registry).register(AbstractCollection.class, ArrayListSubclass.class); allowing(scanner).getTypesWithAnnotation(Resource.class); allowing(scanner).getTypesWithAnnotation(Intercepts.class); allowing(scanner).getTypesWithAnnotation(Convert.class); allowing(scanner).getTypesWithMetaAnnotation(Stereotype.class); }}); registrar.registerFrom(scanner); mockery.assertIsSatisfied(); }
private FileTxnSnapLog createFileTxnSnapLogWithNoAutoCreateDataDir(File logDir, File snapDir) throws IOException { return createFileTxnSnapLogWithAutoCreateDataDir(logDir, snapDir, "false"); }
public void setUp() throws Exception { root = InMemoryPage.makeRoot("RooT");
private void usage() { System.out.println("usage: java fitnesse.runner.TestRunner [options] host port page-name"); System.out.println("\t-v\tPrint test results."); System.out.println("\t-suiteFilter <filter> \texecutes only tests which are flagged with the given filter"); System.exit(-1); }
public static void main(String[] args) { if (args.length == 2) { ManagedZooKeeperServerMain.main(args); return; } try { QuorumPeerConfig.parse(args); } catch(Exception e) { LOG.fatal("Error in config ", e); System.exit(2); } if (!QuorumPeerConfig.isStandalone()) { try {
private void header() { buffer.append("<div id=\"" + getDivName() + "\"><H3> <span class=\"fail\">Exceptions</span></H3><br/>"); }
public void doCommit(final PageData data) { saveContent(data.getContent()); saveAttributes(data.getProperties()); this.versionsController.prune(this); }
public void parseFrontMatterWithSymbolicLinkText() { assertParses( "---\n" +
public void testCnxManagerListenerThreadConfigurableRetry() throws Exception { final Map<Long, QuorumServer> unresolvablePeers = new HashMap<>(); final long myid = 1L; unresolvablePeers.put(myid, new QuorumServer(myid, "unresolvable-domain.org:2182:2183;2181")); final QuorumPeer peer = new QuorumPeer(unresolvablePeers, ClientBase.createTmpDir(), ClientBase.createTmpDir(), 2181, 3, myid, 1000, 2, 2, 2); final QuorumCnxManager cnxManager = peer.createCnxnManager(); final QuorumCnxManager.Listener listener = cnxManager.listener; final AtomicBoolean errorHappened = new AtomicBoolean(false); listener.setSocketBindErrorHandler(() -> errorHappened.set(true)); listener.start();
public LabelNode gotoLabel(final LabelNode l) {
public void tallyPageCountsShouldCountPagesCorrectly() throws Exception { TestSummary pageCounts = new TestSummary(0, 0, 0, 0); pageCounts.tallyPageCounts(getExecutionResult("TestPage", new TestSummary(32, 0, 0, 0)));
private static String buildQueryStringForSnapshotCommand(final boolean streaming) throws Exception { final Map<String, String> parameters = new HashMap<>(); parameters.put(REQUEST_QUERY_PARAM_STREAMING, String.valueOf(streaming)); return getParamsString(parameters); }
private void init(Collection<InetSocketAddress> serverAddresses, long randomnessSeed, Resolver resolver) { this.sourceOfRandomness = new Random(randomnessSeed); this.resolver = resolver; if (serverAddresses.isEmpty()) { throw new IllegalArgumentException( "A HostProvider may not be empty!"); } this.serverAddresses = shuffle(serverAddresses); currentIndex = -1; lastIndex = -1; }
RevisionControlOperation[] operations(); boolean isNotUnderRevisionControl(); String toString(); boolean isCheckedOut(); boolean isCheckedIn(); void persist(WikiPage page) throws Exception; }
public void testReadWriteByteMax() { testReadWriteShort(Byte.MAX_VALUE); }
static int checkDesc(final String desc, final int start, final boolean canBeVoid) { if ((desc == null) || (start >= desc.length())) { throw new IllegalArgumentException("Invalid type descriptor (must not be null or empty)"); } int index; switch (desc.charAt(start)) { case 'V':
public void testCurrentFrameNoStrike() throws Exception { g.roll(1); assertEquals(1, g.currentFrame()); g.roll(2); assertEquals(2, g.currentFrame()); }
public String makeHttpRequest() { String request = "GET /" + pageName + "?responder=suite"; if (suiteFilter != null) request += "&suiteFilter=" + suiteFilter; if (excludeSuiteFilter != null) request += "&excludeSuiteFilter=" + excludeSuiteFilter; request += "&format=xml"; return request + " HTTP/1.1\r\n\r\n"; }
public void converseWithLeader(InputArchive ia, OutputArchive oa, Leader l) throws IOException {  LearnerInfo li = new LearnerInfo(1, 0x10000); byte liBytes[] = new byte[12]; ByteBufferOutputStream.record2ByteBuffer(li, ByteBuffer.wrap(liBytes));  QuorumPacket qp = new QuorumPacket(Leader.FOLLOWERINFO, ZxidUtils.makeZxid(20, 0), liBytes, null); oa.writeRecord(qp, null); readPacketSkippingPing(ia, qp); Assert.assertEquals(Leader.LEADERINFO, qp.getType()); Assert.assertEquals(ZxidUtils.makeZxid(21, 0), qp.getZxid()); Assert.assertEquals(ByteBuffer.wrap(qp.getData()).getInt(), 0x10000); qp = new QuorumPacket(Leader.ACKEPOCH, 0, new byte[4], null); oa.writeRecord(qp, null); readPacketSkippingPing(ia, qp); Assert.assertEquals(Leader.DIFF, qp.getType()); readPacketSkippingPing(ia, qp); Assert.assertEquals(Leader.NEWLEADER, qp.getType()); Assert.assertEquals(ZxidUtils.makeZxid(21, 0), qp.getZxid()); qp = new QuorumPacket(Leader.ACK, qp.getZxid(), null, null); oa.writeRecord(qp, null); readPacketSkippingPing(ia, qp); Assert.assertEquals(Leader.UPTODATE, qp.getType()); }
public void correctInstructionsForInstallTableForMultipleLibraries() throws Exception { buildInstructionsFor("|echo support|\n|file support|\n"); List<Object> expectedInstructions = list( list("install_id_0", "make", "library1", "EchoSupport"), list("install_id_1", "make", "library2", "FileSupport") ); assertEquals(expectedInstructions, instructions); }
private void test304IfNotModified(String resource) throws Exception { Locale.setDefault(Locale.US); Calendar now = new GregorianCalendar(); now.add(Calendar.DATE, -1); String yesterday = SimpleResponse.makeStandardHttpDateFormat().format(now.getTime()); now.add(Calendar.DATE, 2); String tomorrow = SimpleResponse.makeStandardHttpDateFormat().format(now.getTime()); request.setResource(resource); request.addHeader("If-Modified-Since", yesterday); response = responder.makeResponse(context, request); assertEquals(200, response.getStatus()); request.setResource(resource); request.addHeader("If-Modified-Since", tomorrow); SimpleResponse notModifiedResponse = (SimpleResponse) responder.makeResponse(context, request); assertEquals(304, notModifiedResponse.getStatus()); assertEquals("", notModifiedResponse.getContent()); assertMatches(HTTP_DATE_REGEXP, notModifiedResponse.getHeader("Date")); assertNotNull(notModifiedResponse.getHeader("Cache-Control")); assertNull(notModifiedResponse.getHeader("Content-Type")); }
public void inputAndOutputWithSymbol() throws Exception { makeTables( "!|scenario|echo|input|giving|output|\n" + "|check|echo|@input|@output|\n" + "\n" + "!|script|\n" + "|$V=|echo|7|\n" + "|echo|$V|giving|$V|\n" ); Map<String, Object> pseudoResults = SlimClient.resultToMap( list( list("scriptTable_id_0", "7"), list("scriptTable_id_1/scriptTable_s_id_0", "7") ) ); evaluateExpectations(pseudoResults); String scriptTable = script.getChildren().get(0).getTable().toString(); String expectedScript = "[[scenario, echo, input, giving, output], [check, echo, $V->[7], pass($V->[7])]]"; assertEquals(expectedScript, scriptTable); }
public void setUp() throws Exception { } public void tearDown() throws Exception { } public void testGetValueFor() throws Exception { assertEquals(0, Base64.getValueFor((byte) 'A')); assertEquals(26, Base64.getValueFor((byte) 'a')); assertEquals(52, Base64.getValueFor((byte) '0')); } public void testDecodeNothing() throws Exception { assertEquals("", Base64.decode("")); } public void testDecodeOneChar() throws Exception { assertEquals("a", Base64.decode("YQ==")); } public void testDecodeTwoChars() throws Exception { assertEquals("a:", Base64.decode("YTo=")); } public void testDecodeLongSample() throws Exception { assertEquals("Aladdin:open sesame", Base64.decode("QWxhZGRpbjpvcGVuIHNlc2FtZQ==")); } public void testEncodeNothing() throws Exception { assertEquals("", Base64.encode("")); } public void testEncodeOneChar() throws Exception { assertEquals("YQ==", Base64.encode("a")); } public void testEncodeTwoChars() throws Exception { assertEquals("YTo=", Base64.encode("a:")); } public void testEncodeThreeChars() throws Exception { assertEquals("YWJj", Base64.encode("abc")); } public void testEncodeLongSample() throws Exception { assertEquals("QWxhZGRpbjpvcGVuIHNlc2FtZQ==", Base64.encode("Aladdin:open sesame")); } }
public InputStream getResultStream() throws Exception { return new ByteArrayInputStream(output.toString().getBytes()); }
public void currentClockTimeInMillisShouldBeRebasedToConstructorArg() throws Exception { Date startOfTheDecade = ymdDateFormat.parse("2010-01-01"); clock = new DateAlteringClock(startOfTheDecade); assertThat(ymdDateFormat.format(new Date(Clock.currentTimeInMillis())), is("2010-01-01")); }
public InetSocketAddress getRemoteAddress(); public interface Stats{ public long getOutstandingRequests(); public long getPacketsReceived(); public long getPacketsSent(); } public Stats getStats(); }
public void testShouldAskRevisionControllerToUpdatePage() throws Exception { revisionController.update(contentAndPropertiesFilePathFor(FS_PARENT_PAGE)); replay(revisionController); createPage(FS_PARENT_PAGE); request.setResource(FS_PARENT_PAGE); invokeResponderAndCheckSuccessStatus(); }
public void testLoadCertificateFromTrustStore() throws IOException, GeneralSecurityException { List<X509Certificate> certs = PemReader.readCertificateChain(x509TestContext.getTrustStoreFile(KeyStoreFileType.PEM)); assertEquals(1, certs.size()); assertEquals(x509TestContext.getTrustStoreCertificate(), certs.get(0)); }
public void canProvideJodaTimeConverters() { executeInsideRequest(new WhatToDo<String>() {
public void shouldUseTheDefaulJvmtLocale() throws ParseException { when(request.getSession()).thenReturn(session); when(request.getAttribute("javax.servlet.jsp.jstl.fmt.locale.request")).thenReturn(null); when(session.getAttribute("javax.servlet.jsp.jstl.fmt.locale.session")). thenReturn(null); when(context.getAttribute("javax.servlet.jsp.jstl.fmt.locale.application")). thenReturn(null); when(context.getInitParameter("javax.servlet.jsp.jstl.fmt.locale")). thenReturn(null); when(request.getLocale()).thenReturn(null); assertThat(Locale.getDefault(), is(equalTo(converter.getLocale()))); }
void processResult(int rc, String path, Object ctx, String name, Stat stat); }  @InterfaceAudience.Public interface StringCallback extends AsyncCallback {  void processResult(int rc, String path, Object ctx, String name); }  @InterfaceAudience.Public interface VoidCallback extends AsyncCallback {  void processResult(int rc, String path, Object ctx); }  @InterfaceAudience.Public interface MultiCallback extends AsyncCallback {  void processResult(int rc, String path, Object ctx, List<OpResult> opResults); }  interface EphemeralsCallback extends AsyncCallback {  void processResult(int rc, Object ctx, List<String> paths); } }
public void testValidCharacterSet() { tc.setCharset("KOI8"); }
public void testGetQuotaLimit() { assertEquals(0L, QuotaMetricsUtils.getQuotaLimit(0L, -1L)); assertEquals(1L, QuotaMetricsUtils.getQuotaLimit(-1L, 1L)); assertEquals(0L, QuotaMetricsUtils.getQuotaLimit(-2L, 0L)); }
public void updateLocator(List<MemcachedNode> nodes, Config conf) { setKetamaNodes(nodes); }
MemcachedConnection createConnection(List<InetSocketAddress> addrs) throws IOException;  BlockingQueue<Operation> createOperationQueue();  NodeLocator createLocator(List<MemcachedNode> nodes); }
public <T> Serializer from(T object); public boolean accepts(String format); }
public void testTooManySyncsNonessential() throws Exception { LearnerSyncThrottler throttler = new LearnerSyncThrottler(5, syncType); for (int i = 0; i < 6; i++) { throttler.beginSync(false);
public void onEachLink(TarArchiveEntry entry) throws IOException {
public void start() throws IOException { commandRunner.asynchronousStart(); }
public BlockingQueue<Operation> createReadOperationQueue() { return readQueueFactory == null ? super.createReadOperationQueue() : readQueueFactory.create();
public void testDistributionFromChangesProvider() throws Exception { final String input = "release distribution=production\n" + " * change1\n" + " * change2\n" + "release distribution=staging, date=14:00 13.01.2007, version=12324, urgency=low, by=tcurdt@joost.com\n" + " * change1\n" + " * change2\n" + "release distribution=development, date=12:00 10.01.2007, version=10324, urgency=low, by=tcurdt@joost.com\n" + " * change1\n" + " * change2\n"; BinaryPackageControlFile packageControlFile = new BinaryPackageControlFile(); packageControlFile.set("Package", "package"); packageControlFile.set("Version", "version"); packageControlFile.set("Date", "Mon, 20 Aug 2007 15:25:57 +0200"); final TextfileChangesProvider provider = new TextfileChangesProvider(new ByteArrayInputStream(input.getBytes(UTF_8)), packageControlFile); final ChangeSet[] changeSets = provider.getChangesSets(); assertNotNull(changeSets); assertEquals(3, changeSets.length); assertEquals("production", changeSets[0].getDistribution()); assertEquals("staging", changeSets[1].getDistribution()); assertEquals("development", changeSets[2].getDistribution()); }
protected SlimTestSystem getTestSystem() throws IOException { WikiPage page = getPage(); SlimClientBuilder builder = new SlimClientBuilder(page.getData(), getDescriptor()); builder.setFastTest(fastTest); SlimClient slimClient = builder.build(); return new HtmlSlimTestSystem(slimClient, this, new ExecutionLog(page, slimClient.getTestRunner())); }
public void shouldBeAbleToConvertWithENUS() { when(request.getAttribute("javax.servlet.jsp.jstl.fmt.locale.request")).thenReturn("en_US"); assertThat(converter.convert("10.00", Float.class, bundle), is(equalTo(new Float("10.00")))); assertThat(converter.convert("10.01", Float.class, bundle), is(equalTo(new Float("10.01")))); }
public void close() throws IOException { historyFormatter.close(); testHistory = new TestHistory(); testHistory.readHistoryDirectory(context.getTestHistoryDirectory());
public void intercept(InterceptorStack stack, ResourceMethod method, Object resourceInstance) throws InterceptionException { } public boolean accepts(ResourceMethod method) { return true; } } @Test public void shouldReturnAnInterceptorWhichAcceptsTheGivenResource() throws InterceptionException, IOException { mockery.checking(new Expectations() { { one(container).instanceFor(CustomInterceptor.class); will(returnValue(interceptor)); one(interceptor).accepts(method); will(returnValue(true)); } }); registry.register(interceptors); Interceptor[] types = registry.interceptorsFor(method, container); assertThat(types.length, is(1)); assertThat(types[0], is(equalTo(interceptor))); mockery.assertIsSatisfied(); } @Test public void shouldNotReturnAnInterceptorWhichDoesNotAcceptTheGivenResource() { mockery.checking(new Expectations() { { one(container).instanceFor(CustomInterceptor.class); will(returnValue(interceptor)); one(interceptor).accepts(method); will(returnValue(false)); } }); registry.register(interceptors); Interceptor[] types = registry.interceptorsFor(method, container); assertThat(types.length, is(0)); mockery.assertIsSatisfied(); } @Test public void shouldReturnNoInterceptorIfThereIsNoneRegistered() { Interceptor[] types = registry.interceptorsFor(method, container); assertThat(types.length, is(0)); mockery.assertIsSatisfied(); } }
public void testResponse() throws Exception { Responder responder = new ErrorResponder(new Exception("some error message")); SimpleResponse response = (SimpleResponse)responder.makeResponse(new FitNesseContext(), new MockRequest()); assertEquals(400, response.getStatus()); String body = response.getContent(); assertHasRegexp("<html>", body); assertHasRegexp("<body", body); assertHasRegexp("java.lang.Exception: some error message", body); }
private WikiTestPage mockWikiTestPage() { WikiPage mock = mock(WikiPage.class); when(mock.isRoot()).thenReturn(true); when(mock.getName()).thenReturn("WikiPage"); when(mock.getPageCrawler()).thenReturn(new PageCrawlerImpl(mock)); return new WikiTestPage(mock); }
public Map<Watcher.Event.EventType, Set<Watcher>> removeWatcher( String clientPath, Watcher watcher, Watcher.WatcherType watcherType, boolean local, int rc ) throws KeeperException {
public static void main(String[] args) throws Exception { for(String arg: args) { KerberosName name = new KerberosName(arg);
public static void main(String[] args) throws IOException, InterruptedException, BookieException { Bookie b = new Bookie(5000, null, new File("/tmp"), new File[] { new File("/tmp") }); CounterCallback cb = new CounterCallback(); long start = System.currentTimeMillis(); for (int i = 0; i < 100000; i++) { ByteBuffer buff = ByteBuffer.allocate(1024); buff.putLong(1); buff.putLong(i); buff.limit(1024); buff.position(0); cb.incCount(); b.addEntry(buff, cb, null, new byte[0]); } cb.waitZero(); long end = System.currentTimeMillis(); System.out.println("Took " + (end-start) + "ms"); }
public void testMakeBreadCrumbsWithCurrentPageLinkedWithEmptyArray() throws Exception { try { HtmlUtil.makeBreadCrumbsWithCurrentPageLinked(".");
private void checkProperties(WikiPage page, String source, boolean isRoot) throws Exception { WikiPageProperties props = page.getData().getProperties(); WikiImportProperty importProperty = WikiImportProperty.createFrom(props); assertNotNull(importProperty); assertEquals(source, importProperty.getSource()); assertEquals(isRoot, importProperty.isRoot()); }
public LabelNode rangeLabel(final LabelNode l) { return (LabelNode) rangeTable.get(l); }
private boolean isComponentFactory(Class<?> requiredType, Class<?> type) { return ComponentFactory.class.isAssignableFrom(type) && !requiredType.equals(ComponentFactory.class); }
public void testIsSecure() throws Exception { assertTrue((new ShutdownResponder().getSecureOperation() instanceof AlwaysSecureOperation) == true); }
public void process(WikiPage page) { for (WikiPage hit : testPageList) { if (hit.equals(page)) return; } if (page.getData().hasAttribute("Test")) testPageList.add(page);
public void shortResultShouldShowPassFailBarWithPadding() throws Exception { addPageDirectory("TestPage"); File pageDirectory = addPageDirectory("TestPage"); addTestResult(pageDirectory, "20090503110451_30_20_3_0"); addTestResult(pageDirectory, "20090503143157_10_5_3_0"); makeResponse(); StringBuilder expected = new StringBuilder(); for (int i=0; i<10; i++) { expected.append("<td class=\"pass\">&nbsp</td>"); } expected.append(".*"); for (int i=0; i<5; i++) { expected.append("<td class=\"fail\">&nbsp</td>"); } expected.append(".*"); for (int i=0; i<35; i++) { expected.append("<td class=\"ignore\">&nbsp</td>"); } assertHasRegexp(expected.toString(), response.getContent()); }
protected String createEvaluationMessage(String actual, String expected) { String evaluationMessage; String replacedExpected = Utils.unescapeHTML(replaceSymbols(expected)); int dolDolIndex = 0; while ((dolDolIndex = replacedExpected.indexOf("$$")) != -1) { replacedExpected = replacedExpected.substring(0, dolDolIndex) + replacedExpected.substring(dolDolIndex+1); } if (actual == null) evaluationMessage = fail("null");
public DeleteOperation delete(String key, OperationCallback operationCallback) { return new DeleteOperationImpl(key, operationCallback); }
public void next(ResourceMethod method, Object resourceInstance) throws InterceptionException { if (interceptors.isEmpty()) { logger.debug("All registered interceptors have been called. End of VRaptor Request Execution."); return; } InterceptorHandler handler = interceptors.poll(); handler.execute(this, method, resourceInstance); }
public void slimHostDefaultsTolocalhost() throws Exception { Descriptor descriptor = mock(Descriptor.class); assertEquals("localhost", new SlimClientBuilder(descriptor).determineSlimHost()); }
public void useConverterFromCustomizing() { ConverterRegistry.addConverter(CustomClass.class, new CustomConverter()); Converter<CustomClass> converter = ConverterRegistry.getConverterForClass(CustomClass.class); assertEquals("customConverter", converter.toString(new CustomClass())); }
public void testPageMatchesQueryWithExcludedSetUpsAndIncludedTearDowns() throws Exception { Map<String, Boolean> attributes = new HashMap<String, Boolean>(); attributes.put("SetUp", false); attributes.put("TearDown", true); List<PageType> pageTypes = Arrays.asList(TEST, STATIC, SUITE); searcher = generateSearcherByPageTypesAndSearchAttributes(pageTypes, attributes); setPageProperty(page, TEST.toString(), "true"); assertFalse(searcher.pageMatches(page)); page = crawler.addPage(root, PathParser.parse("SetUp")); assertFalse(searcher.pageMatches(page)); page = crawler.addPage(root, PathParser.parse("TearDown")); assertTrue(searcher.pageMatches(page)); page = crawler.addPage(root, PathParser.parse("SuiteSetUp")); assertFalse(searcher.pageMatches(page)); page = crawler.addPage(root, PathParser.parse("SuiteTearDown")); assertTrue(searcher.pageMatches(page)); }
public void shutdown() {
public void testShouldUseSpecifiedRevisionController() throws Exception { Properties testProperties = new Properties(); testProperties.setProperty(ComponentFactory.VERSIONS_CONTROLLER_CLASS, NullVersionsController.class.getName()); fileSystemPageFactory = new FileSystemPageFactory(testProperties); VersionsController defaultRevisionController = fileSystemPageFactory.getVersionsController(); assertEquals(NullVersionsController.class, defaultRevisionController.getClass()); assertEquals(14, ((NullVersionsController) defaultRevisionController).getHistoryDepth()); }
CASResponse cas(String key, long casId, int exp, Object value); <T> CASResponse cas(String key, long casId, T value, Transcoder<T> tc); <T> Future<Boolean> add(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> add(String key, int exp, Object o); <T> Future<Boolean> set(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> set(String key, int exp, Object o); <T> Future<Boolean> replace(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> replace(String key, int exp, Object o); <T> Future<T> asyncGet(String key, Transcoder<T> tc); Future<Object> asyncGet(String key); Future<CASValue<Object>> asyncGetAndTouch(final String key, final int exp); <T> Future<CASValue<T>> asyncGetAndTouch(final String key, final int exp, final Transcoder<T> tc); CASValue<Object> getAndTouch(String key, int exp); <T> CASValue<T> getAndTouch(String key, int exp, Transcoder<T> tc); <T> Future<CASValue<T>> asyncGets(String key, Transcoder<T> tc); Future<CASValue<Object>> asyncGets(String key); <T> CASValue<T> gets(String key, Transcoder<T> tc); CASValue<Object> gets(String key); <T> T get(String key, Transcoder<T> tc); Object get(String key); <T> BulkFuture<Map<String, T>> asyncGetBulk(Iterator<String> keys, Iterator<Transcoder<T>> tcs); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Iterator<Transcoder<T>> tcs); <T> BulkFuture<Map<String, T>> asyncGetBulk(Iterator<String> keys, Transcoder<T> tc); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); BulkFuture<Map<String, Object>> asyncGetBulk(Iterator<String> keys); BulkFuture<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> BulkFuture<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); BulkFuture<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Iterator<String> keys, Transcoder<T> tc); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc); Map<String, Object> getBulk(Iterator<String> keys); Map<String, Object> getBulk(Collection<String> keys); <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys); Map<String, Object> getBulk(String... keys); <T> Future<Boolean> touch(final String key, final int exp, final Transcoder<T> tc); <T> Future<Boolean> touch(final String key, final int exp); Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, long by); long incr(String key, int by); long decr(String key, long by); long decr(String key, int by); Future<Long> asyncIncr(String key, long by); Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, long by); Future<Long> asyncDecr(String key, int by); long incr(String key, long by, long def, int exp); long incr(String key, int by, long def, int exp); long decr(String key, long by, long def, int exp); long decr(String key, int by, long def, int exp); Future<Long> asyncIncr(String key, long by, long def, int exp); Future<Long> asyncIncr(String key, int by, long def, int exp); Future<Long> asyncDecr(String key, long by, long def, int exp); Future<Long> asyncDecr(String key, int by, long def, int exp); long incr(String key, long by, long def); long incr(String key, int by, long def); long decr(String key, long by, long def); long decr(String key, int by, long def); Future<Long> asyncIncr(String key, long by, long def); Future<Long> asyncIncr(String key, int by, long def); Future<Long> asyncDecr(String key, long by, long def); Future<Long> asyncDecr(String key, int by, long def); Future<Boolean> delete(String key); Future<Boolean> delete(String key, long cas); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs); CountDownLatch broadcastOp(final BroadcastOpFactory of); CountDownLatch broadcastOp(final BroadcastOpFactory of, Collection<MemcachedNode> nodes);  Set<String> listSaslMechanisms(); }
public void testComplete_closesResultRepositoryAndAddsToTotalTestSummary() throws Exception{ jf.setTotalSummary(new TestSummary(1,2,3,4)); jf.testComplete(buildNestedTestPage(), new TestSummary(5,6,7,8)); assertEquals(new TestSummary(6,8,10,12),jf.getTotalSummary()); verify(mockResultsRepository).close(); }
private boolean isPossibleOutput( File file ) { if (file.exists()) { return file.isFile() && file.canWrite(); } return true; }
Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, int by); long incr(String key, int by, long def) throws OperationTimeoutException; long decr(String key, int by, long def) throws OperationTimeoutException; Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs);  void authenticate(String mechs[], CallbackHandler cbh) throws OperationException;  Set<String> listSaslMechanisms(); }
public InterceptorHandler handlerFor(Class<? extends Interceptor> type) { if (type.isAnnotationPresent(Lazy.class)) { InterceptorHandler handler = cachedHandlers.get(type); if (handler == null) { LazyInterceptorHandler value = new LazyInterceptorHandler(container, type); cachedHandlers.putIfAbsent(type, value); return value; } else { return handler; } } return new ToInstantiateInterceptorHandler(container, type); }
public OperationFuture<Boolean> flush(final int delay) { final AtomicReference<Boolean> flushResult= new AtomicReference<Boolean>(null); final ConcurrentLinkedQueue<Operation> ops= new ConcurrentLinkedQueue<Operation>(); CountDownLatch blatch = broadcastOp(new BroadcastOpFactory(){ public Operation newOp(final MemcachedNode n, final CountDownLatch latch) { Operation op=opFact.flush(delay, new OperationCallback(){ public void receivedStatus(OperationStatus s) { flushResult.set(s.isSuccess()); } public void complete() { latch.countDown(); }}); ops.add(op); return op; }}); return new OperationFuture<Boolean>(null, blatch, flushResult, operationTimeout) {
public static Test suite() { return TestSuiteMaker.makeSuite("html", new Class[] { HtmlPageTest.class,
protected void performExecution() throws Exception { addToResponse(HtmlUtil.getHtmlOfInheritedPage("PageHeader", page)); SetupTeardownIncluder.includeInto(data, true); if (data.getContent().length() == 0) addEmptyContentMessage(); testSystem.sendPageData(data); testSystem.bye(); }
private void executeTests(MultipleTestsRunner testRunner) throws IOException, TestExecutionException { JavaFormatter testFormatter = new JavaFormatter(suiteName); testFormatter.setResultsRepository(new JavaFormatter.FolderResultsRepository(outputDir)); testRunner.addTestSystemListener(testFormatter); testRunner.executeTestPages(); TestSummary summary = testFormatter.getTotalSummary(); assertTrue(msgAtLeastOneTest(suiteName, summary), summary.getRight() > 0 || summary.getWrong() > 0 || summary.getExceptions() > 0); }
public PageData getDataVersion(String versionName) throws Exception { return null; }
public void prepareResultRepository(TestResultRepository resultRepository) throws IOException; }
public void add(long delta) { } @Override public long get() { return 0; } } private static final class NullSummary implements Summary { private static final NullSummary INSTANCE = new NullSummary(); @Override public void add(long value) { } } private static final class NullSummarySet implements SummarySet { private static final NullSummarySet INSTANCE = new NullSummarySet(); @Override public void add(String key, long value) { } } }
public void addToMyList(final User user, final Dvd dvd) { final User sessionUser = refreshUser(); validator.checking(new Validations() {{ that(user.getLogin(), is(sessionUser.getLogin()),"user", "you_cant_add_to_others_list"); that(sessionUser.getDvds(), not(hasItem(dvd)), "dvd", "you_already_have_this_dvd"); }}); validator.onErrorUse(Results.page()).of(UsersController.class).home(); dao.add(new DvdRental(user, dvd)); result.use(Results.logic()).redirectTo(UsersController.class).home(); }
public void oneLineTable() { assertParsesWithOffset(
public void testIsNotHierarchical() throws Exception { assertFalse(new TOCWidget(new WidgetRoot(parent), "!contents\n").isRecursive()); }
public String verifyThreadCount(ArrayList<QuorumPeer> peerList, long ecnt) throws InterruptedException { String failure = null; for (int i = 0; i < 120; i++) { Thread.sleep(500); failure = _verifyThreadCount(peerList, ecnt); if (failure == null) { return null; } } return failure; }
MemcachedNode createMemcachedNode(SocketAddress sa, SocketChannel c, int bufSize);  BlockingQueue<Operation> createOperationQueue();  NodeLocator createLocator(List<MemcachedNode> nodes);  OperationFactory getOperationFactory();  long getOperationTimeout();  boolean isDaemon(); }
public void setup() { this.mockery = new Mockery(); this.router = mockery.mock(Router.class); this.response = mockery.mock(HttpServletResponse.class); this.request = mockery.mock(HttpServletRequest.class); this.context = mockery.mock(ServletContext.class); this.logicResult = new DefaultLogicResult(response, context, request,router); }
public static FitNesseContext makeTestContext() { Properties properties = new Properties(); properties.setProperty("FITNESSE_PORT", String.valueOf(PORT)); return makeTestContext(InMemoryPage.newInstance(), properties); }
public String urlFor(Class<?> type, Method m, Object... params) { return parameters.fillUri(parameterNames, params); }
public Response makeResponse(FitNesseContext context, Request request) throws Exception { SimpleResponse response = new SimpleResponse(); VelocityContext velocityContext = new VelocityContext(); StringWriter writer = new StringWriter(); Template template = VelocityFactory.getVelocityEngine().getTemplate("searchForm.vm"); velocityContext.put("pageTitle", new PageTitle("Search Form")); velocityContext.put("pageTypeAttributes", PageType.values()); velocityContext.put("actionAttributes", SEARCH_ACTION_ATTRIBUTES); velocityContext.put("securityAttributes", SECURITY_ATTRIBUTES); velocityContext.put("specialAttributes", SPECIAL_ATTRIBUTES); velocityContext.put("searchedRootPage", request.getResource()); velocityContext.put("request", request); template.merge(velocityContext, writer); response.setContent(writer.toString()); return response; }
public void setUp() throws Exception { seeker = new SimpleSocketSeeker(); sender = new MockResponseSender(); responder = new SocketCatchingResponder(); context = FitNesseUtil.makeTestContext(); dealer = FitTestSystem.socketDealer(); request = new MockRequest(); }
public void testBadConnection() throws Exception { String errorMessage = "FAILURE"; connectionStatusSize = "0000000007"; prepareSessionProcess(); socketOutput.write(errorMessage.getBytes()); int exitValue = process.waitFor(); String stdoutString = new String(stdoutBytes.toByteArray()); assertTrue(exitValue != 0);
public void shouldValidateParameters() throws Exception { final ResourceMethod method = mockery.methodFor(Component.class, "otherMethod", int.class); mockery.checking(new Expectations() {{ Object[] values = new Object[]{0}; one(parametersProvider).getParametersFor(method, errors, bundle); will(doAll(addErrorsToList("error1"),returnValue(values))); one(validator).addAll(errors); one(stack).next(method, null); one(params).setParameters(values); }}); instantiator.intercept(stack, method, null); mockery.assertIsSatisfied(); }
public void testGetObject() throws Exception { final MemcachedClientFactoryBean factory = new MemcachedClientFactoryBean(); factory.setDaemon(true); factory.setFailureMode(FailureMode.Cancel); factory.setHashAlg(HashAlgorithm.CRC32_HASH); factory.setProtocol(Protocol.BINARY); factory.setServers(TestConfig.IPV4_ADDR + ":22211 " + TestConfig.IPV4_ADDR + ":22212"); factory.setShouldOptimize(true); final Transcoder<Object> transcoder = new SerializingTranscoder(); factory.setTranscoder(transcoder); final MemcachedClient memcachedClient = (MemcachedClient)factory.getObject(); Assert.assertEquals("deamon", true, memcachedClient.isDaemon()); Assert.assertEquals("servers", 2, memcachedClient.getUnavailableServers().size()); Assert.assertSame("transcoder", transcoder, memcachedClient.getTranscoder()); }
public void setup() { this.mockery = new Mockery(); this.provider = mockery.mock(ConnectionProvider.class); this.first = mockery.mock(Migration.class, "first"); this.second = mockery.mock(Migration.class, "second"); List<Migration> list = Arrays.asList(this.first, this.second); this.migrator = new Migrator(provider, new ArrayBasedMigrationProvider(list)); mockery.checking(new Expectations() { {
public static String translateTo(SourcePage page, VariableSource variableSource) throws Exception { ParsingPage.Cache cache = new ParsingPage.Cache(); return new HtmlTranslator(page, new ParsingPage(page)).translateTree(Parser.make(new ParsingPage(page, new ParsingPage.CompositeVariableSource(cache, variableSource), cache), page.getContent(), SymbolProvider.wikiParsingProvider).parse()); }
public void shutdown() { timeToDie = true; queuedRequests.add(requestOfDeath); nextProcessor.shutdown(); }
public void reset(String pathToNotifyOn, Event.EventType requiredEventType) { super.reset(); this.pathToNotifyOn = pathToNotifyOn; this.requiredEventType = requiredEventType; }
public void setup() throws Exception { MockitoAnnotations.initMocks(this); this.removal = new EmptyElementsRemoval(); this.provider = new OgnlParametersProvider(converters, nameProvider, request, removal, container, new OgnlFacade(converters, removal)); this.errors = new ArrayList<Message>(); when(converters.to(Long.class)).thenReturn(new LongConverter()); when(converters.to(long.class)).thenReturn(new PrimitiveLongConverter()); when(converters.to(String.class)).thenReturn(new StringConverter()); when(request.getSession()).thenReturn(session); buyA = method("buyA", House.class); kick = method("kick", AngryCat.class); error = method("error", WrongCat.class); array = method("array", Long[].class); list = method("list", List.class); listOfObject= method("listOfObject", List.class); abc = method("abc", ABC.class); simple = method("simple", Long.class); string = method("string", String.class); stringArray = method("stringArray", String[].class); dependency = method("dependency", Result.class); primitive = method("primitive", long.class); generic = DefaultResourceMethod.instanceFor(Specific.class, Generic.class.getDeclaredMethod("generic", Object.class)); }
public void analyze(Class<?> type) { List<Class<? extends Interceptor>> interceptors = new ArrayList<Class<? extends Interceptor>>(); if (type.isAnnotationPresent(Intercepts.class)) { if (Interceptor.class.isAssignableFrom(type)) { logger.debug("Found interceptor for " + type); interceptors.add((Class<Interceptor>) type); } else if (InterceptorSequence.class.isAssignableFrom(type)) { logger.debug("Found interceptor sequence for " + type); interceptors.addAll(parseSequence(type)); } else { logger.error("Annotation " + Intercepts.class + " found in " + type + " but this is neither an Interceptor nor an InterceptorSequence. Ignoring"); } } registry.register(interceptors); }
public void canMakeSuiteExecutionReport() throws Exception { SuiteExecutionReport original = new SuiteExecutionReport(); original.version = "version"; original.rootPath = "rootPath"; original.date = DateTimeUtil.getDateFromString("12/31/1969 18:00:00"); original.finalCounts = new TestSummary(1, 2, 3, 4); original.setTotalRunTimeInMillis(totalTimeMeasurementWithElapsedMillis(41)); long time = DateTimeUtil.getTimeFromString("12/31/1969 18:00:00"); SuiteExecutionReport.PageHistoryReference reference = new SuiteExecutionReport.PageHistoryReference("dah", time, 3L); reference.getTestSummary().wrong = 99; original.addPageHistoryReference(reference); StringWriter writer = new StringWriter(); original.toXml(writer, VelocityFactory.getVelocityEngine()); ExecutionReport report = ExecutionReport.makeReport(writer.toString()); assertTrue(report instanceof SuiteExecutionReport); assertEquals(original, report); assertEquals(41, report.getTotalRunTimeInMillis()); }
public Operation newOp(MemcachedNode n, final CountDownLatch latch) { return opFact.saslMechs(new OperationCallback() { @Override
public void testRender() throws Exception { CollapsableWidget widget = new CollapsableWidget(new MockWidgetRoot(), "!* title\ncontent\n*!"); String html = widget.render(); assertSubString("title", html); assertSubString("content", html); assertSubString("collapsableOpen.gif", html); assertSubString("<a href=\"javascript:expandAll();\">Expand All</a>", html); assertSubString("<a href=\"javascript:collapseAll();\">Collapse All</a>", html); }
protected TestSystemListener newTestInProgressFormatter() { return new PageInProgressFormatter(context); }
public void testBulkReconfig() throws Exception { qu = new QuorumUtil(3);
public void start(ServletContext context) { } public void stop() { } } }
public Parse last() { return more == null ? this : more.last(); }
public void warning(String message, String sourceName, int line, String lineSource, int lineOffset) { if (line < 0) { System.out.println("\n" + message);
public void testCurrentServersAreObserversInNextConfig() throws Exception { ClientBase.setupTestEnv();
public void testCompleteShouldSetRunTimeForCurrentReference() throws Exception { FitNesseContext context = mock(FitNesseContext.class); WikiTestPage page = new WikiTestPage(new WikiPageDummy("name", "content")); SuiteExecutionReportFormatter formatter = new SuiteExecutionReportFormatter(context, page.getSourcePage()); TimeMeasurement timeMeasurement = mock(TimeMeasurement.class); when(timeMeasurement.startedAt()).thenReturn(65L); when(timeMeasurement.elapsed()).thenReturn(2L); formatter.newTestStarted(page, timeMeasurement); when(timeMeasurement.elapsed()).thenReturn(99L); TestSummary testSummary = new TestSummary(4, 2, 7, 3); formatter.testComplete(page, testSummary, timeMeasurement); assertThat(formatter.suiteExecutionReport.getPageHistoryReferences().size(), is(1)); PageHistoryReference reference = formatter.suiteExecutionReport.getPageHistoryReferences().get(0); assertThat(reference.getTestSummary(), equalTo(testSummary)); assertThat(reference.getRunTimeInMillis(), is(99L)); }
public void write(int b) {
public void newTestStarted_SwitchesResultRepositoryToCurrentTest() throws Exception{ WikiTestPage wp=buildNestedTestPage(); jf.testStarted(wp); verify(mockResultsRepository).open(nestedPageName); }
public boolean equals(Object o) { if (!(o instanceof QuorumServer)) { return false; } QuorumServer qs = (QuorumServer) o; if ((qs.id != id) || (qs.type != type)) { return false; } if (!addr.equals(qs.addr)) { return false; } if (!electionAddr.equals(qs.electionAddr)) { return false; } if (!checkAddressesEqual(clientAddr, qs.clientAddr)) { return false; } return checkAddressesEqual(secureClientAddr, qs.secureClientAddr); }
public void shouldNotInstantiateIfThereIsAlreadyAResource() throws InterceptionException, IOException { final DogController myDog = new DogController(); InstantiateInterceptor interceptor = new InstantiateInterceptor(null); interceptor.intercept(stack, method, myDog); verify(stack).next(method, myDog); }
public void expire(long sessionId) { try { ZooLog.logTextTraceMessage(
public static Function<Route, ResourceMethod> matches(final String uri, final HttpMethod method, final MutableRequest request) { return new Function<Route, ResourceMethod>() { public ResourceMethod apply(Route route) {
public void testParseMethodParsesInputStringAndConvertsItToAppropriateObject() throws Exception { Object parsedObject = DataType.INTEGER.parse("10"); assertEquals(10, ((Integer) parsedObject).intValue()); parsedObject = DataType.DOUBLE.parse("10.3"); assertEquals(10.3, ((Double) parsedObject).doubleValue(), 0.01); parsedObject = DataType.STRING.parse("Some String"); assertEquals("Some String", ((String) parsedObject)); parsedObject = DataType.DATE.parse("10"); assertEquals(10, ((Integer) parsedObject).intValue()); }
private void addFormRow(HtmlTableListingBuilder table) throws Exception { HtmlTag nameInput = HtmlUtil.makeInputTag("text", "linkName"); HtmlTag pathInput = HtmlUtil.makeInputTag("text", "linkPath"); pathInput.addAttribute("size", "40"); HtmlTag submitButton = HtmlUtil.makeInputTag("submit", "submit", "Create Symbolic Link"); table.addRow(new HtmlElement[]{nameInput, pathInput, submitButton}); }
public void elapsedSecondsShouldBeDoubleRepresentationOfElapsed() throws Exception { assertThat(timeMeasurementWithElapsedMillis(1).elapsedSeconds(), is(0.001d)); assertThat(timeMeasurementWithElapsedMillis(1000).elapsedSeconds(), is(1.0d)); assertThat(timeMeasurementWithElapsedMillis(2345).elapsedSeconds(), is(2.345d)); assertThat(timeMeasurementWithElapsedMillis(0).elapsedSeconds(), is(0d)); }
public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; final Revalidation that = (Revalidation) o; return sessionId == that.sessionId && timeout == that.timeout && handler.equals(that.handler); }
static String buildIdOfHeaderLine(final String textFromHeaderLine) { return HtmlUtil.remainRfc3986UnreservedCharacters(textFromHeaderLine); }
private List<String> recursivelyAddMatchingFiles(String path, File dir) { String singleWildcardPath = convertDoubleToSingleWildcard(path); return getMatchingSubfiles(singleWildcardPath, dir); }
public void tearDown() throws Exception { x509TestContext.clearSystemProperties(x509Util); System.clearProperty(x509Util.getSslHandshakeDetectionTimeoutMillisProperty()); forceClose(listeningSocket); forceClose(serverSideSocket); forceClose(clientSocket); workerPool.shutdown(); workerPool.awaitTermination(1000, TimeUnit.MILLISECONDS); x509Util.close(); }
protected File getArtifactJar(String groupId, String artifactId, String version, String classifier) throws Exception { Artifact artifact = factory.createArtifactWithClassifier(groupId, artifactId, version, ScalaMojoSupport.JAR, classifier); resolver.resolve(artifact, remoteRepos, localRepo); return artifact.getFile(); }
public void setup() { this.mockery = new Mockery(); this.container = mockery.mock(Container.class); this.info = mockery.mock(ComponentInfoProvider.class); this.stack = mockery.mock(InterceptorStack.class); this.interceptor = new ResultSupplierInterceptor(container, info); }
private List<SlimAssertion> instructionsForRow(int row) throws SyntaxError { String firstCell = table.getCellContents(0, row).trim(); List<SlimAssertion> assertions; String match; if (firstCell.equalsIgnoreCase("start")) assertions = startActor(row); else if (firstCell.equalsIgnoreCase("check")) assertions = checkAction(row); else if (firstCell.equalsIgnoreCase("check not")) assertions = checkNotAction(row); else if (firstCell.equalsIgnoreCase("reject")) assertions = reject(row); else if (firstCell.equalsIgnoreCase("ensure")) assertions = ensure(row); else if (firstCell.equalsIgnoreCase("show")) assertions = show(row); else if (firstCell.equalsIgnoreCase("note")) assertions = note(row); else if ((match = ifSymbolAssignment(0, row)) != null) assertions = actionAndAssign(match, row); else if (firstCell.length() == 0) assertions = note(row); else if (firstCell.trim().startsWith("#") || firstCell.trim().startsWith("*")) assertions = note(row); else {
public void setUp() throws Exception { root = InMemoryPage.makeRoot("root"); }
public void tearDown() throws Exception { super.tearDown(); LOG.info("FINISHED " + getTestName()); }
private void assertParsed(String s) { assertEquals(s,ListTree.parse(s).toString()); }
public static String generateDigest(String idPassword) throws NoSuchAlgorithmException { String[] parts = idPassword.split(":", 2); byte[] digest = MessageDigest.getInstance("SHA1").digest(idPassword.getBytes()); return parts[0] + ":" + base64Encode(digest); }
public void defaultIsPerTestSystemTestRun() { TestRun run = factory.createRun(Collections.emptyList()); assertEquals(PerTestSystemTestRun.class, run.getClass()); factory.addProvider(pages -> Optional.empty()); run = factory.createRun(Collections.emptyList()); assertEquals(PerTestSystemTestRun.class, run.getClass()); }
private ServerCnxnFactory startServer(File tmpDir) throws IOException, InterruptedException { final int CLIENT_PORT = PortAssignment.unique(); ZooKeeperServer zks = new ZooKeeperServer(tmpDir, tmpDir, 3000); ServerCnxnFactory f = ServerCnxnFactory.createFactory(CLIENT_PORT, -1); f.startup(zks); Assert.assertNotNull("JMX initialization failed!", zks.jmxServerBean); Assert.assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT)); return f; }
public void storeResult(String k, boolean result) { if(result) { success++;
private void fillPluginFeatureFactories() { pluginFeatureFactories.add(new PropertyBasedPluginFeatureFactory(componentFactory)); for (PluginFeatureFactory factory : ServiceLoader.load(PluginFeatureFactory.class)) { pluginFeatureFactories.add(factory);
public Object instantiate(Target<?> target, Parameters parameters) { return multiInstantiator.instantiate(target, parameters); }
public void testComplete(WikiTestPage test, TestSummary testSummary) throws IOException { for (BaseFormatter formatter : formatters) formatter.testComplete(test, testSummary);
private List<Assertion> invokeRow(int row) throws SyntaxError { List<Assertion> assertions = new ArrayList<Assertion>(); checkRow(row); assertions.add(callUnreportedFunction("reset")); assertions.addAll(setVariables(row)); assertions.add(callUnreportedFunction("execute")); assertions.addAll(callFunctions(row)); return assertions; }
public void registersAndUsesTheLastConverterInstaceRegisteredForTheSpecifiedType() { converters.register(MyConverter.class); converters.register(MySecondConverter.class); mockery.checking(new Expectations() { { one(container).register(MySecondConverter.class); one(container).instanceFor(MySecondConverter.class); will(returnValue(null)); one(container).instanceFor(MySecondConverter.class); will(returnValue(new MySecondConverter())); } }); Converter<?> found = converters.to(MyData.class, container); assertThat(found.getClass(), is(typeCompatibleWith(MySecondConverter.class))); mockery.assertIsSatisfied(); }
public void startup() { logger.info("Starting up the database... configuration should be done here"); Client guilherme = new Client(); guilherme.setId(1L); guilherme.setName("Guilherme Silveira"); guilherme.setEmails(Arrays.asList("guilherme.silveira@caelum.com.br")); guilherme.setAge(27); add(guilherme); }
public WidgetRoot getPrecompiledScenarioWidgets() throws Exception { if (precompiledScenarioWidgets == null) precompiledScenarioWidgets = new WidgetRoot(getWidgetRootContent(), page); return precompiledScenarioWidgets; }
public void notifyDataSetChanged() { super.notifyDataSetChanged(); filter(); sort(); }
public void register(Class<?> type) { AnnotatedGenericBeanDefinition definition = new AnnotatedGenericBeanDefinition(type); String name = beanNameGenerator.generateBeanName(definition, applicationContext); applicationContext.registerBeanDefinition(name, definition); }
private void extractCredentials() { if (cfg.containsKey("rest.http.auth")) { credentials = new Credentials(cfg.getProperty("rest.http.auth", ""));
public void doesNothingIfNotAnOldComponent() throws InterceptionException, IOException, NoSuchMethodException { final OldComponent resourceInstance = new OldComponent(); final ResourceMethod method = mockery.methodFor(OldComponent.class, "method"); mockery.checking(new Expectations() { { one(stack).next(method, resourceInstance); } }); validator.intercept(stack, method, resourceInstance); mockery.assertIsSatisfied(); }
public void shouldSerializeCollection() { String expectedResult = "<order>\n <price>15.0</price>\n <comments>pack it nicely, please</comments>\n</order>"; expectedResult += expectedResult; Order order = new Order(new Client("guilherme silveira"), 15.0, "pack it nicely, please"); serializer.from(Arrays.asList(order, order)).serialize(); assertThat(result(), is(equalTo(expectedResult))); }
boolean isRoot(WikiPage page) throws Exception; WikiPage getRoot(WikiPage page) throws Exception; void traverse(WikiPage root, FitNesseTraversalListener pageCrawlerTest) throws Exception; WikiPage getSiblingPage(WikiPage page, WikiPagePath pathRelativeToSibling) throws Exception; }
public void testComplete(WikiTestPage test, TestSummary testSummary) throws IOException { timeMeasurement.stop(); referenceToCurrentTest.setTestSummary(testSummary); referenceToCurrentTest.setRunTimeInMillis(timeMeasurement.elapsed()); suiteExecutionReport.addPageHistoryReference(referenceToCurrentTest); suiteExecutionReport.tallyPageCounts(ExecutionResult.getExecutionResult(test.getName(), testSummary)); super.testComplete(test, testSummary); }
private void resetDefaultRealm() throws IOException { InputStream templateResource = new FileInputStream( getKrb5conf().getAbsolutePath()); String content = IOUtil.readInput(templateResource); content = content.replaceAll("default_realm = .*\n", "default_realm = " + getRealm() + "\n"); IOUtil.writeFile(content, getKrb5conf()); }
public void testExecutionStatusHtml() throws Exception { ExecutionLog log = new ExecutionLog(new WikiPageDummy(), new CommandRunner()); String status = formatter.executionStatus(log); assertSubString("<div id=\"execution-status\">", status); }
public void toString_should_return_string_which_contains_the_int_when_value_is_a_int() { Integer value = 31415962; String current = converter.toString(value); assertEquals(value.toString(), current); }
String evaluationMessage(String actual, String expected) { this.actual = actual; this.expected = expected; String evaluationMessage; if (isExceptionMessage(actual)) evaluationMessage = expected + " " + makeExeptionMessage(actual).toHtml(); else evaluationMessage = createEvaluationMessage(actual, expected).toHtml(); this.evaluationMessage = HtmlTable.colorize(evaluationMessage); return evaluationMessage; }
public void starting(FrameworkMethod method) { testName = method.getName(); LOG.info("STARTING " + testName); }
public boolean equals(Object o) { if (this == o) { return true; } if (!(o instanceof GetDataResult)) { return false; } GetDataResult other = (GetDataResult) o; return getType() == other.getType() && stat.equals(other.stat) && Arrays.equals(data, other.data); }
protected void importRemotePageContent(WikiPage localPage) { if (fail) importerClient.pageImportError(localPage, new Exception("blah"));
public void oneRowFirstCellMatchesSecondCellBlank() throws Exception { assertQueryResults("|2||\n", ListUtility.<Object>list(
String getUri(); String getName();  boolean matches(Method method); }
public void registerDestroyListener(LifecycleListener listener) {
private Assertion callUnreportedFunction(String functionName) { final Instruction functionCall = callFunction(getTableName(), functionName); dontReportExceptionsInTheseInstructions.add(functionCall.getId()); return makeAssertion(functionCall, Expectation.NOOP_EXPECTATION); }
public boolean isAbleToInstantiate(Target<?> target) { Object value = request.getAttribute(target.getName()); return value != null && target.getClassType().isInstance(value); }
public boolean shouldIncludeScenarioLibraries() { boolean isSlim = "slim".equalsIgnoreCase(sourcePage.getVariable(WikiPageIdentity.TEST_SYSTEM)); String includeScenarioLibraries = sourcePage.getVariable("INCLUDE_SCENARIO_LIBRARIES"); boolean includeScenarios = "true".equalsIgnoreCase(includeScenarioLibraries); boolean notIncludeScenarios = "false".equalsIgnoreCase(includeScenarioLibraries); return includeScenarios || (!notIncludeScenarios && isSlim); }
public void onNew(ServerCnxn sc) { ConnectionBean b=new ConnectionBean(sc,ManagedZooKeeperServer.this); map.put(sc, b); ZooTrace.logTraceMessage(LOG, ZooTrace.JMX_TRACE_MASK, "Registering new ConnectionBean: "+b); MBeanRegistry.getInstance().register(b, svrBean); }
public void testCommandPatternCSharp() throws Exception { String specifiedPageText = "!define COMMAND_PATTERN {%m -r fitSharp.Slim.Service.Runner,fitsharp.dll %p}\n"; WikiPage specifiedPage = makeTestPage(specifiedPageText); Descriptor descriptor = new Descriptor(specifiedPage.readOnlyData(), false, getClassPath(specifiedPage)); assertEquals("%m -r fitSharp.Slim.Service.Runner,fitsharp.dll %p", descriptor.getCommandPattern()); Descriptor descriptor1 = new Descriptor(specifiedPage.readOnlyData(), true, getClassPath(specifiedPage)); assertEquals("%m -r fitSharp.Slim.Service.Runner,fitsharp.dll %p", descriptor1.getCommandPattern()); }
protected void setUp() throws Exception { super.setUp(); mPG = TestData.GetTest1(getContext()).groups.get(0);
void saveProperties() throws IOException { OutputStream os = null; File propFile = getPropertiesFile(); try { os = new FileOutputStream(propFile);
public void testRenameSubpageOfRoot() throws Exception { WikiPage source = crawler.addPage(root, PathParser.parse("SourcePage"), "gunk ^TargetPage gunk"); WikiPage target = crawler.addPage(source, PathParser.parse("TargetPage")); renamer = new PageReferenceRenamer(root, target, "RenamedPage"); renamer.renameReferences(); String updatedSourceContent = source.getData().getContent(); assertEquals("gunk >RenamedPage gunk", updatedSourceContent); }
public void testMoveToRoot() throws Exception { WikiPagePath originalPath = PathParser.parse("PageOne.PageA"); assertTrue(crawler.pageExists(root, originalPath)); movePage(originalPath, PathParser.parse(""), true); WikiPage movedPage = root.getChildPage(pageA.getName()); assertFalse(crawler.pageExists(root, originalPath)); assertEquals("content", movedPage.getData().getContent()); assertEquals(PathParser.parse("PageA"), movedPage.getPageCrawler().getFullPath(movedPage)); pageOne = root.getChildPage(pageOne.getName()); assertEquals(".PageA", pageOne.getData().getContent()); }
public void shouldDiscoverGenericTypeParametersWhenThereIsInheritance() throws Exception { Assert.assertEquals("resource",extractor.nameFor(XController.class.getMethod("edit").getGenericReturnType())); Assert.assertEquals("resourceList",extractor.nameFor(XController.class.getMethod("list").getGenericReturnType())); }
public int hashCode() { return (int) (getType() * 35 + path.hashCode() + (stat == null ? 0 : stat.getMzxid()));
private void checkInvalidSnapshot(String filename, File tmpDir) throws IOException { checkInvalidSnapshot(filename, false, tmpDir); checkInvalidSnapshot(filename, true, tmpDir); }
protected void doExecute() throws Exception { if (script == null && scriptFile == null) { throw new MojoFailureException( "Either script or scriptFile must be defined"); } if (script != null && scriptFile != null) { throw new MojoFailureException( "Only one of script or scriptFile can be defined"); } currentScriptIndex++; if (StringUtils.isEmpty(includeScopes)) { if (scriptFile != null) { includeScopes = "compile, test, runtime"; } else { includeScopes= Scopes.PLUGIN.name(); } }
public Constant newDouble(final double value) { key1.set(value); Constant result = get(key1); if (result == null) { result = new Constant(key1); put(result); } return result; }
public void sendPacket(Record request, Record response, AsyncCallback cb, int opCode) throws IOException {
public BigDecimal convert(String value, Class<? extends BigDecimal> type, ResourceBundle bundle) { if (value == null || value.trim().length() == 0) { return null; } try { final Locale locale = localization.getLocale();
public void scanFailed(Object ctx, Exception exception) { ConcurrencyUtils.put(queue, Either.of((Message) null, exception)); }
public void testConnectionStatReset() throws IOException, InterruptedException { testCommand("connection_stat_reset"); }
public void noStarvationOfNonLocalCommittedRequestsTest() throws Exception { final String path = "/noStarvationOfCommittedRequests"; processor.queuedRequests = new MockRequestsQueue(); Set<Request> nonLocalCommits = new HashSet<Request>(); for (int i = 0; i < 10; i++) { Request nonLocalCommitReq = newRequest( new CreateRequest(path, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL.toFlag()), OpCode.create, 51, i + 1); processor.committedRequests.add(nonLocalCommitReq); nonLocalCommits.add(nonLocalCommitReq); } for (int i = 0; i < 10; i++) { processor.initThreads(defaultSizeOfThreadPool); processor.stoppedMainLoop = true; processor.run(); } Assert.assertTrue("commit request was not processed", processedRequests.containsAll(nonLocalCommits));
public void XsetItems(String arg0) { task.XsetItems(arg0); }
public String addTo(String originalValue, Object value, int numberofTime) { double doubleValue = ((Double) value).doubleValue() * numberofTime; double results = Double.parseDouble(originalValue) + doubleValue; return String.valueOf(new Double(results).floatValue()); }
public static void addZKStartStopAuditLog() { if (isAuditEnabled()) { log(getZKUser(), AuditConstants.OP_START, Result.SUCCESS);
private List<Object> checkAction(int row) { int lastColInAction = table.getColumnCountInRow(row) - 1; table.getCellContents(lastColInAction, row); addExpectation(new ReturnedValueExpectation(getInstructionTag(), lastColInAction, row)); return invokeAction(1, lastColInAction - 1, row); }
synchronized public void readEntry(long ledgerId, long entryId, ReadEntryCallback cb, Object ctx) throws IOException, InterruptedException { completionSemaphore.acquire(); readCompletions.put(new CompletionKey(ledgerId, entryId), new Completion<ReadEntryCallback>(cb, ctx)); ByteBuffer tmpEntry = ByteBuffer.allocate(8 + 8 + 8); tmpEntry.putInt(20); tmpEntry.putInt(BookieProtocol.READENTRY); tmpEntry.putLong(ledgerId); tmpEntry.putLong(entryId); tmpEntry.position(0);
public void testName() { assertTrue("Name was " + mPE.title, mPE.title.equals("Amazon")); }
public void testLoadKeyStore() throws Exception { String path = x509TestContext.getKeyStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath(); KeyStore ks = new PKCS12FileLoader.Builder() .setKeyStorePath(path) .setKeyStorePassword(x509TestContext.getKeyStorePassword()) .build() .loadKeyStore(); assertEquals(1, ks.size()); }
public ExceptionResult evaluateException(ExceptionResult exceptionResult) { if (exceptionResult.isNoMethodInClassException() || exceptionResult.isNoInstanceException()) { return null; } table.updateContent(col, row, exceptionResult); getTestContext().incrementErroredTestsCount(); return exceptionResult; }
public String toString() { States state = getState(); return ("State:" + state.toString() + (state == States.CONNECTED ?
public void startVector(ArrayList v, String tag) throws IOException; public void endVector(ArrayList v, String tag) throws IOException; public void startMap(TreeMap v, String tag) throws IOException; public void endMap(TreeMap v, String tag) throws IOException; }
public static int readInt(InputStream is) throws IOException { byte[] buf = new byte[4]; is.read(buf, 0, 4); return readInt(buf, 0); }
protected void initService() throws IOException { ControllerServerConfig controllerConfig = (ControllerServerConfig) config; controllerConfig.ensureComplete(); this.controller = new ZooKeeperServerController(controllerConfig); this.listener = new CommandListener(controller, controllerConfig); this.serverCnxnFactory = controller.getCnxnFactory(); }
public void buildDefaultTestSystemName() throws Exception { WikiPage testPage = crawler.addPage(root, PathParser.parse("TestPage"), ""); String testSystemName = TestSystem.getDescriptor(testPage, null, false).getTestSystemName(); Assert.assertEquals("fit:fit.FitServer", testSystemName); }
private String runFitnesseMainWith(String... args) throws Exception { FitNesseMain.dontExitAfterSingleCommand = true; PrintStream out = System.out; ByteArrayOutputStream outputBytes = new ByteArrayOutputStream(); System.setOut(new PrintStream(outputBytes)); FitNesseMain.main(args); System.setOut(out); String response = outputBytes.toString(); return response; }
public void testClearSign() throws Exception { final InputStream ring = getClass().getClassLoader().getResourceAsStream("org/vafer/gpg/secring.gpg"); assertNotNull(ring); final String inputStr = "TEST1 \n-TEST2 \n \nTEST3 \n"; final byte[] input = inputStr.getBytes("UTF-8"); final String expectedOutputStr = "-----BEGIN PGP SIGNED MESSAGE-----\n" + "Hash: SHA1\n" + "\n" + "TEST1\n" + "- -TEST2\n" + "\n" + "TEST3\n" + "-----BEGIN PGP SIGNATURE-----\n" + "Version: BCPG v1.47\n" + "\n" + "iEYEARECABAFAkax1rgJEHM9pIAuB02PAABIJgCghFmoCJCZ0CGiqgVLGGPd/Yh5\n" + "FQQAnRVqvI2ij45JQSHYJBblZ0Vv2meN\n" + "=aAAT\n" + "-----END PGP SIGNATURE-----\n"; final byte[] expectedOutput = expectedOutputStr.getBytes("UTF-8"); final ByteArrayOutputStream os = new ByteArrayOutputStream(); SigningUtils.clearSign(new ByteArrayInputStream(input), ring, "2E074D8F", "test", os); final byte[] output = fixCRLF(os.toByteArray()); final int from = expectedOutputStr.indexOf("iEYEAREC"); final int until = expectedOutputStr.indexOf("=aAAT") + 5; Arrays.fill(output, from, until, (byte) '?'); Arrays.fill(expectedOutput, from, until, (byte) '?'); assertEquals(new String(expectedOutput), new String(output)); }
private void endFormals() { if (seenFormalParameter) { declaration.append('>');
public void testCreatePersistent() throws Exception { qu.enableLocalSession(true); qu.startAll(); QuorumPeer leader = qu.getLeaderQuorumPeer(); ZooKeeper zk = new ZooKeeper(qu.getConnectString(leader), CONNECTION_TIMEOUT, this); CreateRequest createRequest = new CreateRequest("/success", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT.toFlag()); ByteArrayOutputStream baos = new ByteArrayOutputStream(); BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos); createRequest.serialize(boa, "request"); ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());
public String testSummary() { String summaryContent = wasInterrupted ? TESTING_INTERRUPTED : ""; summaryContent += makeSummaryContent(); HtmlTag script = JavascriptUtil.makeReplaceElementScript("test-summary", summaryContent); script.add("document.getElementById(\"test-summary\").className = \"" + (wasInterrupted ? ExecutionResult.ERROR : ExecutionResult.getExecutionResult(relativeName, getAssertionCounts())) + "\";"); return script.html(); }
public void testKeyfile() throws IOException, InvalidDBException { Context ctx = getContext(); AssetManager am = ctx.getAssets(); InputStream is = am.open("kdb_with_xml_keyfile.kdb", AssetManager.ACCESS_STREAMING); ImporterV3 importer = new ImporterV3(); importer.openDatabase(is, "12345", "/sdcard/key"); is.close();
public Object aroundSlimInvoke(FixtureInteraction interaction, Method method, Object... arguments) throws Exception { METHODS.add(method.getName()); return interaction.methodInvoke(method, this, arguments); }
private boolean isSetUpPage(WikiPage page) throws Exception { return setUpPageNames.contains(page.getName()); }
public String next() { if (!hasNext()) { throw new NoSuchElementException(); } String localPath = path; ++level; if (path.equals("/")) { path = ""; } else { path = path.substring(0, path.lastIndexOf('/')); if (path.length() == 0) { path = "/"; } } return localPath; }
public void processRequest(Request request) throws RequestProcessorException { executedFlag = true; }
public static void deleteFileSystemDirectory(String dirPath) { deleteFileSystemDirectory(new File(dirPath)); }
public int hashCode() { return (int) (getType() * 35 + stat.getMzxid()); }
public void buildSearchIndex(Context ctx) { searchHelper = new SearchDbHelper(ctx); initSearch(); searchHelper.open(); searchHelper.insertEntry(pm.getEntries()); searchHelper.close(); indexBuilt = true; }
abstract QuorumAuthServer getQuorumAuthServer();  abstract void registerLearnerHandlerBean(LearnerHandler learnerHandler, Socket socket);  abstract void unregisterLearnerHandlerBean(LearnerHandler learnerHandler); }
private void createRequest() { page = WikiPageUtil.addPage(root, PathParser.parse(PAGE_NAME), ""); request = new MockRequest(); addDefaultRequestInputs(); }
public boolean isAuthenticated(String username, String password) throws Exception { return true; }
public void testUntrustedAuth() { X509AuthenticationProvider provider = createProvider(clientCert); MockServerCnxn cnxn = new MockServerCnxn(); cnxn.clientChain = new X509Certificate[] { unknownCert }; Assert.assertEquals(KeeperException.Code.AUTHFAILED, provider.handleAuthentication(cnxn, null)); }
public static void main(String[] args) { TestRunner.main(new String[]{"fitnesse.wikitext.widgets.ParentWidgetTest"}); }
public void originalContentCanBeRetrievedViaVersionInfo() throws Exception { PageData data = page.getData(); data.setContent("new content"); VersionInfo version = page.commit(data); PageData loadedData = page.getDataVersion(version.getName()); assertEquals("original content", loadedData.getContent()); }
void setCell(int col, int row, String contents); int addRow(List<String> list); void appendCellToRow(int row, String contents); String getUnescapedCellContents(int col, int row); String getCellResult(int col,int row); void appendChildTable(int row, Table table); void setTestStatusOnRow(int row, ExecutionResult testStatus); void setCell(int col, int row, Result response); void appendToCell(int col, int row, Result response); }
public void redirectsToCustomOnErrorPage() { try { validator.onError().goTo(MyComponent.class).logic();
public void canBuildInstructionsForMultipleCallsToSameFunction() throws Exception { makeDynamicDecisionTableAndBuildInstructions(dynamicDecisionTableWithSameFunctionMultipleTimes); int n = 0; List<Instruction> expectedInstructions = list( new MakeInstruction(id(n++), TABLE_INSTANCE_NAME, "fixture", new Object[]{"argument"}), new CallInstruction(id(n++), TABLE_INSTANCE_NAME, "table", new Object[]{list(list("func?", "func?"), list("3", "5"), list("7", "9"))}), new CallInstruction(id(n++), TABLE_INSTANCE_NAME, "beginTable"), new CallInstruction(id(n++), TABLE_INSTANCE_NAME, "reset"), new CallInstruction(id(n++), TABLE_INSTANCE_NAME, "execute"), new CallInstruction(id(n++), TABLE_INSTANCE_NAME, "get", new Object[]{"func"}), new CallInstruction(id(n++), TABLE_INSTANCE_NAME, "get", new Object[]{"func"}), new CallInstruction(id(n++), TABLE_INSTANCE_NAME, "reset"), new CallInstruction(id(n++), TABLE_INSTANCE_NAME, "execute"), new CallInstruction(id(n++), TABLE_INSTANCE_NAME, "get", new Object[]{"func"}), new CallInstruction(id(n++), TABLE_INSTANCE_NAME, "get", new Object[]{"func"}), new CallInstruction(id(n++), TABLE_INSTANCE_NAME, "endTable") ); assertEquals(expectedInstructions, instructions); }
public String getVariable(String name) throws Exception { Maybe<String> local = getLocalVariable(name); return local.isNothing() ? getInitializedVariableRoot().getVariable(name) : local.getValue(); }
public TestResultRecord findMostRecentTestRun() { try { readHistoryFromPageDirectory(directory); } catch (ParseException e) {
String getQuorumAddress();  String getElectionAddress();  String getClientAddress();  String getLearnerType();  boolean isLeader(); }
protected void setUp() throws Exception { qt.setUp(); hostPort = ClientTest.hostPort; }
public void testShouldReturnPageNotFoundMessageWhenPageDoesNotExist() throws Exception { replay(this.revisionController); final String pageName = "InvalidPageName"; this.request.setResource(pageName); invokeResponderAndCheckResponseContains("The requested resource: <i>" + pageName + "</i> was not found."); }
public void testMapper() throws Exception { project.executeTarget("perm-mapper"); File deb = new File("target/test-classes/test.deb"); assertTrue("package not build", deb.exists()); ArchiveWalker.walkData(deb, new ArchiveVisitor<TarArchiveEntry>() { public void visit(TarArchiveEntry entry, byte[] content) throws IOException {
public void testHrule() throws Exception { ParentWidget page = new WidgetRoot("-----", mockSource); WikiWidget widget = page.nextChild(); assertEquals(HruleWidget.class, widget.getClass()); }
public void testToString() throws ConfigException { String provided = ipv4config + ":participant;0.0.0.0:1237"; String expected = ipv4config + ":participant;0.0.0.0:1237"; QuorumServer qs = new QuorumServer(0, provided); Assert.assertEquals("Use IP address", expected, qs.toString()); provided = ipv4config + ";0.0.0.0:1237"; expected = ipv4config + ":participant;0.0.0.0:1237"; qs = new QuorumServer(0, provided); Assert.assertEquals("Type unspecified", expected, qs.toString()); provided = ipv4config + ":observer;0.0.0.0:1237"; expected = ipv4config + ":observer;0.0.0.0:1237"; qs = new QuorumServer(0, provided); Assert.assertEquals("Observer type", expected, qs.toString()); provided = ipv4config + ":participant;1237"; expected = ipv4config + ":participant;0.0.0.0:1237"; qs = new QuorumServer(0, provided); Assert.assertEquals("Client address unspecified", expected, qs.toString()); provided = ipv4config + ":participant;1.2.3.4:1237"; expected = ipv4config + ":participant;1.2.3.4:1237"; qs = new QuorumServer(0, provided); Assert.assertEquals("Client address specified", expected, qs.toString()); provided = "example.com:1234:1236:participant;1237"; expected = "example.com:1234:1236:participant;0.0.0.0:1237"; qs = new QuorumServer(0, provided); Assert.assertEquals("Use hostname", expected, qs.toString()); }
public void testSimpleVersionTasks() throws Exception { WikiPagePath path = PathParser.parse("MyPageOne"); WikiPage page = crawler.addPage(root, path, "old content"); PageData data = page.getData(); data.setContent("new content"); VersionInfo previousVersion = page.commit(data); Collection<VersionInfo> versions = page.getVersions(); assertEquals(1, versions.size()); assertEquals(true, versions.contains(previousVersion)); PageData loadedData = page.getDataVersion(previousVersion.getName()); assertSame(page, loadedData.getWikiPage()); assertEquals("old content", loadedData.getContent()); }
public void addFilter(String key, Responder filterClass) { List<Responder> filters = filterMap.get(key); if (filters == null) { filters = new LinkedList<>(); filterMap.put(key, filters); } filters.add(filterClass); }
public void shouldNotSupportNonGenericLists() throws InstantiationException, IllegalAccessException, InvocationTargetException, NoSuchMethodException { final SimpleNode node = mockery.ognlNode("nonGeneric"); mockery.checking(new Expectations() { { one(evaluation).getNode(); will(returnValue(node)); one(evaluation).getSource(); will(returnValue(client)); } }); handler.instantiate(container, client.nonGeneric, "2", evaluation); mockery.assertIsSatisfied(); }
public static void assertTranslatesTo(String input, VariableSource variableSource, String expected) { assertEquals(expected, translateToHtml(null, input, variableSource)); }
public void addResult(TestResult currentResult) { results.add(currentResult); }
public void shouldOutjectParametersWithSeveralDots() throws Exception { givenParameterIsPresent("with.several.dots", "value"); outjector.outjectRequestMap(); Map<?,?> with = castMap(request.getAttribute("with")); Map<?,?> several = castMap(with.get("several")); assertThat(several.get("dots"), is("value")); }
public void setup() { this.mockery = new Mockery(); this.request = mockery.mock(MutableRequest.class); this.session = mockery.mock(HttpSession.class); this.context = mockery.mock(ServletContext.class); FilterChain chain = mockery.mock(FilterChain.class); final RequestInfo webRequest = new RequestInfo(context, chain, request, null); jstlLocalization = new JstlLocalization(webRequest); this.converter = new LocaleBasedDateConverter(jstlLocalization); this.bundle = ResourceBundle.getBundle("messages"); Locale.setDefault(Locale.ENGLISH); }
static void printBoth(TreeInfo.TreeNode leftNode, TreeInfo.TreeNode rightNode, int byteThreshold, int nodeThreshold, boolean debug, boolean interactive) { if (Math.abs(rightNode.descendantSize - leftNode.descendantSize) > byteThreshold || Math.abs(rightNode.descendantCount - leftNode.descendantCount) > nodeThreshold) {
Map<Long, QuorumServer> getVotingMembers(); Map<Long, QuorumServer> getObservingMembers(); boolean equals(Object o); byte[] toByteArray(); }
BlockingQueue<Operation> createReadOperationQueue();  BlockingQueue<Operation> createWriteOperationQueue();  NodeLocator createLocator(List<MemcachedNode> nodes);  OperationFactory getOperationFactory();  long getOperationTimeout();  boolean isDaemon(); }
public void close() { try { log(socket, request, response);
public void testSnapshot() throws Exception { File origSnapDir = new File(testData, "invalidsnap");
void kill() throws IOException; void runTests(TestPage pageToTest) throws IOException, InterruptedException; ExecutionLog getExecutionLog(); boolean isSuccessfullyStarted(); }
public static HtmlTag makeActionLink( String action, String name, String inputName, String accessKey, boolean newWindow ) { TagGroup group = new TagGroup(); String href = action; if (inputName != null) href = href + "?" + inputName; HtmlTag link = new HtmlTag("a"); link.addAttribute("href", href); if (newWindow) link.addAttribute("target", "newWindow"); link.addAttribute("accesskey", accessKey); link.add(name); group.add(new HtmlComment(name + " button")); group.add(link); return group; }
private void makeOffer() throws KeeperException, InterruptedException { state = State.OFFER; dispatchEvent(EventType.OFFER_START); LeaderOffer newLeaderOffer = new LeaderOffer(); byte[] hostnameBytes; synchronized (this) { newLeaderOffer.setHostName(hostName); hostnameBytes = hostName.getBytes(); newLeaderOffer.setNodePath(zooKeeper.create(rootNodeName + "/" + "n_", hostnameBytes, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL)); leaderOffer = newLeaderOffer; } LOG.debug("Created leader offer {}", leaderOffer); dispatchEvent(EventType.OFFER_COMPLETE); }
private boolean areEqualAndNotScenarioCalls(String content1, String content2) { return !isCalledScenario(content1) && !isCalledScenario(content2) && content1.equals(content2); }
private void genDeserialize(FileWriter c, JType type, String tag, String name) throws IOException { if (type instanceof JRecord) { c.write(" rc = rc ? rc : deserialize_" + extractStructName(type) + "(in, \"" + tag + "\", &v->" + name + ");\n");
public static void cmEdit(String file, String payload) { cmMethodCalls.add(String.format("edit %s|%s", file, payload)); }
private Maybe<String> parseVariableValue(Parser parser, Symbol next) { SymbolType close = next.getType().closeType(); if (close == SymbolType.Empty) return Maybe.noString; return parser.parseToAsString(close); }
public void variablesAreReplacedInMissing() throws Exception { makeQueryTableAndBuildInstructions(queryTableHeader + "|3|$V|\n"); qt.setSymbol("V", "5"); Map<String, Object> pseudoResults = SlimClient.resultToMap( list( list("queryTable_id_0", "OK"), list("queryTable_id_2", list( ) ) ) ); testContext.evaluateExpectations(pseudoResults); qt.evaluateReturnValues(pseudoResults); assertEquals( "[" +
String readReportFile(String reportName) throws IOException { return new String(Files.readAllBytes(new File(this.reportDir, reportName).toPath()), StandardCharsets.UTF_8); }
public void matchesWhenUsingAWildcard() throws SecurityException, NoSuchMethodException { List<Route> routes = parser.rulesFor(new DefaultResourceClass(ClientsController.class)); Route route = getRouteMatching(routes, "/move/second/child"); assertThat(route, canHandle(ClientsController.class, "move"));
public static void main(String args[]) { CmdLineParser parser = new CmdLineParser(); CmdLineParser.Option typeOpt = parser.addStringOption("type"); CmdLineParser.Option versionOpt = parser.addBooleanOption('V', "version"); CmdLineParser.Option verboseOpt = parser.addBooleanOption('v', "verbose"); CmdLineParser.Option nomungeOpt = parser.addBooleanOption("nomunge"); CmdLineParser.Option linebreakOpt = parser.addStringOption("line-break"); CmdLineParser.Option preserveSemiOpt = parser.addBooleanOption("preserve-semi"); CmdLineParser.Option disableOptimizationsOpt = parser.addBooleanOption("disable-optimizations"); CmdLineParser.Option helpOpt = parser.addBooleanOption('h', "help"); CmdLineParser.Option charsetOpt = parser.addStringOption("charset"); CmdLineParser.Option outputFilenameOpt = parser.addStringOption('o', "output"); CmdLineParser.Option mungemapFilenameOpt = parser.addStringOption('m', "mungemap"); CmdLineParser.Option preserveUnknownHintsOpt = parser.addBooleanOption('p', "preservehints"); Reader in = null; Writer out = null; Writer mungemap = null; try {
private void checkLogDir() throws LogDirContentCheckException { File[] files = this.dataDir.listFiles(new FilenameFilter() { @Override public boolean accept(File dir, String name) { return Util.isSnapshotFileName(name); } }); if (files != null && files.length > 0) { throw new LogDirContentCheckException("Log directory has snapshot files. Check if dataLogDir and dataDir configuration is correct.");
public void testIsSerializable() throws Exception { try { new ObjectOutputStream(new ByteArrayOutputStream()).writeObject(properties);
private void createFixtureInstance(Class<?> fixtureClass) { Class<?> clazz = fixtureClass; Object created = statementExecutor.create(INSTANCE_NAME, clazz.getName(), new Object[] {}); assertEquals("OK", created); }
public Socket getSocket() throws Exception
public void write(@Nonnull byte[] b, int off, int len) throws IOException { bb.put(b, off, len); }
String determineSlimHost() { String slimHost = page.readPageData().getVariable("SLIM_HOST"); return slimHost == null ? "localhost" : slimHost; }
public VersionInfo commit(PageData data) { VersionInfo previousVersion = makeVersion(); doCommit(data); return previousVersion; }
private void warn(String message, boolean showDebugString) { if (verbose) { if (showDebugString) {
public void testCreateSubscriptionFailure() throws Exception { ByteString topic = getTopic(0); subscriber.asyncSubscribe(topic, localSubscriberId, CreateOrAttach.CREATE_OR_ATTACH, new TestCallback(queue), null); assertTrue(queue.take());
void observeLeader() throws Exception { zk.registerJMX(new ObserverBean(this, zk), self.jmxLocalPeerBean); try { QuorumServer leaderServer = findLeader();
public void create(final String instanceName, final String className, final Object... constructorArgs) throws SlimException { Future<?> submit = service.submit(new Callable<Boolean>() { @Override public Boolean call() throws Exception { inner.create(instanceName, className, constructorArgs); return true; } }); getWithTimeout(submit); }
public void testSystemStopped(TestSystem testSystem, ExecutionLog executionLog, Throwable cause) { } }
private static void deserializeTree(int depth, int width, int len) throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException { BinaryInputArchive ia; int count; { DataTree tree = new DataTree(); SerializationPerfTest.createNodes(tree, "/", depth, width, tree.getNode("/").stat.getCversion(), new byte[len]); count = tree.getNodeCount(); ByteArrayOutputStream baos = new ByteArrayOutputStream(); BinaryOutputArchive oa = BinaryOutputArchive.getArchive(baos); tree.serialize(oa, "test"); baos.flush(); ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray()); ia = BinaryInputArchive.getArchive(bais); } DataTree dserTree = new DataTree(); System.gc(); long start = System.nanoTime(); dserTree.deserialize(ia, "test"); long end = System.nanoTime(); long durationms = (end - start) / 1000000L; long pernodeus = ((end - start) / 1000L) / count; Assert.assertEquals(count, dserTree.getNodeCount()); LOG.info("Deserialized " + count + " nodes in " + durationms + " ms (" + pernodeus + "us/node), depth=" + depth + " width="
public void intercept(InterceptorStack stack, ResourceMethod method, Object resourceInstance) throws InterceptionException {
public void passOneList() throws Exception { caller.call("testSlim", "oneList", list("one", "two")); assertEquals(list("one", "two"), testSlim.getListArg()); }
public MethodVisitor visitMethod(final int access, final String name, final String desc, final String signature, final String[] exceptions) { String newDesc = remapper.mapMethodDesc(desc); MethodVisitor mv = super.visitMethod(access, remapper.mapMethodName(className, name, desc), newDesc, remapper.mapSignature(signature, false), exceptions == null ? null : remapper.mapTypes(exceptions)); return mv == null ? null : createRemappingMethodAdapter(access, newDesc, mv); }
public void getsUrlForProxyPage() { WikiPage root = InMemoryPage.makeRoot("RooT"); ProxyPage virtualPage = new ProxyPage("VirtualPage", root, "host", 9999, PathParser.parse("RealPage.VirtualPage")); assertEquals("http://host:9999/RealPage.WikiPath", new WikiSourcePage(virtualPage).makeUrl("WikiPath")); }
private List<Object> startActor(int row) { int classNameColumn = 1; String cellContents = table.getCellContents(classNameColumn, row); String className = Disgracer.disgraceClassName(cellContents); return constructInstance("scriptTableActor", className, classNameColumn, row); }
public void testSetAndGetACL(ServerState serverState) throws Exception { setUp(serverState); create2EmptyNode(zkClient, PARENT_PATH); assertEquals(Ids.OPEN_ACL_UNSAFE, zkClient.getACL(PARENT_PATH, new Stat()), String.format("%s Node has open ACL", serverState)); zkClient.setACL(PARENT_PATH, Ids.READ_ACL_UNSAFE, -1); assertEquals(Ids.READ_ACL_UNSAFE, zkClient.getACL(PARENT_PATH, new Stat()), String.format("%s Node has world read-only ACL", serverState)); }
private Response createChildPageAndMakeResponse(Request request) throws Exception { createChildPage(request); SimpleResponse response = new SimpleResponse(); WikiPagePath fullPathOfCurrentPage = crawler.getFullPath(currentPage); response.redirect(fullPathOfCurrentPage.toString()); return response; }
protected VersionInfo makeVersionInfo(PageData data) throws Exception { Date time = data.getLastModificationTime(); String versionName = VersionInfo.nextId() + "-" + dateFormat().format(time); String user = data.getAttribute(WikiPage.LAST_MODIFYING_USER); if(user != null && !"".equals(user)) versionName = user + "-" + versionName; return new VersionInfo(versionName, user, time); }
protected void checkForPulse() throws InterruptedException { if(killed) throw new InterruptedException("FitClient was killed");
public boolean visit(Symbol node) { if (node.isType(Path.symbolType) ) { result.add(translator.translate(node.childAt(0))); } return true; }
private void fillPassword() { EditText txtPassword = (EditText) findViewById(R.id.password); txtPassword.setText(generatePassword()); }
public void run() {
public void testComplete(WikiPage test, TestSummary testSummary, TimeMeasurement timeMeasurement) throws Exception { referenceToCurrentTest.setTestSummary(testSummary); referenceToCurrentTest.setRunTimeInMillis(timeMeasurement.elapsed()); suiteExecutionReport.addPageHistoryReference(referenceToCurrentTest); suiteExecutionReport.tallyPageCounts(testSummary); }
public void testAddChangePasswordWithMultipleUsers() throws Exception { addTMNTUsers(); passwords.savePassword("Donatello", "manrikigusari"); String contents = FileUtil.getFileContent(passwordFile); assertSubString("Leonardo:" + cipher.encrypt("katana"), contents); assertSubString("Donatello:" + cipher.encrypt("manrikigusari"), contents); assertSubString("Michaelangelo:" + cipher.encrypt("nunchaku"), contents); assertSubString("Rafael:" + cipher.encrypt("sai"), contents); }
public void shouldUseTheDefaultLocale() throws ParseException { mockery.checking(new Expectations() {{ one(request).getAttribute("javax.servlet.jsp.jstl.fmt.locale.request"); will(returnValue(null)); one(request).getSession(); will(returnValue(session)); one(session).getAttribute("javax.servlet.jsp.jstl.fmt.locale.session"); will(returnValue(null)); one(context).getAttribute("javax.servlet.jsp.jstl.fmt.locale.application"); will(returnValue(null)); one(context).getInitParameter("javax.servlet.jsp.jstl.fmt.locale"); will(returnValue(null)); one(request).getLocale(); will(returnValue(Locale.getDefault())); }}); Date date = new SimpleDateFormat("dd/MM/yyyy").parse("10/05/2010"); String formattedToday = DateFormat.getDateInstance(DateFormat.SHORT).format(date); assertThat(converter.convert(formattedToday, Date.class, bundle), is(equalTo(date))); mockery.assertIsSatisfied(); }
public void setup() throws Exception { this.stream = new ByteArrayOutputStream(); response = mock(HttpServletResponse.class); when(response.getWriter()).thenReturn(new PrintWriter(stream)); extractor = new DefaultTypeNameExtractor(); initializer = new HibernateProxyInitializer(); this.serialization = new GsonJSONSerialization(response, extractor, initializer, Collections.<JsonSerializer> emptyList(), Collections.<ExclusionStrategy> emptyList());
public void onDebug(String content) { mavenLogger.debug(content); }
protected void addTestSystemListeners(RunNotifier notifier, MultipleTestsRunner testRunner) { testRunner.addTestSystemListener(new ListenerExtension(notifier, getTestClass().getJavaClass())); }
public void canTranslateAInheritedResourceBothWays() throws NoSuchMethodException { router.add(new PathAnnotationRoutesCreator(mockery.resource(MyResource.class))); router.add(new PathAnnotationRoutesCreator(mockery.resource(InheritanceExample.class))); Method method = mockery.methodFor(MyResource.class, "notAnnotated").getMethod(); String url = router.urlFor(InheritanceExample.class, method, new Object[] {}); assertThat(router.parse(url, HttpMethod.POST, null).getMethod(), is(equalTo(method))); mockery.assertIsSatisfied(); }
void validate(Object object, Class<?>... groups);  void validateProperties(Object object, String... properties);  void validateProperty(Object object, String property, Class<?>... groups); <T extends View> T onErrorUse(Class<T> view); void addAll(Collection<? extends Message> message); void add(Message message); List<Message> getErrors(); boolean hasErrors();  <T> T onErrorForwardTo(Class<T> controller);  <T> T onErrorForwardTo(T controller);  <T> T onErrorRedirectTo(Class<T> controller);  <T> T onErrorRedirectTo(T controller);  <T> T onErrorUsePageOf(Class<T> controller);  <T> T onErrorUsePageOf(T controller);  void onErrorSendBadRequest(); }
public Request makeRequest() { request = new Request(input); return request; }
private ChannelFuture sendPktOnly(Packet p) { return sendPkt(p, false); }
private void finishParsing() throws Exception { parseThread.join(); }
<T> T proxify(Class<T> type, MethodInvocation<? super T> handler); }
public SlimCommandRunningClient build() { CommandRunner commandRunner; if (useManualStartForTestSystem()) { commandRunner = new MockCommandRunner(getExecutionLogListener()); } else { commandRunner = new CommandRunner(buildCommand(), "", createClasspathEnvironment(getClassPath()), getExecutionLogListener(), determineTimeout()); } return new SlimCommandRunningClient(commandRunner, determineSlimHost(), getSlimPort(), determineTimeout(), getSlimVersion(), determineSSL(), determineHostSSLParameterClass()); }
public boolean hasMoreToExtract() { return argumentColumn <= endingCol; }
<T> Future<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); Future<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> Future<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); Future<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc) throws OperationTimeoutException; Map<String, Object> getBulk(Collection<String> keys) throws OperationTimeoutException; <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys) throws OperationTimeoutException; Map<String, Object> getBulk(String... keys) throws OperationTimeoutException; Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); long incr(String key, int by) throws OperationTimeoutException; long decr(String key, int by) throws OperationTimeoutException; Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, int by); long incr(String key, int by, long def) throws OperationTimeoutException; long decr(String key, int by, long def) throws OperationTimeoutException; Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); }
public Response makeResponse(FitNesseContext context, Request request) throws Exception { this.context = context; crawler = context.root.getPageCrawler(); crawler.setDeadEndStrategy(new VirtualEnabledPageCrawler()); resource = request.getResource(); shouldIncludePaths = request.hasInput("includePaths"); suiteFilter = (String) request.getInput("suiteFilter"); return new PuppetResponse(this); }
public void newTestStarted(WikiPage newTest) throws Exception { PageCrawler pageCrawler = getPage().getPageCrawler(); String relativeName = pageCrawler.getRelativeName(getPage(), newTest); WikiPagePath fullPath = pageCrawler.getFullPath(newTest); String fullPathName = PathParser.render(fullPath); announceStartNewTest(relativeName, fullPathName); }
public void gotData(String k, int flags, byte[] data) { assert key.equals(k) : "Wrong key returned"; val=tc.decode(new CachedData(flags, data)); }
public Future<Object> asyncGet(final String key) { final CountDownLatch latch=new CountDownLatch(1); final OperationFuture<Object> rv=new OperationFuture<Object>(latch); Operation op=new GetOperation(key, new GetOperation.Callback() { private Object val=null; public void receivedStatus(String line) { rv.set(val); } public void gotData(String k, int flags, byte[] data) { assert key.equals(k) : "Wrong key returned"; val=transcoder.decode(new CachedData(flags, data)); } public void complete() { latch.countDown(); }}); rv.setOperation(op); addOp(key, op); return rv; }
public List<WikiPage> getChildren() throws Exception { return new ArrayList<WikiPage>(); }
public void testExecutionReport_Output() throws Exception { MockWikiPage mockWikiPage = new MockWikiPage("This.Is.Not.A.Real.Location"); MockCommandRunner mockCommandRunner = new MockCommandRunner(); mockCommandRunner.setOutput("I wrote something here"); ExecutionLog executionLog = new ExecutionLog(mockWikiPage, mockCommandRunner); ExecutionStatus result; if(executionLog.exceptionCount() > 0) result = ExecutionStatus.ERROR; else if(executionLog.hasCapturedOutput()) result = ExecutionStatus.OUTPUT; else result = ExecutionStatus.OK; assertSame(ExecutionStatus.OUTPUT, result); }
public WikiPage addChildPage(String name) throws Exception; public boolean hasChildPage(String name) throws Exception; public WikiPage getChildPage(String name) throws Exception; public void removeChildPage(String name) throws Exception; public List getChildren() throws Exception; public String getName() throws Exception; public PageData getData() throws Exception; public PageData getDataVersion(String versionName) throws Exception; public VersionInfo commit(PageData data) throws Exception; public PageCrawler getPageCrawler();
public void setup() throws NoSuchMethodException { this.mockery = new Mockery(); this.provider = mockery.mock(ParametersProvider.class); this.parameters =mockery.mock(MethodParameters.class); }
public Object remove(Object key) { key = convertKey(key); int hashCode = hash(key); int index = hashIndex(hashCode, data.length); HashEntry entry = data[index]; HashEntry previous = null; while (entry != null) { if (entry.hashCode == hashCode && isEqualKey(key, entry.key)) { Object oldValue = entry.getValue(); removeMapping(entry, index, previous); return oldValue; } previous = entry; entry = entry.next; } return null; }
@Override public ExceptionResult evaluateException(ExceptionResult exceptionResult) { return null; } };
public void testBuffer() { final byte[] expected = "hello-world".getBytes(StandardCharsets.UTF_8); final String tag = "tag1"; checkWriterAndReader( (oa) -> oa.writeBuffer(expected, tag),
public void passesTheWebMethod() throws SecurityException, NoSuchMethodException { HttpMethod delete = HttpMethod.DELETE; Route route = mock(Route.class); when(route.canHandle("/clients/add")).thenReturn(true); when(route.allowedMethods()).thenReturn(EnumSet.of(delete)); when(route.resourceMethod(request, "/clients/add")).thenReturn(method); router.add(route); ResourceMethod found = router.parse("/clients/add", delete, request); assertThat(found, is(equalTo(method))); verify(route, atLeastOnce()).getPriority(); }
private TestSystem makeTestSystem(Descriptor descriptor) throws IOException { if ("slim".equalsIgnoreCase(descriptor.getTestSystemType())) return fastTest ? createInProcessHtmlSlimTestSystem(descriptor) : createHtmlSlimTestSystem(descriptor);
public void simpleInputAndOutputPassing() throws Exception { makeTables( "!|scenario|echo|input|giving|output|\n" + "|check|echo|@input|@output|\n" + "\n" + "!|DT:EchoGiving|\n" + "|input|output|\n" + "|7|7|\n" ); Map<String, Object> pseudoResults = SlimClient.resultToMap( list( list("decisionTable_did_0/scriptTable_s_id_0", "7") ) ); evaluateExpectations(pseudoResults); String scriptTable = dt.getChild(0).getTable().toString(); String expectedScript = "[[scenario, echo, input, giving, output], [check, echo, 7, pass(7)]]"; assertEquals(expectedScript, scriptTable); String dtHtml = dt.getTable().toString(); assertEquals(1, dt.getTestSummary().getRight()); assertEquals(0, dt.getTestSummary().getWrong()); assertEquals(0, dt.getTestSummary().getIgnores()); assertEquals(0, dt.getTestSummary().getExceptions()); }
public void shoudRegisterResourcesInRouter() { Router router = container.instanceFor(Router.class); assertThat(router.allRoutes(), hasItem(canHandle(DummyResource.class, DummyResource.class.getDeclaredMethods()[0]))); }
protected String makeDescription(String author, String pubDate) { String description; String authoredBy = ""; if(exists(author)) authoredBy = author + ":"; description = authoredBy + pubDate; return description; }
protected String createEvaluationMessage(String value, String literalizedValue, String originalValue) { setSymbol(symbolName, value); return String.format("$%s<-[%s]", literalize(symbolName), literalizedValue); }
public void testLedgerRecovery() throws Exception { testInternal(100);
public void shouldBeAbleToConvert() throws ParseException { mockery.checking(new Expectations() {{ exactly(2).of(request).getAttribute("javax.servlet.jsp.jstl.fmt.locale.request"); will(returnValue("pt_br")); }}); assertThat(converter.convert("10/06/2008", Date.class), is(equalTo(new SimpleDateFormat("dd/MM/yyyy").parse("10/06/2008")))); mockery.assertIsSatisfied(); }
public void testPing() throws Exception {
String getLastResponseTime();  long getLastLatency();  void resetCounters(); }
public int compareTo(MimeType mime) {
private Servers LaunchServers(int numServers) throws IOException, InterruptedException { int SERVER_COUNT = numServers; Servers svrs = new Servers(); final int clientPorts[] = new int[SERVER_COUNT]; StringBuilder sb = new StringBuilder(); for (int i = 0; i < SERVER_COUNT; i++) { clientPorts[i] = PortAssignment.unique(); sb.append("server." + i + "=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + "\n"); } String quorumCfgSection = sb.toString(); MainThread mt[] = new MainThread[SERVER_COUNT]; ZooKeeper zk[] = new ZooKeeper[SERVER_COUNT]; for (int i = 0; i < SERVER_COUNT; i++) { mt[i] = new MainThread(i, clientPorts[i], quorumCfgSection); mt[i].start(); zk[i] = new ZooKeeper("127.0.0.1:" + clientPorts[i], ClientBase.CONNECTION_TIMEOUT, this); } waitForAll(zk, States.CONNECTED); svrs.mt = mt; svrs.zk = zk; return svrs; }
public void shouldInstantiateHashSetListForSetInterface() throws Exception { mockery.checking(new Expectations() { { one(removal).add(new HashSet<Object>()); } }); GenericNullHandler handler = new GenericNullHandler(); Set<?> set = handler.instantiate(Set.class, container); assertThat(set, is(notNullValue())); assertThat(set, is(instanceOf(HashSet.class))); }
private Set<String> setupClassPathForConsole(final VersionNumber scalaVersion) throws Exception { final Set<String> classpath = new HashSet<String>(); classpath.addAll(this.setupProjectClasspaths()); classpath.addAll(this.setupConsoleClasspaths(scalaVersion)); return classpath; }
public void testReferencesOnPageOne_1() { checkChangesOnPageOne("Stuff PageTwo Stuff\n", "Stuff PageThree Stuff\n"); }
public static String translateTo(WikiPage page, String input) { ParsingPage.Cache cache = new ParsingPage.Cache(); VariableSource variableSource = new CompositeVariableSource(cache, new BaseWikitextPage.ParentPageVariableSource(page)); SyntaxTreeV2 syntaxTree = new SyntaxTreeV2(); syntaxTree.parse(input, new ParsingPage(new WikiSourcePage(page), variableSource, cache)); return syntaxTree.getHtml(); }
public Object nextElement() { return null;
protected void sockConnect(Socket sock, InetSocketAddress addr, int timeout) throws IOException { synchronized (this) { if (++socketConnectAttempt < passSocketConnectOnAttempt || unreachableAddresses.contains(addr)) {
public void processRequest(Request request) { QuorumPeer self = leader.self; if(self != null) leader.processAck(self.getId(), request.zxid, null);
void close() { try { changeZkState(States.CLOSED); } catch (IOException e) { LOG.warn("Connection close fails when migrates state from {} to CLOSED", getZkState()); } clientCnxnSocket.onClosing(); }
public void build(Translator translator, Symbol symbol, HtmlTag tag) { tag.add(new HtmlText(symbol.getContent())); }
public void acceptsAnHttpMethodLimitedMappingRule() throws NoSuchMethodException { rules.add(new Rules() {{ routeFor("/clients/add").with(HttpMethod.POST).is(MyControl.class).add(null); }}); assertThat(rules.parse("/clients/add", HttpMethod.POST), is(VRaptorMatchers.resourceMethod(method("add",Dog.class)))); }
public static String join(List strings, String delimiter) { if (strings.isEmpty()) return ""; Iterator i = strings.iterator(); StringBuffer joined = new StringBuffer((String) i.next()); for (; i.hasNext();) { String eachLine = (String) i.next(); joined.append(delimiter); joined.append(eachLine); } return joined.toString(); }
public void testShouldUseSpecifiedRevisionControllerWithHistoryDepth() throws Exception { Properties testProperties = new Properties(); testProperties.setProperty(ConfigurationParameter.VERSIONS_CONTROLLER_CLASS.getKey(), NullVersionsController.class.getName()); testProperties.setProperty(ConfigurationParameter.VERSIONS_CONTROLLER_DAYS.getKey(), "42"); fileSystemPageFactory = new FileSystemPageFactory(testProperties); VersionsController defaultRevisionController = fileSystemPageFactory.getVersionsController(); assertEquals(NullVersionsController.class, defaultRevisionController.getClass()); assertEquals(42, ((NullVersionsController) defaultRevisionController).getHistoryDepth()); }
public void initialize() { if (hasExp) { prepareBuffer(key, 0, EMPTY_BYTES, 0, exp);
public String render() throws Exception {
public void assertSuitePasses(String suiteName) throws Exception{ assertPasses(suiteName, TestHelper.PAGE_TYPE_SUITE); }
public void setup() { this.converter = new SignatureConverter(); }
boolean touchSession(long sessionId, int sessionTimeout);  void shutdown();  void removeSession(long sessionId); void checkSession(long sessionId) throws KeeperException.SessionExpiredException; }
public void processResult(int rc, String path, Object ctx, byte[] data, Stat stat) { System.out.println("rc = " + rc + " path = " + path + " data = " + (data == null ? "null" : new String(data)) + " stat = "); printStat(stat); }
public void testInitialAcceptedCurrent() throws Exception { File tmpDir = File.createTempFile("test", ".dir", testData); tmpDir.delete(); tmpDir.mkdir(); try { FileTxnSnapLog logFactory = new FileTxnSnapLog(tmpDir, tmpDir);
protected void createSessionTracker() { sessionTracker = new SessionTrackerImpl(this, sessionsWithTimeouts, tickTime, 1); ((SessionTrackerImpl)sessionTracker).start(); }
long decr(String key, int by) throws OperationTimeoutException; long incr(String key, int by, long def) throws OperationTimeoutException; long decr(String key, int by, long def) throws OperationTimeoutException; Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); }
protected void registerComponents(ComponentRegistry container) { singleInterfaceRegister(StupidTranslator.class, container); singleInterfaceRegister(DefaultResourceRegistry.class, container); singleInterfaceRegister(DefaultDirScanner.class, container); singleInterfaceRegister(WebInfClassesScanner.class, container); singleInterfaceRegister(DefaultInterceptorRegistry.class, container); singleInterfaceRegister(DefaultMethodLookupBuilder.class, container); singleInterfaceRegister(DefaultPathResolver.class, container); singleInterfaceRegister(ParanamerNameProvider.class, container); singleInterfaceRegister(DefaultConverters.class, container); singleInterfaceRegister(DefaultMethodParameters.class, container); singleInterfaceRegister(DefaultRequestParameters.class, container); singleInterfaceRegister(DefaultInterceptorStack.class, container); singleInterfaceRegister(DefaultRequestExecution.class, container); singleInterfaceRegister(DefaultResult.class, container); singleInterfaceRegister(OgnlParametersProvider.class, container); singleInterfaceRegister(DefaultRequestInfo.class, container); singleInterfaceRegister(DefaultValidator.class, container); container.register(ForwardToDefaultViewInterceptor.class, ForwardToDefaultViewInterceptor.class); container.register(RequestResult.class, RequestResult.class); container.register(PageResult.class, DefaultPageResult.class); container.register(TypeCreator.class, AsmBasedTypeCreator.class); container.register(EmptyElementsRemoval.class, EmptyElementsRemoval.class); container.register(ParametersInstantiatorInterceptor.class, ParametersInstantiatorInterceptor.class); container.register(InterceptorListPriorToExecutionExtractor.class, InterceptorListPriorToExecutionExtractor.class); container.register(URLParameterExtractorInterceptor.class, URLParameterExtractorInterceptor.class); container.register(ResourceLookupInterceptor.class, ResourceLookupInterceptor.class); container.register(InstantiateInterceptor.class, InstantiateInterceptor.class); container.register(ExecuteMethodInterceptor.class, ExecuteMethodInterceptor.class); }
public void testMakeResponseImportingNonRootPage() throws Exception { MockRequest request = makeRequest(baseUrl + "PageOne"); Response response = responder.makeResponse(new FitNesseContext(testData.localRoot), request); String content = new MockResponseSender(response).sentData(); assertNotNull(testData.pageTwo.getChildPage("ChildOne")); assertSubString("href=\"PageTwo.ChildOne\"", content); assertSubString(">ChildOne<", content); }
public void localizedStartStatementWithArguments() throws Exception { buildInstructionsFor("|localized start|Bob martin|x|y|\n", true); List<MakeInstruction> expectedInstructions = list( new MakeInstruction("localizedScriptTable_id_0", "localizedScriptTableActor", "BobMartin", new Object[]{"x", "y"}) ); assertEquals(expectedInstructions, instructions()); }
public void tearDown() throws Exception { } public void testTestSummary() throws Exception { formatter.processTestResults("TestName", new TestSummary(49, 0, 0, 0)); formatter.processTestResults("TestName2", new TestSummary(1, 0, 2, 0)); formatter.processTestResults("TestName3", new TestSummary(1, 1, 0, 0)); formatter.finishWritingOutput(); assertSubString("<strong>Test Pages:</strong> 2 right, 1 wrong, 0 ignored, 0 exceptions", pageBuffer.toString()); assertSubString("<strong>Assertions:</strong> 51 right, 1 wrong, 2 ignored, 0 exceptions", pageBuffer.toString()); } public void testCountsHtml() throws Exception { formatter.processTestResults("RelativePageName", new TestSummary(1, 0, 0, 0)); assertSubString("<div class=\\\"alternating_row_2\\\">", pageBuffer.toString()); assertSubString("<span class=\\\"test_summary_results pass\\\">1 right, 0 wrong, 0 ignored, 0 exceptions</span>", pageBuffer.toString()); assertSubString("<a href=\\\"#RelativePageName0\\\" class=\\\"test_summary_link\\\">RelativePageName</a>", pageBuffer.toString()); pageBuffer.setLength(0); formatter.processTestResults("AnotherPageName", new TestSummary(0, 1, 0, 0)); assertSubString("<div class=\\\"alternating_row_1\\\">", pageBuffer.toString()); assertSubString("<span class=\\\"test_summary_results fail\\\">0 right, 1 wrong, 0 ignored, 0 exceptions</span>", pageBuffer.toString()); assertSubString("<a href=\\\"#AnotherPageName0\\\" class=\\\"test_summary_link\\\">AnotherPageName</a>", pageBuffer.toString()); } public void testResultsHtml() throws Exception { formatter.announceStartTestSystem(null, "Fit", "laughing.fit"); formatter.announceNumberTestsToRun(2); formatter.announceStartNewTest("RelativeName", "FullName"); formatter.processTestOutput("starting"); formatter.processTestOutput(" output"); formatter.processTestResults("RelativeName", new TestSummary(1, 0, 0, 0)); formatter.announceStartTestSystem(null, "Slim", "very.slim"); formatter.announceStartNewTest("NewRelativeName", "NewFullName"); formatter.processTestOutput("second"); formatter.processTestOutput(" test"); formatter.processTestResults("NewRelativeName", new TestSummary(0, 1, 0, 0)); formatter.finishWritingOutput(); String results = pageBuffer.toString(); assertSubString("<h2 class=\"centered\">Test Output</h2>", results); assertSubString("<h2 class=\"centered\">Test System: Slim:very.slim</h2>", results); assertSubString("<div class=\"test_output_name\">", results); assertSubString("<a href=\"FullName\" id=\"RelativeName1\" class=\"test_name\">RelativeName</a>", results); assertSubString("<div class=\"alternating_block_1\">starting output</div>", results); assertSubString("<a href=\"NewFullName\" id=\"NewRelativeName2\" class=\"test_name\">NewRelativeName</a>", results); assertSubString("<div class=\"alternating_block_2\">second test</div>", results); } public void testTestingProgressIndicator() throws Exception { formatter.announceStartTestSystem(null, "Fit", "laughing.fit"); formatter.announceNumberTestsToRun(20); formatter.announceStartNewTest("RelativeName", "FullName"); assertSubString("<script>document.getElementById(\"test-summary\").innerHTML =" + " \"<div id=\\\"progressBar\\\" class=\\\"pass\\\" style=\\\"width:0.0%\\\">", pageBuffer.toString()); assertSubString("Running&nbsp;tests&nbsp;...&nbsp;(1/20)", pageBuffer.toString()); pageBuffer.setLength(0); formatter.processTestResults("RelativeName", new TestSummary(1, 0, 0, 0)); formatter.announceStartNewTest("RelativeName", "FullName"); assertSubString("<script>document.getElementById(\"test-summary\").innerHTML =" + " \"<div id=\\\"progressBar\\\" class=\\\"pass\\\" style=\\\"width:5.0%\\\">", pageBuffer.toString()); assertSubString("(2/20)", pageBuffer.toString()); pageBuffer.setLength(0); formatter.processTestResults("RelativeName", new TestSummary(1, 0, 0, 0)); formatter.announceStartNewTest("RelativeName", "FullName"); assertSubString("<script>document.getElementById(\"test-summary\").innerHTML =" + " \"<div id=\\\"progressBar\\\" class=\\\"pass\\\" style=\\\"width:10.0%\\\">", pageBuffer.toString()); assertSubString("(3/20)", pageBuffer.toString()); } }
public <T> T relation(final Class<T> type) { return proxifier.proxify(type, new MethodInvocation<T>() { public Object intercept(T proxy, Method method, Object[] args,
private String getResultFor(String name, boolean addPaths) throws Exception { request.setResource(name); if (addPaths) request.addInput("includePaths", "blah"); response = responder.makeResponse(context, request); sender = new MockResponseSender(); sender.doSending(response); String result = sender.sentData(); return result; }
public void testAsyncSetACLFailure_BadVersion() { new StatCB(zk).verifySetACLFailure_BadVersion(); }
public static void copyToClipboard(Context context, String label, String text) throws SamsungClipboardException { copyToClipboard(context, label, text, false); }
protected void doClose() { }  protected Object retryOperation(ZooKeeperOperation operation) throws KeeperException, InterruptedException { KeeperException exception = null; for (int i = 0; i < retryCount; i++) { try { return operation.execute(); } catch (KeeperException.SessionExpiredException e) { LOG.warn("Session expired for: " + zookeeper + " so reconnecting due to: " + e, e); throw e; } catch (KeeperException.ConnectionLossException e) { if (exception == null) { exception = e; } LOG.debug("Attempt {} failed with connection loss so " + "attempting to reconnect", i, e); retryDelay(i); } } throw exception; }  protected void ensurePathExists(String path) { ensureExists(path, null, acl, CreateMode.PERSISTENT); }  protected void ensureExists(final String path, final byte[] data, final List<ACL> acl, final CreateMode flags) { try { retryOperation(new ZooKeeperOperation() { public boolean execute() throws KeeperException, InterruptedException { Stat stat = zookeeper.exists(path, false); if (stat != null) { return true; } zookeeper.create(path, data, acl, flags); return true; } }); } catch (KeeperException e) { LOG.warn("Caught: " + e, e); } catch (InterruptedException e) { LOG.warn("Caught: " + e, e); } }  protected boolean isClosed() { return closed.get(); }  protected void retryDelay(int attemptCount) { if (attemptCount > 0) { try { Thread.sleep(attemptCount * retryDelay); } catch (InterruptedException e) { LOG.debug("Failed to sleep", e); } } } }
public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { try { if (LOG.isTraceEnabled()) {
private TestSystem makeTestSystem(Descriptor descriptor) throws IOException { if ("slim".equalsIgnoreCase(ClientBuilder.getTestSystemType(descriptor.getTestSystemName()))) return createHtmlSlimTestSystem(descriptor);
private WikiPage findInheritedPage(String pageName) throws Exception { return PageCrawlerImpl.getClosestInheritedPage(pageName, testPage); }
public Object[] mergeParameters(Object[] args) { Object[] newArgs = new Object[parameterNames.size()+args.length]; for (int i=0; i< parameterNames.size();i++) newArgs[i] = parameterNames.get(i); for (int i=0; i< args.length;i++) newArgs[i+ parameterNames.size()] = args[i]; args = newArgs; return args; }
public ReplyHeader submitRequest(RequestHeader h, Record request, Record response, WatchRegistration watchRegistration, WatchDeregistration watchDeregistration) throws InterruptedException { ReplyHeader r = new ReplyHeader(); Packet packet = queuePacket(h, r, request, response, null, null, null, null, watchRegistration, watchDeregistration); synchronized (packet) { while (!packet.finished) { packet.wait(); } } return r; }
private Class<?> forName(String className) throws PluginException { try { return Class.forName(className);
public static void Launch(Activity act, PwGroupV3 group, int mode) { Intent i = new Intent(act, GroupActivity.class); if ( group != null ) { i.putExtra(KEY_ENTRY, group.groupId); } i.putExtra(KEY_MODE, mode); act.startActivityForResult(i,0); }
public void add(int key, long value) { } public void add(String key, long value) { } public void reset() { } public abstract Map<String, Object> values(); }
public boolean equals(Object obj) { return compareTo((Number) obj) == 0; }
public void shouldExecuteMultipleFilters() throws Exception { factory.addFilter("mock", new AnotherMockFilter()); Responder responder = factory.makeResponder(request); expectedAnotherFilterResponse = new SimpleResponse(); Response response = responder.makeResponse(context, request); assertSame(expectedAnotherFilterResponse, response); }
void authenticate(String mechs[], CallbackHandler cbh) throws OperationException; }
public void reconfigure(InetSocketAddress addr){ ServerSocketChannel oldSS = ss; try { this.ss = ServerSocketChannel.open();
public void testRemoveWatchBit() { int watcherCacheSize = 1; BitHashSet ws = new BitHashSet(watcherCacheSize); ws.add(1); ws.add(2); assertTrue(ws.contains(1)); assertTrue(ws.contains(2)); ws.remove(1); assertFalse(ws.contains(1)); assertEquals(1, ws.size()); assertEquals(0, ws.cachedSize()); List<Integer> actualBits = new ArrayList<>(); for (int bit : ws) { actualBits.add(bit); } assertArrayEquals(new Integer[]{2}, actualBits.toArray(new Integer[actualBits.size()])); ws.add(3); assertEquals(2, ws.size()); assertEquals(1, ws.cachedSize()); actualBits.clear(); for (int bit : ws) { actualBits.add(bit); } assertArrayEquals(new Integer[]{2, 3}, actualBits.toArray(new Integer[actualBits.size()])); ws.remove(2); ws.remove(3); assertEquals(0, ws.size()); assertEquals(0, ws.cachedSize()); }
MemcachedNode getHandlingNode();  void setHandlingNode(MemcachedNode to);  void timeOut();  boolean isTimedOut();  boolean isTimedOut(long ttlMillis);  boolean isTimedOutUnsent(); }
public void sendingFinished() { if (!connected) { return; } lastLocalSeqIdDelivered = localSeqIdDeliveringNow; if (lastLocalSeqIdDelivered > lastSeqIdCommunicatedExternally + SEQ_ID_SLACK){
public Object parse(String s) { return ("null".equals(s))? null : new Integer(Integer.parseInt(s)); }
public static String makeArtifactNameString(Artifact artifact) {
public void processRequest(Request request) { if (stopped) { return; } if (LOG.isDebugEnabled()) { LOG.debug("Processing request:: " + request); } request.commitProcQueueStartTime = Time.currentElapsedTime(); queuedRequests.add(request);
public void testRegexp() throws Exception { assertMatches("!virtualwiki http://localhost:" + FitNesseUtil.port + "/SomePage"); assertNoMatch("!virtualwiki SomeName"); }
public void testComplete(WikiTestPage test, TestSummary testSummary) throws IOException; public void errorOccurred(Throwable cause); }
public void finishedWithSocket() throws Exception { finished = true; socket.close(); }
public void setUp() throws Exception { versionsController = new ZipFileVersionsController(); FileSystemPageFactory fileSystemPageFactory = new FileSystemPageFactory(new DiskFileSystem(), versionsController, new SystemVariableSource()); root = fileSystemPageFactory.makePage(new File("TestDir/RooT"), "RooT", null); page = (FileSystemPage) WikiPageUtil.addPage(root, PathParser.parse("PageOne"), "original content"); PageData data = page.getData(); firstVersion = VersionInfo.makeVersionInfo(data); secondVersion = page.commit(data); }
public void testShouldReportErrorMsgIfCheckinOperationFails() throws Exception { final String errorMsg = "Cannot checkin files to Revision Control"; revisionController.checkin(contentAndPropertiesFilePathFor(FS_PARENT_PAGE)); expectLastCall().andThrow(new RevisionControlException(errorMsg)); replay(revisionController); createPage(FS_PARENT_PAGE); request.setResource(FS_PARENT_PAGE); invokeResponderAndCheckSuccessStatus(); assertSubString(errorMsg, response.getContent()); }
protected Object callMethod(Object instance, Method method, Object[] convertedArgs) throws Throwable { try { Object result;
protected void initializeResponder(WikiPage root, Request request) { this.root = root; }
public void increment(ExecutionResult result) { this.testSummary.add(result); }
public static String translateTo(WikiPage page, String input) { ParsingPage.Cache cache = new ParsingPage.Cache(); VariableSource variableSource = new CompositeVariableSource(cache, new BaseWikitextPage.ParentPageVariableSource(page)); Symbol list = Parser.make(new ParsingPage(new WikiSourcePage(page), variableSource, cache), input).parse(); return new HtmlTranslator(new WikiSourcePage(page), new ParsingPage(new WikiSourcePage(page))).translateTree(list); }
protected void doPost(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException { final String cmdName = extractCommandNameFromURL(request, response); if (cmdName != null) { final String authInfo = request.getHeader(HttpHeader.AUTHORIZATION.asString());
public void call(String[] args, ScriptTable parentTable, int row) { Map<String, String> scenarioArguments = new HashMap<String, String>(); for (int i = 0; i < inputs.size(); i++) scenarioArguments.put(inputs.get(i), args[i]); call(scenarioArguments, parentTable, row); }
public void config() { this.mockery = new Mockery(); this.method = mockery.mock(ResourceMethod.class); this.resource = mockery.mock(ResourceClass.class); this.config = mockery.mock(Config.class); this.request = mockery.mock(HttpServletRequest.class); this.info =mockery.mock(MethodInfo.class); mockery.checking(new Expectations() { { allowing(request).getHeader("Accept"); one(config).getViewPattern(); will(returnValue("/$component/$logic.$result.jsp")); } }); this.resolver = new VRaptor2PathResolver(config, request, info); }
public void printString(String s) { System.out.println(s); }
public void resetStatistics() { ServerStats.getInstance().resetRequestCounters(); ServerStats.getInstance().resetLatency(); }
private boolean isSubmodule() {
protected TableScanner scanTheTables(PageData pageData) { Symbol syntaxTree = pageData.getSyntaxTree(); Symbol preparsedScenarioLibrary = getPreparsedScenarioLibrary(); syntaxTree.addToFront(findCollapsibleSymbol(preparsedScenarioLibrary)); String html = pageData.translateToHtml(syntaxTree); return new HtmlTableScanner(html); }
public void shouldAddAllowHeader() throws Exception { mockery.checking(new Expectations() { { one(response).addHeader("Allow", "GET, POST"); ignoring(anything()); } }); this.handler.deny(request, EnumSet.of(HttpMethod.GET, HttpMethod.POST)); mockery.assertIsSatisfied(); }
public void allTestingComplete() throws Exception { try { writeResults();
public void testAdHash() throws Exception{ List<Long> bucket1 = generateRandomHashes(50); List<Long> bucket2 = generateRandomHashes(3); List<Long> bucket3 = generateRandomHashes(30); List<Long> bucket4 = generateRandomHashes(10); List<Long> bucket5 = generateRandomHashes(5);
public void testMissingSeeker() throws Exception { request.addInput("ticket", "123"); Response response = responder.makeResponse(context, request); response.readyToSend(sender); assertHasRegexp("There are no clients waiting for a socket with ticketNumber 123", sender.sentData()); assertTrue(sender.closed); assertEquals(404, response.getStatus()); }
@Test public void scansIncludes() { ParserTest.assertScansTokenType("!include name", TokenType.Include, true); }
public void testNodes100() throws Exception { int testIterations = 100; final CountDownLatch latch = new CountDownLatch(testIterations); final AtomicInteger failureCounter = new AtomicInteger(); for (int i = 0; i < testIterations; i++) { runElectionSupportThread(latch, failureCounter); } Assert.assertEquals(0, failureCounter.get()); if (!latch.await(20, TimeUnit.SECONDS)) { LOGGER.info("Waited for all threads to start, but timed out. We had {} failures.", failureCounter);
public void produce(DataConsumer receiver) throws IOException { receiver.onEachFile(null, createEntry()); }
public void testThreeFinalStrikes() throws Exception { rollMany(18, 0); g.roll(10); assertEquals("", 10, g.currentFrame()); assertEquals("", 2, g.currentBall()); assertEquals("", 9, g.scoreableFrame()); g.roll(10); assertEquals("", 10, g.currentFrame()); assertEquals("", 3, g.currentBall()); assertEquals("", 9, g.scoreableFrame()); g.roll(10); assertEquals("", 10, g.currentFrame()); assertEquals("", 0, g.currentBall()); assertEquals("", 10, g.scoreableFrame()); assertEquals("", true, g.gameOver()); }
public void testChRootTransaction() throws Exception {
private void buildInstructionsFor(String scriptStatements, boolean localized) throws Exception { buildInstructionsForWholeTable(scriptTableHeader + scriptStatements, localized); }
public void testResponse() throws Exception { WikiPage page = crawler.addPage(root, PathParser.parse("PageOne")); PageData data = page.getData(); data.setContent("some content"); WikiPageProperties properties = data.getProperties(); properties.set("Test", "true"); properties.set(WikiPageProperties.VIRTUAL_WIKI_ATTRIBUTE, "http://www.fitnesse.org"); page.commit(data); MockRequest request = new MockRequest(); request.setResource("PageOne"); Responder responder = new PropertiesResponder(); SimpleResponse response = (SimpleResponse) responder.makeResponse(context, request); assertEquals("max-age=0", response.getHeader("Cache-Control")); String content = response.getContent(); assertSubString("PageOne", content); assertSubString("value=\"http://www.fitnesse.org\"", content); assertDoesntHaveRegexp("textarea name=\"extensionXml\"", content); assertHasRegexp("<input.*value=\"Save Properties\".*>", content); assertHasRegexp("<input.*value=\"saveProperties\"", content); for (String attribute : new String[]{"Search", "Edit", "Properties", "Versions", "Refactor", "WhereUsed", "RecentChanges"}) assertCheckboxChecked(attribute, content); for (String attribute : new String[]{"Prune", PageData.PropertySECURE_READ, PageData.PropertySECURE_WRITE, PageData.PropertySECURE_TEST}) assertCheckboxNotChecked(content, attribute);
public void testTagsShouldBeInheritedFromSuite() throws Exception { PageData suiteData = suite.getData(); suiteData.setAttribute(SUITES, "tag"); suite.commit(suiteData); addTestToSuite("TestInheritsTag", fitPassFixture); request.setQueryString("suiteFilter=tag"); String results = runSuite(); assertHasRegexp("#TestInheritsTag", results); }
public void functionCallWithOneArgumentAndTrailingName() throws Exception { buildInstructionsFor("|function|arg|trail|\n"); List<CallInstruction> expectedInstructions = asList( new CallInstruction("htmlScriptTable_id_0", "htmlScriptTableActor", "functionTrail", new Object[]{"arg"}) ); assertEquals(expectedInstructions, instructions()); }
private void print(String key, double number) { print(key, "" + number); }
public void resetObserverConnectionStats() { for (LearnerHandler lh : activeObservers) { lh.resetObserverConnectionStats();
private void getContentForSimpleRename() throws Exception { request.setResource("files"); request.addInput("filename", "MyFile.txt"); responder = new RenameFileConfirmationResponder(); response = (SimpleResponse)responder.makeResponse(context, request); content = response.getContent(); }
public Description createDescription(Class<?> clazz, WikiPage page) { String name = page.getFullPath().toString(); FitNessePageAnnotation wikiPageAnnotation = new FitNessePageAnnotation(page); return createDescription(clazz, name, wikiPageAnnotation); }
private boolean searchInField(String key) { if (key.equals(PwEntryV4.STR_TITLE)) { return sp.searchInTitles;
void shutdown();  void removeSession(long sessionId);  boolean isTrackingSession(long sessionId);  void checkSession(long sessionId, Object owner) throws KeeperException.SessionExpiredException, KeeperException.SessionMovedException, KeeperException.UnknownSessionException;  void checkGlobalSession(long sessionId, Object owner) throws KeeperException.SessionExpiredException, KeeperException.SessionMovedException; void setOwner(long id, Object owner) throws SessionExpiredException;  void dumpSessions(PrintWriter pwriter);  Map<Long, Set<Long>> getSessionExpiryMap();  long getLocalSessionCount(); }
protected void startSearching() { super.startSearching(); String searchString = getSearchString(); String replacementString = getReplacementString(); observer = new ContentReplacingSearchObserver(searchString, replacementString); finder = new RegularExpressionWikiPageFinder(searchString, this); finder.search(page); }
public void testImportingFromSecurePageWithCredentials() throws Exception { makeSecurePage(testData.remoteRoot); MockRequest request = makeRequest(baseUrl); request.addInput("remoteUsername", "joe"); request.addInput("remotePassword", "blow"); Response response = getResponse(request); String content = new MockResponseSender(response).sentData(); assertNotSubString("requires authentication", content); assertSubString("3 pages were imported.", content); assertEquals("joe", WikiImporter.remoteUsername); assertEquals("blow", WikiImporter.remotePassword); }
public void addScenario(String scenarioName, ScenarioTable scenarioTable) { ScenarioTable oldValue = scenarios.put(scenarioName, scenarioTable); if (oldValue == null || !oldValue.equals(scenarioTable)) { allTables.add(scenarioTable);
void notFound();  void conflict(); void header(String key, String value); void methodNotAllowed(EnumSet<HttpMethod> allowedMethods);  void notModified();  void movedPermanentlyTo(String url);  <T> T movedPermanentlyTo(Class<T> controller);  void unsupportedMediaType(String errorMessage);  void notAcceptable();  void accepted(); }
void resetStatistics();  void resetLatency();  void resetMaxLatency();  void resetFsyncThresholdExceedCount();  void resetNonMTLSConnCount();  void resetAuthFailedCount();  long getNumAliveConnections();  long getDataDirSize();  long getLogDirSize();  String getSecureClientPort();  String getSecureClientAddress();  long getTxnLogElapsedSyncTime();  int getJuteMaxBufferSize();  int getLastClientResponseSize();  int getMinClientResponseSize();  int getMaxClientResponseSize(); long getFlushDelay(); void setFlushDelay(long delay); long getMaxWriteQueuePollTime(); void setMaxWriteQueuePollTime(long delay); int getMaxBatchSize(); void setMaxBatchSize(int size);  int getMaxCnxns(); }
public void setup() { MockitoAnnotations.initMocks(this); iogi = new Iogi(new NullDependencyProvider(), mockLocaleProvider); }
private boolean filterForJline(final Artifact artifact) { final String artifactId = artifact.getArtifactId(); final String groupId = artifact.getGroupId(); return artifactId.equals(ScalaConsoleMojo.JLINE) && groupId.equals(ScalaConsoleMojo.JLINE); }
public int hashCode() { return Objects.hash(major, minor, bugfix, modifier); }
public void surplusErrors() throws Exception { assertTableResults("|2|4|\n", asList(
public boolean hasWriteOp() { throw new UnsupportedOperationException(); }
public void testCompleteTrailerThatIsInComplete() { tables.last().trailer = "JUNK"; ParseUtility.completeTrailer(tables); assertEquals("<html><title>table</title><body>"+ "t1<table><tr><td>Test</td></tr></table>t2"+
public T execute() throws Exception; } public static <T> T profile(Operation<T> op, long timeout, String message) throws Exception { long start = System.currentTimeMillis(); T res = op.execute(); long end = System.currentTimeMillis(); if (end - start > timeout) { LOG.error("Elapsed "+(end - start) + " ms: " + message); } return res; } }
public DERObject toASN1Object() { ASN1EncodableVector v = new ASN1EncodableVector(); if (cA != null) { v.add(cA); } if (pathLenConstraint != null)
private boolean isWaitingForCommit() { return nextPending.get() != null; }
public static void markSensitive(ClipData clipData) { try { Object extras = persistableBundle.newInstance();
private static CallAndAssignStatement createCallAndAssignStatement(String id, String operation, List<Object> words, NameTranslator methodNameTranslator) { String symbolName = getWord(words, 2); String instanceName = getWord(words, 3); String methodName = getWord(words, 4); Object[] args = makeArgsArray(words, 5); return new CallAndAssignStatement(id, symbolName, instanceName, methodName, args, methodNameTranslator); }
public void testClasspath() throws Exception { WikiPage root = InMemoryPage.makeRoot("RooT"); WikiPage page = WikiPageUtil.addPage(root, PathParser.parse("ClassPath"), "!path 123\n!path abc\n"); List<?> paths = page.getData().getClasspaths(); assertTrue(paths.contains("123")); assertTrue(paths.contains("abc")); }
public void overridesNestedPairRule() { ParserTestHelper.assertTranslatesTo(" * item--1\n--", list("ul", 0) + listItem("item--1", 1) + list("/ul", 0) + "--");
public void onShutdown(ZooKeeperServer server) { MBeanRegistry.getInstance().unregister(dataTreeBean); MBeanRegistry.getInstance().unregister(svrBean); }
public void jsonpQueryArgument() throws Exception { request.addInput("jsonp", "load"); assertPageWithTableResponseWith("|cell|\n", "load({\"tables\": [{\"cell\": {}}]})"); }
WikiPage addChildPage(String name); boolean hasChildPage(String name); WikiPage getChildPage(String name); void removeChildPage(String name); List<WikiPage> getChildren(); String getName(); PageData getData(); ReadOnlyPageData readOnlyData(); Collection<VersionInfo> getVersions(); @Deprecated PageData getDataVersion(String versionName); WikiPage getVersion(String versionName); String getHtml(); VersionInfo commit(PageData data); PageCrawler getPageCrawler(); WikiPage getHeaderPage(); WikiPage getFooterPage(); }
public void testGetStreamMode() { Assert.assertEquals( "expected to return un-compressed stream", StreamMode.CHECKED, SnapStream.getStreamMode("snapshot.180000e3a2") ); Assert.assertEquals( "expected to return snappy stream", StreamMode.SNAPPY, SnapStream.getStreamMode("snapshot.180000e3a2.snappy") ); Assert.assertEquals( "expected to return gzip stream",
Future<Object> asyncGet(String key); <T> Future<CASValue<T>> asyncGets(String key, Transcoder<T> tc); Future<CASValue<Object>> asyncGets(String key); <T> CASValue<T> gets(String key, Transcoder<T> tc) throws OperationTimeoutException; CASValue<Object> gets(String key) throws OperationTimeoutException; <T> T get(String key, Transcoder<T> tc) throws OperationTimeoutException; Object get(String key) throws OperationTimeoutException; <T> Future<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); Future<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> Future<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); Future<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc) throws OperationTimeoutException; Map<String, Object> getBulk(Collection<String> keys) throws OperationTimeoutException; <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys) throws OperationTimeoutException; Map<String, Object> getBulk(String... keys) throws OperationTimeoutException; Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, int by) throws OperationTimeoutException; long decr(String key, int by) throws OperationTimeoutException; Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, int by); long incr(String key, int by, long def) throws OperationTimeoutException; long decr(String key, int by, long def) throws OperationTimeoutException; Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); }
public static void startWithFactory(SlimFactory slimFactory, Options options) throws IOException { ServerSocketFactory serverSocketFactory = options.useSSL ? new SslServerSocketFactory(true, options.sslParameterClassName) : new PlainServerSocketFactory(); try { SlimService slimservice = new SlimService(slimFactory.getSlimServer(), serverSocketFactory.createServerSocket(options.port), options.daemon);
public void testSystemStarted(TestSystem testSystem, String testSystemName, String testRunner) throws Exception { } @Override public void newTestStarted(TestPage test, TimeMeasurement timeMeasurement) throws Exception { } @Override public void testOutputChunk(String output) throws Exception { } @Override public void testComplete(TestPage test, TestSummary testSummary, TimeMeasurement timeMeasurement) throws Exception { } @Override public void writeHead(String pageType) throws Exception { } }
public void abort() { try { super.close(); } catch (IOException ioe) { LOG.warn("Unable to abort file {}", tmpFile, ioe); } if (!tmpFile.delete()) { LOG.warn("Unable to delete tmp file during abort {}", tmpFile);
public void run() { try { sock.setSoTimeout(leader.self.getTickTime()*leader.self.getInitLimit());
public void shutdown() throws IOException { for(QueueAttachment qa : connections) { if(qa.channel != null) { qa.channel.close(); qa.sk=null; if(qa.toWrite > 0) { getLogger().warn( "Shut down with %d bytes remaining to write", qa.toWrite); } getLogger().debug("Shut down channel %s", qa.channel); } } selector.close(); getLogger().debug("Shut down selector %s", selector); }
public void config() { this.mockery = new Mockery(); this.translator = mockery.mock(UrlToResourceTranslator.class); this.webRequest = mockery.mock(HttpServletRequest.class); this.webResponse = mockery.mock(HttpServletResponse.class); this.request = new VRaptorRequest(null, webRequest, webResponse); this.requestInfo = mockery.mock(RequestInfo.class); this.lookup = new ResourceLookupInterceptor(translator, requestInfo, request); }
public void testCommandPatternJava() throws Exception { String pageText = "!define TEST_SYSTEM {slim}\n"; WikiPage page = makeTestPage(pageText); Descriptor descriptor = new WikiPageDescriptor(page.readOnlyData(), false, false, getClassPath(page)); MockClientBuilder clientBuilder = new MockClientBuilder(descriptor); String sep = System.getProperty("path.separator"); String prefix = javaExecutablePrefix(); assertEquals(prefix + "java -cp fitnesse.jar" + sep + "%p %m", clientBuilder.getCommandPattern()); }
private static SlimClient dummySlimClient() { return new SlimClient() { @Override
public void shouldReportMissingMethodOnFixtureClassWhenMethodCanNotBeFoundOnBothFixtureAndSystemUnderTest() { createAnnotatedFixture(); String result = (String) statementExecutor.call(INSTANCE_NAME, "noSuchMethod"); String expectedErrorMessage = String.format(MESSAGE_NO_METHOD_IN_CLASS, "noSuchMethod", 0, MyAnnotatedSystemUnderTestFixture.class.getName()); assertTrue(result.contains(expectedErrorMessage)); }
public void shouldNotComplainAboutEmpty() { assertThat(converter.convert("", BigDecimal.class), is(nullValue())); }
public void endMethod() { if ((access & Opcodes.ACC_ABSTRACT) == 0) { mv.visitMaxs(0, 0); } mv.visitEnd(); }
public void testUnspecifiedClientAddress() throws Exception { int[] ports = new int[3]; for (int port : ports) { port = PortAssignment.unique(); } String server = "server.0=localhost:" + ports[0] + ":" + ports[1] + ";" + ports[2]; QuorumServer qs = new QuorumServer(0, server); Assert.assertEquals(qs.clientAddr.getHostString(), "0.0.0.0"); Assert.assertEquals(qs.clientAddr.getPort(), ports[2]); }
public boolean canHandle(Object target, Object property) { return false; }
public void testFinderShouldDealWithOtherLinks() throws Exception { WhereUsedPageFinder whereUsed = new WhereUsedPageFinder(pageThree, this); WikiPage newPage = WikiPageUtil.addPage(root, PathParser.parse("NewPage"), "I enjoy being a sibling of [[the third page][http://fitnesse.org]]"); whereUsed.search(root); assertEquals(0, hits.size()); }
public void setUp() throws Exception { output = new PipedOutputStream(); input = new PipedInputStream(output); responder = new TestResultFormattingResponder(); formatter = new MockResultFormatter(); responder.formatter = formatter; result1 = new PageResult("Result1Title", new Counts(1, 2, 3, 4), "result1 data"); result2 = new PageResult("Result2Title", new Counts(4, 3, 2, 1), "result2 data"); context = new FitNesseContext(); }
public void setup() { this.converter = new PrimitiveShortConverter(); this.errors = new ArrayList<ValidationMessage>(); this.bundle = ResourceBundle.getBundle("messages"); }
long incr(String key, int by, long def) throws OperationTimeoutException; long decr(String key, int by, long def) throws OperationTimeoutException; Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs);  void authenticate(String username, String password) throws OperationException; }
public void testNonSpecial() { assertEquals(EphemeralType.VOID, EphemeralType.get(0)); assertEquals(EphemeralType.NORMAL, EphemeralType.get(1)); assertEquals(EphemeralType.NORMAL, EphemeralType.get(Long.MAX_VALUE)); }
void setCommitProcMaxCommitBatchSize(int size); int getRequestThrottleLimit(); void setRequestThrottleLimit(int requests); int getRequestThrottleStallTime(); void setRequestThrottleStallTime(int time); boolean getRequestThrottleDropStale(); void setRequestThrottleDropStale(boolean drop); boolean getRequestStaleLatencyCheck(); void setRequestStaleLatencyCheck(boolean check); boolean getRequestStaleConnectionCheck(); void setRequestStaleConnectionCheck(boolean check);  void resetStatistics();  void resetLatency();  void resetMaxLatency();  void resetFsyncThresholdExceedCount();  long getNumAliveConnections();  long getDataDirSize();  long getLogDirSize();  String getSecureClientPort();  String getSecureClientAddress();  long getTxnLogElapsedSyncTime();  int getJuteMaxBufferSize();  int getLastClientResponseSize();  int getMinClientResponseSize();  int getMaxClientResponseSize(); long getFlushDelay(); void setFlushDelay(long delay); long getMaxWriteQueuePollTime(); void setMaxWriteQueuePollTime(long delay); int getMaxBatchSize(); void setMaxBatchSize(int size); }
public void close() { if (closed.compareAndSet(false, true)) { doClose();
protected void initClient() throws Exception { initClient(new DefaultConnectionFactory() { @Override
public Object invoke(Object proxy, Object[] args) { try { logger.debug("proxy invoke, proxy {}, method {}", proxy, methodProxy);
private void addOp(int which, Operation op) { assert isAlive() : "IO Thread is not running."; conn.addOperation(which, op); }
public boolean removeAll(Collection<?> arg0) { throw new UnsupportedOperationException(); }
public void processResult(int rc, String path, Object ctx); }  @InterfaceAudience.Public interface MultiCallback extends AsyncCallback {  public void processResult(int rc, String path, Object ctx, List<OpResult> opResults); } }
InetSocketAddress parseAddr(String s){ String parts[] = s.split(":"); if (parts.length != 2) { System.out.println(s + " does not have the form host:port"); } InetSocketAddress addr = new InetSocketAddress(parts[0], Integer.parseInt(parts[1])); return addr; }
public void asynchronousStart() throws IOException { ProcessBuilder processBuilder = new ProcessBuilder(command); processBuilder.environment().putAll(determineEnvironment()); if (LOG.isLoggable(Level.FINE)) { LOG.fine("Starting process " + asList(command)); } process = processBuilder.start(); sendCommandStartedEvent(); redirectOutputs(); }
public void setUp() throws Exception { root = InMemoryPage.makeRoot("RooT"); crawler = root.getPageCrawler(); pageOne = crawler.addPage(root, PathParser.parse("PageOne"), "has PageOne content"); childPage = crawler.addPage(root, PathParser.parse("PageOne.PageOneChild"), "PageChild is a child of PageOne"); virtualPage = crawler.addPage(root, PathParser.parse("PageTwo"), "PageTwo has a bit of content too\n^PageOneChild"); PageData data = virtualPage.getData(); virtualPage.commit(data); foundPages.clear(); }
public void addVariable(String name, String value) throws Exception { initializeVariableRoot(); variableRoot.addVariable(name, value); }
public void stoppedAtDateShouldBeDateRepresentationOfStoppedAt() throws Exception { TimeMeasurement measurement = new TimeMeasurement(); measurement.start(); assertThat(measurement.stop().stoppedAtDate().getTime(), is(measurement.stoppedAt())); }
void close() throws IOException;  public interface TxnIterator {  TxnHeader getHeader();  Record getTxn();  boolean next() throws IOException;  void close() throws IOException;  long getStorageSize() throws IOException; } }
public void assertThatClearInOneThreadDoesNotMessUpAnotherThread() throws InterruptedException { Thread t1 = new Thread(new T1()); Thread t2 = new Thread(new T2()); t1.start(); t2.start(); t1.join(); t2.join(); assertEquals("value", valueFound); }
public void addConfigNode() { DataNode zookeeperZnode = nodes.get(procZookeeper); if (zookeeperZnode != null) {
public void testTocOnRoot() throws Exception { TOCWidget widget = new TOCWidget(new WidgetRoot(root), "!contents\n"); String html = widget.render(); assertHasRegexp("ParenT", html); assertHasRegexp("ParentTwo", html); }
protected Request requestFrom(String commandSpecification) { return new MockRequestBuilder(commandSpecification).build(); }
public void shutdown() { nextProcessor.shutdown(); syncProcessor.shutdown(); }
public void getsVirtualChildren() { TestRoot root = new TestRoot(); WikiPage page = root.makePage("PageOne"); root.makePage(page, "PageTwo"); root.makePage(page, "PageThree"); WikiPage virtualPage = root.makePage("VirtualPage"); VirtualCouplingExtension extension = (VirtualCouplingExtension) virtualPage.getExtension(VirtualCouplingExtension.NAME); extension.setVirtualCoupling(new MockVirtualCouplingPage(page)); WikiSourcePage source = new WikiSourcePage(virtualPage); ArrayList<String> names = new ArrayList<String>(); for (SourcePage child: source.getChildren()) names.add(child.getName()); assertEquals(2, names.size()); assertTrue(names.contains("PageTwo")); assertTrue(names.contains("PageThree")); }
void header(String key, String value); void created();  void created(String location); void ok(); void conflict(); void methodNotAllowed(EnumSet<HttpMethod> allowedMethods); }
public void testObservers() throws IOException, InterruptedException { testCommand("observers", new Field("synced_observers", Integer.class),
private static boolean isUpperCaseLetter(String candidate, int offset) { return candidate.charAt(offset) >= 'A' && candidate.charAt(offset) <= 'Z'; }
public void shouldCallXStreamJsonSerialization() { String expectedResult = "{\"message\": {\"message\": \"Just another {0} in {1}\",\"category\": \"success\"}}"; serialization.from("success", "message.cat").as(json()); assertThat(result(), is(equalTo(expectedResult))); }
public byte[] readBuffer(String tag) throws IOException { int len = readInt(tag); if (len == -1) return null; if (len < 0 || len > maxBuffer) { throw new RuntimeException("Unreasonable length = " + len); } byte[] arr = new byte[len]; in.readFully(arr); return arr; }
private <T> void includeParametersInFlash(final Class<T> type, Method method, Object[] args) { request.getSession().setAttribute(ParametersInstantiatorInterceptor.FLASH_PARAMETERS, args); }
public void testRemoveAnyChildWatcher() throws Exception { zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); MyWatcher w1 = new MyWatcher("/node1", 2); MyWatcher w2 = new MyWatcher("/node1", 1); LOG.info("Adding data watcher {} on path {}", w1, "/node1"); assertNotNull("Didn't set data watches", zk2.exists("/node1", w1));
public synchronized void serialize(DataTree dt, Map<Long, Integer> sessions, File snapShot) throws IOException { if (!close) { OutputStream sessOS = new BufferedOutputStream(new FileOutputStream(snapShot));
public void complete() { if (pendingChunks.decrementAndGet() <= 0) { latch.countDown();
public void wikitextPageShouldReadParentVariable() { WikiPage pageWithVariable = WikiPageUtil.addPage(root, PathParser.parse("ChildOne"), "!define Variable {my variable}"); WikiPage symPage = new SymbolicPage("SymPage", pageOne, pageWithVariable); assertEquals("my variable", symPage.getVariable("Variable")); }
String getLearnerMaster();  void setLearnerMaster(String learnerMaster); }
public void testRemoveAllPersistentWatchesOnAPathPartially(boolean useAsync) throws Exception { zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); BlockingDeque<WatchedEvent> persistentEvents = new LinkedBlockingDeque<>(); zk2.addWatch("/node1", persistentEvents::add, AddWatchMode.PERSISTENT); assertWatchers(zk2, "/node1", WatcherType.Persistent); assertNoWatchers(zk2, "/node1", WatcherType.Data); removeAllWatches(zk2, "/node1", WatcherType.Data, false, Code.NOWATCHER, useAsync); assertWatchers(zk2, "/node1", WatcherType.Persistent); assertNoWatchers(zk2, "/node1", WatcherType.Data); zk1.create("/node1/child1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); zk1.setData("/node1", null, -1); assertEvent(persistentEvents, EventType.NodeChildrenChanged, "/node1"); assertEvent(persistentEvents, EventType.NodeDataChanged, "/node1"); assertNull(persistentEvents.poll(10, TimeUnit.MILLISECONDS)); }
public void testUrlEncodedSpacesInFileName() throws Exception { request.setResource("files/file4%20with%20spaces%32.txt"); responder = (FileResponder) FileResponder.makeResponder(request, context.getRootPagePath()); assertEquals("files/file4 with spaces2.txt", responder.resource); }
private void finishOutputForTest() throws Exception { writeData("</div>" + HtmlTag.endl); }
public void gotData(String k, int flags, long cas, byte[] data) { assert key.equals(k) : "Wrong key returned"; assert cas > 0 : "CAS was less than zero: " + cas; val=new CASValue<T>(cas, tc.decode( new CachedData(flags, data, tc.getMaxSize())));
private HtmlTag makeMovePageForm() throws Exception { HtmlTag form = HtmlUtil.makeFormTag("get", resource); form.add(HtmlUtil.makeInputTag("hidden", "responder", "movePage")); form.add("New Location: "); form.add(HtmlUtil.makeInputTag("text", "newLocation", "")); form.add(HtmlUtil.BR); form.add(HtmlUtil.makeInputTag("submit", "", "Move Page")); return form; }
private String prettifyConnectionString(InetSocketAddress confAddress, int boundPort) { if (confAddress != null) { return confAddress.getHostString() .replace("0.0.0.0", "localhost") .replace("0:0:0:0:0:0:0:0", "localhost") + ":" + boundPort; } throw new IllegalStateException("No client address is configured"); }
private Object callMethodAtIndex(StatementExecutorInterface caller, int methodIndex) { String instanceName = getWord(methodIndex + 0); String methodName = getWord(methodIndex + 1); Object[] args = makeArgsArray(methodIndex + 2); return caller.call(instanceName, methodName, args); }
private void fillData() {
private SlimTestContextImpl makeTables(String scenarioText, String decisionTableText) throws Exception { SlimTestContextImpl testContext = new SlimTestContextImpl(new WikiTestPage(root)); String tableText = "!|scenario|" + scenarioText + "|\n" + "\n" + "!|" + SCRIPT_EXTENSION_NAME + "|\n" + "\n" + "!|DT:" + decisionTableText + "|\n"; WikiPageUtil.setPageContents(root, tableText); TableScanner ts = new HtmlTableScanner(root.getHtml()); Table t = ts.getTable(0); ScenarioTable st = new ScenarioTable(t, "s_id", testContext); t = ts.getTable(1); DiffScriptTable2 dst = new DiffScriptTable2(t, "ds_id", testContext); t = ts.getTable(2); dt = new DecisionTable(t, "did", testContext); assertions.addAll(st.getAssertions()); assertions.addAll(dst.getAssertions()); assertions.addAll(dt.getAssertions()); return testContext; }
public LogCommand specify(LogCommand log, Repository repository) { for (File file : files) { log.addPath(getPath(file, repository)); } return log.setMaxCount(historyDepth); }
public void shouldNotProxifyJavaLangObjectMethods() throws Exception { Object proxy = proxifier.proxify(JavassistProxifierTest.class, new MethodInvocation<Object>() { public Object intercept(Object proxy, Method method, Object[] args, SuperMethod superMethod) { fail("should not call this Method interceptor"); return null; } }); new Mirror().on(proxy).invoke().method("finalize").withoutArgs(); }
private void testReadWriteShort(byte value) { byte[] orig = new byte[2]; byte[] dest = new byte[2]; setArray(orig, value, 0, 2); int one = LEDataInputStream.readUShort(orig, 0); LEDataOutputStream.writeUShort(one, dest, 0); assertArrayEquals(orig, dest);
public void testDeleteRecursive() throws IOException, InterruptedException, KeeperException { final ZooKeeper zk = createClient();
public void onClick(View v) { GroupEditActivity.Launch(GroupActivity.this, mGroup); }
public static boolean isASuiteSpecificationsTable(Table table) { return !tableIsTooSmall(table) && table.getCellContents(0, 0).equals("Suite"); }
private void visitSwitchInsn(final Label dflt, final Label[] labels) {
public void testIncompleteMessageAfterException() throws Exception { formatter.setTrackingId("2"); formatter.announceNumberTestsToRun(1); formatter.testStarted(page); pageBuffer.setLength(0); formatter.errorOccurred(new Exception("test"));
public void testFailOnUnknownValue() throws IOException { try { data.setSrc(missingFile);
public void produce( final DataConsumer pReceiver ) throws IOException { TarArchiveEntry entry = new TarArchiveEntry(path, symlink ? TarArchiveEntry.LF_SYMLINK : TarArchiveEntry.LF_LINK); entry.setLinkName(linkName); entry.setUserId(Producers.ROOT_UID); entry.setUserName(Producers.ROOT_NAME); entry.setGroupId(Producers.ROOT_UID); entry.setGroupName(Producers.ROOT_NAME); entry.setMode(TarArchiveEntry.DEFAULT_FILE_MODE); entry = map(entry); entry.setName(path); entry.setLinkName(linkName); pReceiver.onEachLink(entry); }
public void verifyClientConnects() throws Exception {
Future<Boolean> replace(String key, int exp, Object o); <T> Future<T> asyncGet(String key, Transcoder<T> tc); Future<Object> asyncGet(String key); <T> Future<CASValue<T>> asyncGets(String key, Transcoder<T> tc); Future<CASValue<Object>> asyncGets(String key); <T> CASValue<T> gets(String key, Transcoder<T> tc) throws OperationTimeoutException; CASValue<Object> gets(String key) throws OperationTimeoutException; <T> T get(String key, Transcoder<T> tc) throws OperationTimeoutException; Object get(String key) throws OperationTimeoutException; <T> Future<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); Future<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> Future<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); Future<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc) throws OperationTimeoutException; Map<String, Object> getBulk(Collection<String> keys) throws OperationTimeoutException; <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys) throws OperationTimeoutException; Map<String, Object> getBulk(String... keys) throws OperationTimeoutException; Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, int by) throws OperationTimeoutException; long decr(String key, int by) throws OperationTimeoutException; long incr(String key, int by, long def, int exp) throws OperationTimeoutException; long decr(String key, int by, long def, int exp) throws OperationTimeoutException; Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, int by); long incr(String key, int by, long def) throws OperationTimeoutException; long decr(String key, int by, long def) throws OperationTimeoutException; Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs);  void authenticate(final CallbackHandler cbh) throws OperationException; }
private void assertParseVN(String str, int major, int minor, int bugfix, String modifier ) { VersionNumber v = new VersionNumber(str); assertEquals("test major of " + str, major, v.major); assertEquals("test minor of " + str, minor, v.minor); assertEquals("test bugfix of " + str, bugfix, v.bugfix); assertEquals("test modifier of " + str, modifier, v.modifier); }
File getFile();  String getFileName();  String getCompleteFileName(); }
public String getName();  public int getQuorumSize();  public int getInitLimit();  public int getSyncLimit();  public void setInitLimit(int initLimit);  public void setSyncLimit(int syncLimit);  public boolean isSslQuorum();  public boolean isPortUnification();  public long getObserverElectionDelayMS();  public void setObserverElectionDelayMS(long delayMS); }
public void init() throws Exception { statementExecutor = slimFactory.getStatementExecutor(); statementExecutor.addPath(getTestModulePath()); }
public void shouldDelegateToStatusOnNotFound() throws Exception { Status status = mockResult(Status.class); result.notFound(); verify(status).notFound();
public <T> XmlSerializer from(T object) throws IOException { XmlSerializer serializer = new XmlSerializer(response.getWriter()); return serializer; }
public static void logTextTraceMessage(String text, long traceMask) { if (!doLog(traceMask)) { return; } synchronized (ZooLog.class) { checkTextTraceFile();
public void testStarted(TestPage testPage) throws IOException { currentTest = (WikiTestPage) testPage; currentTestTime = new TimeMeasurement().start(); resultsListener.newTestStarted(currentTest, currentTestTime); }
public void oneRowThatExplicitlyFailsNoChange() throws Exception { assertTableResults("|2|4|\n", asList(
private boolean collectionSetOrMap(Object object) { return object instanceof Collection || object instanceof Set || object instanceof Map; }
public ArrayList<Object> fromString(String arg) { ArrayList<Object> result; Matcher matcher = LIST_PATTERN.matcher(arg); if (matcher.matches()) { result = new ArrayList<>(); String items = matcher.group(2); if (!"".equals(items)) { items = items.replaceFirst("^\\s*<li>\\s*", ""); items = items.replaceFirst("\\s*</li>\\s*$", ""); String[] elements = items.split("\\s*</li>\\s*<li>\\s*"); result.addAll(Arrays.asList(elements)); } } else { result = new ArrayList<>(super.fromString(arg)); } return result; }
public void testSingleServerChrootPath(){ String chrootPath = "/hallo/welt"; String servers = "10.10.10.1"; assertChrootPath(chrootPath, new ConnectStringParser(servers+chrootPath)); servers = "[2001:db8:1::242:ac11:2]"; assertChrootPath(chrootPath, new ConnectStringParser(servers+chrootPath));
public void shouldRollbackTransactionIfStillActiveWhenExecutionFinishes() throws Exception { JPATransactionInterceptor interceptor = new JPATransactionInterceptor(entityManager); when(entityManager.getTransaction()).thenReturn(transaction); when(transaction.isActive()).thenReturn(true); interceptor.intercept(stack, method, instance); verify(transaction).rollback(); }
public void testResponse() throws Exception { crawler.addPage(root, PathParser.parse("ChildPage"), "child content with <html>"); request.setResource("ChildPage"); SimpleResponse response = (SimpleResponse) responder.makeResponse(new FitNesseContext(root), request); assertEquals(200, response.getStatus()); String body = response.getContent(); assertSubString("<html>", body); assertSubString("<form", body); assertSubString("method=\"post\"", body); assertSubString("child content with &lt;html&gt;", body); assertSubString("name=\"responder\"", body); assertSubString("name=\"" + EditResponder.TIME_STAMP + "\"", body); assertSubString("name=\"" + EditResponder.TICKET_ID + "\"", body); assertSubString("type=\"submit\"", body); }
public String nameFor(String name) { if(name.length()==1) { return name.toLowerCase(); } StringBuilder content = new StringBuilder(); content.append(Character.toLowerCase(name.charAt(0))); for(int i=1;i<name.length();i++) { char c = name.charAt(i); if(Character.isUpperCase(c)) { content.append('_'); content.append(Character.toLowerCase(c)); } else { content.append(c); } } return content.toString(); }
String getContent(); boolean targetExists(String wikiWordPath); String makeFullPathOfTarget(String wikiWordPath); String findParentPath(String targetName); Maybe<SourcePage> findIncludedPage(String pageName); Collection<SourcePage> getAncestors(); Collection<SourcePage> getChildren(); boolean hasProperty(String propertyKey); String getProperty(String propertyKey); String makeUrl(String wikiWordPath); }
public String getVariable(String name) throws Exception { return "myTestRunner"; }
public void testRegexp() throws Exception { assertTrue(Pattern.matches(HeaderWidget.REGEXP, "!1 some text\n")); assertTrue(Pattern.matches(HeaderWidget.REGEXP, "!2 \n")); assertTrue(Pattern.matches(HeaderWidget.REGEXP, "!3 text\n")); assertTrue(Pattern.matches(HeaderWidget.REGEXP, "!4 text\n")); assertTrue(Pattern.matches(HeaderWidget.REGEXP, "!5 text\n")); assertTrue(Pattern.matches(HeaderWidget.REGEXP, "!6 text\n")); assertTrue(!Pattern.matches(HeaderWidget.REGEXP, "!3text\n")); assertTrue(!Pattern.matches(HeaderWidget.REGEXP, "!0 text\n")); assertTrue(!Pattern.matches(HeaderWidget.REGEXP, "!7 text\n")); }
public int read(byte[] b, int off, int len) throws IOException { return delegate.read(b, off, len); }
public InputStream getInputStream(File file) throws IOException, UnsupportedEncodingException { return new ByteArrayInputStream(files.get(file.getPath()).payload.getBytes("UTF-8")); }
public void sendBye() throws IOException { writeString("bye"); }
public CommandRunner init(CommandRunningFitClient fitClient, String hostName, int port, int ticketNumber) { this.fitClient = fitClient; String fitArguments = hostName + SPACE + port + SPACE + ticketNumber; String commandLine = command + SPACE + fitArguments; this.commandRunner = new CommandRunner(commandLine, "", environmentVariables); return commandRunner; }
public void testEofReadLine() throws Exception { writeToPipe("one line\ntwo lines\nthree lines"); output.close(); assertFalse(reader.isEof()); reader.readLine(); assertFalse(reader.isEof()); reader.readLine(); assertFalse(reader.isEof()); reader.readLine(); assertTrue(reader.isEof()); }
public KeyedOperation touch(String key, int expiration, OperationCallback cb) { return new TouchOperationImpl(key, expiration, cb); }
public void testPackageConffiles() { project.executeTarget("conffiles"); assertTrue("package not build", new File("target/test-classes/test.deb").exists()); }
BlockingQueue<Operation> createOperationQueue();  BlockingQueue<Operation> createReadOperationQueue();  BlockingQueue<Operation> createWriteOperationQueue();  long getOpQueueMaxBlockTime();  NodeLocator createLocator(List<MemcachedNode> nodes);  OperationFactory getOperationFactory();  long getOperationTimeout();  boolean isDaemon();  boolean useNagleAlgorithm();  Collection<ConnectionObserver> getInitialObservers();  FailureMode getFailureMode();  Transcoder<Object> getDefaultTranscoder();  boolean shouldOptimize();  int getReadBufSize();  public HashAlgorithm getHashAlg();  long getMaxReconnectDelay();  AuthDescriptor getAuthDescriptor(); }
public void run() { GroupActivity.Launch(PasswordActivity.this, null, GroupActivity.ADD_GROUP_ONLY); }
public void canProvideAllPrototypeScopedComponents() { checkAvailabilityFor(false, BaseComponents.getPrototypeScoped().keySet()); }
private void registerApplicationScopedComponentsOn(DefaultListableBeanFactory beanFactory) { registerOn(beanFactory, DefaultRouter.class); registerOn(beanFactory, StupidTranslator.class); registerOn(beanFactory, DefaultInterceptorRegistry.class); registerOn(beanFactory, AsmBasedTypeCreator.class); registerOn(beanFactory, DefaultPathResolver.class); registerOn(beanFactory, ParanamerNameProvider.class); registerOn(beanFactory, DefaultConverters.class); registerOn(beanFactory, EmptyElementsRemoval.class); registerOn(beanFactory, ResourcesHolder.class); registerOn(beanFactory, ResourceFinder.class); registerOn(beanFactory, ResourceRegistrar.class); registerOn(beanFactory, NoRoutesConfiguration.class); registerOn(beanFactory, PathAnnotationRoutesCreator.class); }
public void canEvaluateReturnValuesAndColorizeTableForMultipleCallsToSameFunction() throws Exception { makeDecisionTableAndBuildInstructions(decisionTableWithSameFunctionMultipleTimes); int n=0; Map<String, Object> pseudoResults = SlimCommandRunningClient.resultToMap( list( list(id(n++), "OK"), list(id(n++), VOID_TAG), list(id(n++), VOID_TAG),
void testSystemStarted(TestSystem testSystem) throws IOException; void testOutputChunk(String output) throws IOException; void testStarted(TestPage testPage) throws IOException; void testComplete(TestPage testPage, TestSummary testSummary) throws IOException; void testSystemStopped(TestSystem testSystem, Throwable cause ); void testAssertionVerified(Assertion assertion, TestResult testResult); void testExceptionOccurred(Assertion assertion, ExceptionResult exceptionResult); }
private Response makeErrorResponse(FitNesseContext context, Request request, String message) { return new ErrorResponder(message).makeResponse(context, request); }
protected Class queryTableClass() { return QueryTable.class; }
public void setTickTime(int tickTime);  public int getMaxClientCnxnsPerHost();  public void setMaxClientCnxnsPerHost(int max);  public int getMinSessionTimeout();  public void setMinSessionTimeout(int min);  public int getMaxSessionTimeout();  public void setMaxSessionTimeout(int max);  public void resetStatistics();  public void resetLatency();  public void resetMaxLatency();  public long getNumAliveConnections();  public long getDataDirSize();  public long getLogDirSize(); }
public void testContainsValue() { assertFalse(cacheMap.containsValue("anything")); }
protected String makeSummaryContent() { String summaryContent = "<strong>Test Pages:</strong> " + pageCounts.toString() + "&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"; if (latestTestTime != null) { summaryContent += String.format("<strong>Assertions:</strong> %s (%.03f seconds)", getAssertionCounts(), latestTestTime.elapsedSeconds()); } else { summaryContent += String.format("<strong>Assertions:</strong> %s ", getAssertionCounts()); } return summaryContent; }
void testOutputChunk(String readValue); void testComplete(TestSummary summary); void exceptionOccurred(Throwable e); }
public Response makeResponse(FitNesseContext context, Request request) throws Exception; }
private void createFakeJarFileResources() throws IOException { FileUtil.createFile("classes/Resources/files/TestFile","") ; FileUtil.createFile("classes/Resources/files/BestFile","") ; FileUtil.createFile("classes/Resources/SpecialFile",""); }
public Object[] query() { int n = Integer.parseInt(args[0]); Collection<Factor> factors = new ArrayList<Factor>(); for (int f = 2; n > 1; f++) for (; n % f == 0; n /= f) factors.add(new Factor(f)); return factors.toArray(new Factor[factors.size()]); }
private Object getObject(WikiPage root, MockRequest request) throws Exception { Responder responder = new SerializedPageResponder(); SimpleResponse response = (SimpleResponse) responder.makeResponse(new FitNesseContext(root), request); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(response.getContentBytes())); Object obj = ois.readObject(); return obj; }
protected void inStreamCreated(InputArchive ia, FileInputStream is) throws IOException{ FileHeader header= new FileHeader(); header.deserialize(ia, "fileheader"); }
public void testContentSize() throws Exception { response.add("12345"); response.closeAll(); assertEquals(5, response.getContentSize()); }
public void testValidArguments() { String[] args = {"2181", "/data/dir", "60000", "10000"}; serverConfig.parse(args); assertEquals(2181, serverConfig.getClientPortAddress().getPort()); assertEquals(new File("/data/dir"), serverConfig.getDataDir()); assertEquals(60000, serverConfig.getTickTime()); assertEquals(10000, serverConfig.getMaxClientCnxns()); }
public void testSystemStarted(TestSystem testSystem); public void newTestStarted(WikiTestPage test) throws IOException; public void testOutputChunk(String output) throws IOException; public void testAssertionVerified(Assertion assertion, TestResult testResult); public void testExceptionOccurred(Assertion assertion, ExceptionResult exceptionResult); public void testComplete(WikiTestPage test, TestSummary testSummary, TimeMeasurement timeMeasurement) throws IOException; public void errorOccurred(Throwable cause); }
public static HtmlTag makeBreadCrumbsWithPageType( String trail, String separator, String type ) throws Exception { TagGroup group = makeBreadCrumbsWithCurrentPageLinked(trail, separator); group.add(HtmlUtil.BR); group.add(HtmlUtil.makeSpanTag("page_type", type)); return group; }
private void deferProcessingToContainer(FilterChain filterChain, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException { if (logger.isDebugEnabled()) { logger.debug("deferring URI to container: " + request.getRequestURI()); } filterChain.doFilter(request, response); }
public void setUp() throws Exception { mockery = new Mockery(); session = mockery.mock(HttpSession.class); result = mockery.mock(Result.class); stack = mockery.mock(InterceptorStack.class); mockResponse = mockery.mock(HttpServletResponse.class); response = new VRaptorResponse(mockResponse); interceptor = new FlashInterceptor(session, result, response); }
private void print(String key, Object value) { if (value == null) { output(key, null);
public void ifListenerIsSet_newTestStartedFiresTestStarted() throws Exception{ jf.setListener(listener); WikiTestPage page=buildNestedTestPage(); jf.testStarted(page); verify(listener).testStarted(page); }
void serialize(); XmlSerializer include(String fieldName); XmlSerializer addMethod(String methodName); XmlSerializer from(String prefix, Collection collection); XmlSerializer namespace(String uri, String prefix); }
public boolean equals(Object o) { if(o == null || ! (o instanceof Counts)) return false; Counts other = (Counts)o; return right == other.right && wrong == other.wrong &&
void setCommitProcMaxCommitBatchSize(int size); int getRequestThrottleLimit(); void setRequestThrottleLimit(int requests); int getRequestThrottleStallTime(); void setRequestThrottleStallTime(int time); boolean getRequestThrottleDropStale(); void setRequestThrottleDropStale(boolean drop); int getThrottledOpWaitTime(); void setThrottledOpWaitTime(int val); boolean getRequestStaleLatencyCheck(); void setRequestStaleLatencyCheck(boolean check); boolean getRequestStaleConnectionCheck(); void setRequestStaleConnectionCheck(boolean check); int getLargeRequestMaxBytes(); void setLargeRequestMaxBytes(int bytes); int getLargeRequestThreshold(); void setLargeRequestThreshold(int threshold);  void resetStatistics();  void resetLatency();  void resetMaxLatency();  void resetFsyncThresholdExceedCount();  long getNumAliveConnections();  long getDataDirSize();  long getLogDirSize();  String getSecureClientPort();  String getSecureClientAddress();  long getTxnLogElapsedSyncTime();  int getJuteMaxBufferSize();  int getLastClientResponseSize();  int getMinClientResponseSize();  int getMaxClientResponseSize(); long getFlushDelay(); void setFlushDelay(long delay); long getMaxWriteQueuePollTime(); void setMaxWriteQueuePollTime(long delay); int getMaxBatchSize(); void setMaxBatchSize(int size);  int getMaxCnxns(); }
public Maybe<String> render(Scanner scanner) { return null;
public StoreOperation store(StoreType storeType, String key, int flags, int exp, byte[] data, StoreOperation.Callback cb) { return new StoreOperationImpl(storeType, key, flags, exp, data, cb); }
protected void setUp() throws Exception { FileUtil.createDir(ROOT); expect(revisionController.history((FileSystemPage) anyObject())).andStubReturn(new HashSet<VersionInfo>()); expect(revisionController.makeVersion((FileSystemPage) anyObject(), (PageData) anyObject())).andStubReturn(new VersionInfo("PageName")); expect(revisionController.checkState((String) anyObject())).andStubReturn(VERSIONED); revisionController.add((String) anyObject()); expectLastCall().anyTimes(); revisionController.prune((FileSystemPage) anyObject()); expectLastCall().asStub(); }
public void testIfCalsNextOnStackIfDoesntAcceptsIt() throws Exception { final Object instance = new Object(); mockery.checking(new Expectations() {{ one(resourceMethod).getMethod(); will(returnValue(FakeResource.class.getMethod("string"))); one(stack).next(resourceMethod, instance); }}); interceptor.intercept(stack, resourceMethod, instance); mockery.assertIsSatisfied(); }
public void testGetEnginePrivate() { long expResult = 0L; long result = instance.getEnginePrivate(); assertEquals(expResult, result); }
public static String formatDate(String format, Date date) { SimpleDateFormat fmt = new SimpleDateFormat(format); return fmt.format(date); }
public DERObject toASN1Object() { ASN1EncodableVector v = new ASN1EncodableVector(); v.add(version); v.add(subject); v.add(subjectPKInfo); if (attributes != null) { v.add(new DERTaggedObject(false, 0, attributes)); } return new DERSequence(v); }
public void stdErr(String output) { for (ExecutionLogListener listener : listeners) listener.stdErr(output);
private void enlarge(final int size) { int length1 = 2 * data.length; int length2 = length + size; byte[] newData = new byte[length1 > length2 ? length1 : length2]; System.arraycopy(data, 0, newData, 0, length); data = newData; }
V fetch(K key) throws E; } public interface ExpirationPolicy<K, V> { boolean isExpired(K key, V value, long lastModified); }  public class Builder<K, V, E extends Throwable> { private Loader<K, V, E> loader; private ExpirationPolicy<K, V> expirationPolicy = new NoExpirationPolicy<K, V>(); public Builder<K, V, E> withLoader(Loader<K, V, E> loader) { this.loader = loader; return this; } public Builder<K, V, E> withExpirationPolicy(ExpirationPolicy<K, V> expirationPolicy) { this.expirationPolicy = expirationPolicy; return this; } public Cache<K, V, E> build() { return new Cache<K, V, E>() { private Map<K, SoftReference<CachedValue<V>>> cacheMap = new ConcurrentHashMap<K, SoftReference<CachedValue<V>>>(); @Override public V get(K key) throws E { final SoftReference<CachedValue<V>> ref = cacheMap.get(key); final CachedValue<V> cachedValue = ref != null ? ref.get() : null; V value; if (cachedValue == null || expirationPolicy.isExpired(key, cachedValue.value, cachedValue.lastModified)) { value = loader.fetch(key); if (value != null) { put(key, value); } else { cacheMap.remove(key); } } else { value = cachedValue.value; } return value; } public void put(K key, V value) { CachedValue<V> cachedValue = new CachedValue<V>(value, Clock.currentTimeInMillis()); cacheMap.put(key, new SoftReference<CachedValue<V>>(cachedValue)); } @Override public void expire(K key) { cacheMap.remove(key); } }; } private static class CachedValue<V> { private V value; private long lastModified; CachedValue(V value, long lastModified) { this.value = value; this.lastModified = lastModified; } } private static class NoExpirationPolicy<K, V> implements ExpirationPolicy<K, V> { @Override public boolean isExpired(K key, V value, long lastModified) { return false; } } } }
public void registerParametersWithMultipleRegexes() throws SecurityException, NoSuchMethodException { DefaultParametersControl control = new DefaultParametersControl("/test/{hash1:[a-z0-9]{16}}{id}{hash2:[a-z0-9]{16}}/", Collections.singletonMap("id", "(\\d+)"), converters, evaluator); control.fillIntoRequest("/test/0123456789abcdef1234fedcba9876543210", request); verify(request).setParameter("hash1", new String[] {"0123456789abcdef"}); verify(request).setParameter("id", new String[] {"1234"}); verify(request).setParameter("hash2", new String[] {"fedcba9876543210"}); }
ReadOnlyPageData readOnlyData(); Collection<VersionInfo> getVersions(); WikiPage getVersion(String versionName); String getHtml(); VersionInfo commit(PageData data); PageCrawler getPageCrawler(); @Deprecated
private void loadDatabase( String pass, Uri keyfile) { if (pass.length() == 0 && (keyfile == null || keyfile.toString().length() == 0)) { errorMessage(R.string.error_nopass); return; }
public void visitClassType(final String name) { className = name; v.visitClassType(remapper.mapType(name)); }
protected void retreatCounter() { if (engineState[12] == 0) { throw new IllegalStateException("attempt to reduce counter past zero."); } --engineState[12]; }
public void unregisterGauge(String name) { PrometheusGaugeWrapper existing = gauges.remove(name); if (existing != null) { existing.unregister();
private void writeField( OutputStream out, long fieldValue) throws IOException { if (fieldValue >= (1L << 7)) { if (fieldValue >= (1L << 14)) { if (fieldValue >= (1L << 21)) { if (fieldValue >= (1L << 28)) { if (fieldValue >= (1L << 35)) { if (fieldValue >= (1L << 42)) { if (fieldValue >= (1L << 49)) { if (fieldValue >= (1L << 56)) { out.write((int)(fieldValue >> 56) | 0x80); } out.write((int)(fieldValue >> 49) | 0x80); } out.write((int)(fieldValue >> 42) | 0x80); } out.write((int)(fieldValue >> 35) | 0x80); } out.write((int)(fieldValue >> 28) | 0x80); } out.write((int)(fieldValue >> 21) | 0x80); } out.write((int)(fieldValue >> 14) | 0x80); } out.write((int)(fieldValue >> 7) | 0x80); } out.write((int)fieldValue & 0x7f); }
protected void reportSizeLimitExceeded(final IllegalStateException e) { validator.add(new I18nMessage("upload", "servlet3.upload.filesize.exceeded")); logger.warn("The file size limit was exceeded.", e); }
public static int readFully(InputStream inStr, byte[] buf, int off, int len) throws IOException { int totalRead = 0; while (totalRead < len) { int numRead = inStr.read(buf, off + totalRead, len - totalRead); if (numRead < 0) { break; } totalRead += numRead; } return totalRead; }
public void shutdown(){ stop = true; LOG.debug("Shutting down connection manager"); manager.halt(); LOG.debug("Shutting down messenger"); messenger.halt(); LOG.debug("FLE is down"); }
public void setup() { this.mockery = new VRaptorMockery(); this.requestResult = mockery.mock(MethodInfo.class); this.result = mockery.mock(PageResult.class); this.info = mockery.mock(ComponentInfoProvider.class); this.stack = mockery.mock(InterceptorStack.class); this.interceptor = new ViewInterceptor(result, requestResult, info); }
public void testTestSummaryTestFail() throws Exception { TimeMeasurement totalTimeMeasurement = new TimeMeasurement().start(); TimeMeasurement timeMeasurement = new TimeMeasurement(); formatter.writeHead("test"); formatter.announceNumberTestsToRun(1); formatter.newTestStarted(page, timeMeasurement.start()); formatter.testComplete(page, new TestSummary(4, 1, 0, 0), timeMeasurement.stop()); formatter.allTestingComplete(totalTimeMeasurement.stop()); assertSubString("<strong>Assertions:</strong> 4 right, 1 wrong, 0 ignored, 0 exceptions", pageBuffer.toString()); assertSubString("document.getElementById(\"test-summary\").className = \"fail\"", pageBuffer.toString()); }
private Artifact resolveJLine(final VersionNumber scalaVersion, final Artifact defaultFallback) { final Artifact compilerArtifact = super.scalaCompilerArtifact(scalaVersion.toString()); final Set<Artifact> compilerDeps = super.resolveArtifactDependencies(compilerArtifact); for (final Artifact a : compilerDeps) { if (this.filterForJline(a)) { return a; } } super.getLog().warn("Unable to determine the required Jline dependency from the POM. Falling back to hard-coded defaults."); super.getLog().warn("If you get an InvocationTargetException, then this probably means we guessed the wrong version for JLine"); super.getLog().warn(String.format("Guessed JLine: %s", defaultFallback.toString())); return defaultFallback; }
public void testCombineArraysWithMixedNumbers() { String[] first = new String[]{"a", "b", "c"}; String[] second = new String[]{"d", "e"}; String[] result = StringUtil.combineArrays(first, second); assertEquals(5, result.length); assertEquals("a", result[0]); assertEquals("b", result[1]); assertEquals("c", result[2]); assertEquals("d", result[3]); assertEquals("e", result[4]); }
public void setUp() throws Exception { cmMethodCalls.clear(); FileUtil.deleteFileSystemDirectory(base); createFileSystemDirectory(base); root = (FileSystemPage) FileSystemPage.makeRoot(defaultPath, "RooT", new NullRevisionController()); crawler = root.getPageCrawler(); }
public Object remove(Object key) { throw new RuntimeException(); }
private String makeDirectoryListingPage() throws Exception { HtmlPage page = context.htmlPageFactory.newPage(); page.setTitle("Files: " + resource);
public void channelConnected(ChannelHandlerContext ctx, ChannelStateEvent e) throws Exception { if (LOG.isTraceEnabled()) { LOG.trace("Channel connected " + e); } allChannels.add(ctx.getChannel()); NettyServerCnxn cnxn = new NettyServerCnxn(ctx.getChannel(), zkServer, NettyServerCnxnFactory.this); ctx.setAttachment(cnxn); addCnxn(cnxn); }
@Override public TestResult evaluateExpectation(Object returnValues) { return null; } @Override public ExceptionResult evaluateException(ExceptionResult exceptionResult) { return null; }
public void shouldSerializeNoLinksIfThereIsNoTransition() { String xml = xstream.toXML(resource); assertThat(xml, not(containsString("atom:link"))); }
public void processResult(int rc, String path, Object ctx) { synchronized (result) { result[0] = rc;
private static HostNameType determineHostFormat(final String host) { if (InetAddressUtils.isIPv4Address(host)) { return HostNameType.IPv4; } String s = host; if (s.startsWith("[") && s.endsWith("]")) { s = host.substring(1, host.length() - 1); } if (InetAddressUtils.isIPv6Address(s)) { return HostNameType.IPv6; } return HostNameType.DNS; }
public int hashCode() { return Objects.hashCode(category) ^ Objects.hashCode(message) ^ Objects.hash(parameters) ^ Objects.hashCode(severity);
long lastReadDelta();  void completedRead();  void reconnecting();  void connected();  int getReconnectCount();  void registerChannel(SocketChannel ch, SelectionKey selectionKey);  void setChannel(SocketChannel to);  SocketChannel getChannel();  void setSk(SelectionKey to);  SelectionKey getSk();  int getBytesRemainingToWrite();  int writeSome() throws IOException;  void fixupOps();  void authComplete();  void setupForAuth();  void setContinuousTimeout(boolean timedOut); int getContinuousTimeout(); MemcachedConnection getConnection(); void setConnection(MemcachedConnection connection); }
public void testShouldStopSyncronizationIfAnyChildPageThrowErrors() throws Exception { final String errorMsg = "Some error"; expect(revisionController.checkState(contentAndPropertiesFilePathFor(FS_SIBLING_CHILD_PAGE))).andThrow(new RevisionControlException(errorMsg)); expect(revisionController.checkState(contentAndPropertiesFilePathFor(FS_CHILD_PAGE))).andReturn(VERSIONED).anyTimes(); replay(revisionController); createPage(FS_CHILD_PAGE); createPage(FS_SIBLING_CHILD_PAGE, parentPage); request.setResource(FS_PARENT_PAGE); invokeResponderAndCheckSuccessStatus(); assertSubString(errorMsg, response.getContent()); }
protected FileSystemPage createPage(String pageName, FileSystemPage parent) throws Exception { PageCrawler crawler = root.getPageCrawler(); return (FileSystemPage) crawler.addPage(parent, PathParser.parse(pageName)); }
public void head() { } public void add() { } } @Test public void shouldIgnoreANonAnnotatedMethod() throws SecurityException, NoSuchMethodException { ResourceMethod method = lookuper.methodFor("/add", "POST"); assertThat(method, is(Matchers.nullValue())); mockery.assertIsSatisfied(); } @Test public void shouldIgnoreAResourceWithTheWrongWebMethod() throws SecurityException, NoSuchMethodException { ResourceMethod method = lookuper.methodFor("/clients/remove", "POST"); assertThat(method, is(Matchers.nullValue())); mockery.assertIsSatisfied(); } @Test public void shouldAcceptAResultWithASpecificWebMethod() throws SecurityException, NoSuchMethodException { ResourceMethod method = lookuper.methodFor("/clients/head", "HEAD"); assertThat(method.getMethod(), is(equalTo(Clients.class.getMethod("head")))); mockery.assertIsSatisfied(); } }
public void bracesAroundArgumentInTable() throws Exception { SlimTestContextImpl testContext = makeTables( "echo|user|giving|user_old|\n" + "|check|echo|@{user}|@{user_old}", "EchoGiving|\n" + "|user|user_old|\n" + "|7|7" ); Map<String, Object> pseudoResults = SlimCommandRunningClient.resultToMap( asList( asList("decisionTable_did_0/diffScriptTable_s_id_0", "7") ) ); SlimAssertion.evaluateExpectations(assertions, pseudoResults); String scriptTable = dt.getChildren().get(0).getTable().toString(); String expectedScript = "[[diffScriptScenario, echo, user, giving, user_old], [check, echo, 7, pass(7)]]"; assertEquals(expectedScript, scriptTable); assertEquals(1, testContext.getTestSummary().getRight()); assertEquals(0, testContext.getTestSummary().getWrong()); assertEquals(0, testContext.getTestSummary().getIgnores()); assertEquals(0, testContext.getTestSummary().getExceptions()); }
public void buildTestSystemNameWhenTestSystemIsUnknownDefaultsToFit() throws Exception { WikiPage testPage = WikiPageUtil.addPage(root, PathParser.parse("TestPage"), "!define TEST_SYSTEM {X}\n"); String testSystemName = new WikiPageDescriptor(testPage.readOnlyData(), false, false, "").getTestSystemName(); Assert.assertEquals("X:fit.FitServer", testSystemName); }
private MultiOperationRecord generateMultiTransaction(Iterable<Op> ops) {
private String multiply(String value, int numberofTime) { StringBuilder result = new StringBuilder(); for (int i = 0; i < numberofTime; ++i) { result.append(value); } return result.toString(); }
public void testPrunesSuites() throws Exception { SuiteFilter filter = new SuiteFilter(null, null, null); WikiPage prunedSuite = crawler.addPage(root, PathParser.parse("MySuite"), "the suite"); PageData data = prunedSuite.getData(); data.setAttribute(PageData.PropertyPRUNE); data.setAttribute("Suite"); prunedSuite.commit(data); assertFalse(filter.getFilterForTestsInSuite(prunedSuite).hasMatchingTests()); assertTrue(filter.getFilterForTestsInSuite(root).hasMatchingTests()); }
Collection<ConnectionObserver> getInitialObservers();  FailureMode getFailureMode();  Transcoder<Object> getDefaultTranscoder(); }
protected void setUp() throws Exception { LOG.info("STARTING " + getName()); }
public void testRemoveWatcherWhenNoConnection(boolean useAsync) throws Exception { zk1.create("/node1", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); MyWatcher w1 = new MyWatcher("/node1", 2); MyWatcher w2 = new MyWatcher("/node1", 1); LOG.info("Adding data watcher {} on path {}", w1, "/node1"); assertNotNull(zk2.exists("/node1", w1), "Didn't set data watches");
public CASOperation cas(String key, long casId, int flags, int exp, byte[] data, OperationCallback cb) { return new CASOperationImpl(key, casId, flags, exp, data, cb); }
protected void loadChildren() throws Exception { if (cacheTime <= (System.currentTimeMillis() - lastLoadChildrenTime)) { ProxyPage page = retrievePage(getThisPageUrl());
public String toString() { return "ip: " + sock.socket().getRemoteSocketAddress() + " sessionId: 0x" + Long.toHexString(sessionId);
public void logout() { userInfo.logout(); result.use(Results.logic()).redirectTo(HomeController.class).index(); }
public void testComplete(WikiTestPage test, TestSummary testSummary, TimeMeasurement timeMeasurement) { System.out.println(new WikiPagePath(test.getSourcePage()).toString() + " r " + testSummary.right + " w " + testSummary.wrong + " " + testSummary.exceptions
private void addHeadContent() throws Exception { TagGroup head = new TagGroup(); if(isUpdate) head.add("Updating imported wiki."); else head.add("Importing wiki."); head.add(" This may take a few moments."); head.add(HtmlUtil.BR); head.add(HtmlUtil.BR); head.add("Destination wiki: "); String pageName = PathParser.render(path); head.add(HtmlUtil.makeLink(pageName, pageName)); head.add(HtmlUtil.BR); head.add("Source wiki: "); String remoteWikiUrl = remoteUrl(); head.add(HtmlUtil.makeLink(remoteWikiUrl, remoteWikiUrl)); head.add(HtmlUtil.BR); head.add(HtmlUtil.BR); head.add("Imported pages:"); head.add(HtmlUtil.HR); response.add(head.html()); }
public UriBasedRule with(HttpMethod method) { this.method = method; return this; }
public void propertiesForm() throws Exception { assertHasRegexp("<input.*value=\"Search Properties\".*>", content); assertHasRegexp("<input.*name=\"responder\".*value=\"executeSearchProperties\"", content); for (String attributeName : SEARCH_ACTION_ATTRIBUTES) { assertSubString(attributeName, content);
public void exceptionForBadInputType() throws Exception { Parse table = doTableOf(row("field") + row("NotAnInt")); String s = getStringFor(table); assertTrue(s.contains("java.lang.NumberFormatException: For input string: \"NotAnInt\"")); }
protected void performExecution() throws Exception { SuiteContentsFinder suiteTestFinder = new SuiteContentsFinder(page, root, getSuiteFilter()); MultipleTestsRunner runner = new MultipleTestsRunner(suiteTestFinder.getAllPagesToRunForThisSuite(), context, page, formatter); runner.executeTestPages(); }
public boolean accept(Node node) { Tag tag; Attribute attribute; boolean ret; ret = false; if (node instanceof Tag) { tag = (Tag) node; attribute = tag.getAttributeEx(mAttribute); ret = null != attribute; if (ret && (null != mValue)) ret = attribute.getValue().startsWith(mValue); } return (ret); }
public ZooKeeperServer createServer() throws IOException { ManagedZooKeeperServer zks = new ManagedZooKeeperServer( new FileTxnSnapLog(new File(ServerConfig.getDataDir()), new File(ServerConfig.getDataLogDir())), new ZooKeeperServer.BasicDataTreeBuilder()); return zks; }
public void doRow(Parse row) { if(row.parts.body.indexOf(ERROR_INDICATOR) != -1) return; super.doRow(row); try {
public void shouldBeAbleToIncludeSubclassesFields() throws Exception { serialization.from(new B()).include("field2").serialize(); assertThat(result(), is("<b>\n <field2/>\n</b>")); }
public boolean hasNext() { return !path.isEmpty() && (level < maxLevel); }
void setupResend();  void fillWriteBuffer(boolean optimizeGets);  void transitionWriteItem();  Operation getCurrentReadOp();  Operation removeCurrentReadOp();  Operation getCurrentWriteOp();  Operation removeCurrentWriteOp();  boolean hasReadOp();  boolean hasWriteOp();  void addOp(Operation op);  void insertOp(Operation o);  int getSelectionOps();  ByteBuffer getRbuf();  ByteBuffer getWbuf();  SocketAddress getSocketAddress();  boolean isActive();  boolean isAuthenticated();  long lastReadDelta();  void completedRead();  void reconnecting();  void connected();  int getReconnectCount();  void registerChannel(SocketChannel ch, SelectionKey selectionKey);  void setChannel(SocketChannel to);  SocketChannel getChannel();  void setSk(SelectionKey to);  SelectionKey getSk();  int getBytesRemainingToWrite();  int writeSome() throws IOException;  void fixupOps();  void authComplete();  void setupForAuth();  void setContinuousTimeout(boolean timedOut); int getContinuousTimeout(); }
public void setup() { this.mockery = new Mockery(); this.resource = mockery.mock(Resource.class); this.lookup = new VRaptor2MethodLookup(resource); }
public void setExecutionLogAndTrackingId(String stopResponderId, CompositeExecutionLog log) throws Exception; public void announceStartNewTest(WikiPage test) throws Exception; public void processTestOutput(String output) throws Exception; public void processTestResults(WikiPage test, TestSummary testSummary) throws Exception; public void errorOccured(); }
public void usingRegexesWithCurlyBracesNotOnTheEndAndOtherVarAndManyOtherThings() throws Exception { builder = newBuilder("/abc/{abc:[0-9A-Z]{5}}{def}{xxx:[0-9A-Z]{5}}"); builder.is(MyResource.class, method.getMethod()); Route route = builder.build(); assertFalse("invalid uri", route.canHandle("/abc/notValid/def/12")); assertFalse("invalid uri", route.canHandle("/abc/ABC123/def/12")); assertTrue("valid uri", route.canHandle("/abc/AAAAA14BBBBB"));
public void execute() throws BuildException { try { FitNesseMain.main(new String[]
boolean touchSession(long sessionId, int sessionTimeout);  void setSessionClosing(long sessionId);  void shutdown();  void removeSession(long sessionId);  boolean isTrackingSession(long sessionId);  void checkSession(long sessionId, Object owner) throws KeeperException.SessionExpiredException, KeeperException.SessionMovedException, KeeperException.UnknownSessionException;  void checkGlobalSession(long sessionId, Object owner) throws KeeperException.SessionExpiredException, KeeperException.SessionMovedException; void setOwner(long id, Object owner) throws SessionExpiredException;  void dumpSessions(PrintWriter pwriter);  Map<Long, Set<Long>> getSessionExpiryMap();  long getLocalSessionCount(); }
public void shouldUseTheDefaultLocale() throws ParseException { when(request.getAttribute(LOCALE_KEY + ".request")).thenReturn(null); when(request.getSession()).thenReturn(session); when(session.getAttribute(LOCALE_KEY + ".session")). thenReturn(null); when(context.getAttribute(LOCALE_KEY + ".application")). thenReturn(null); when(context.getInitParameter(LOCALE_KEY)). thenReturn(null); when(request.getLocale()).thenReturn(null); Date date = new SimpleDateFormat("dd/MM/yyyy").parse("10/05/2010"); String formattedToday = DateFormat.getDateInstance(DateFormat.SHORT).format(date); assertThat(converter.convert(formattedToday, Date.class, bundle), is(equalTo(date))); }
public void addTarFileSet(Tar.TarFileSet fileset) { dataProducers.add(new FileSetDataProducer(fileset)); }
Future<Boolean> append(String key, Object val); <T> Future<Boolean> append(long cas, String key, T val, Transcoder<T> tc); <T> Future<Boolean> append(String key, T val, Transcoder<T> tc); Future<Boolean> prepend(long cas, String key, Object val); Future<Boolean> prepend(String key, Object val); <T> Future<Boolean> prepend(long cas, String key, T val, Transcoder<T> tc); <T> Future<Boolean> prepend(String key, T val, Transcoder<T> tc); <T> Future<CASResponse> asyncCAS(String key, long casId, T value, Transcoder<T> tc); Future<CASResponse> asyncCAS(String key, long casId, Object value); <T> CASResponse cas(String key, long casId, int exp, T value, Transcoder<T> tc); CASResponse cas(String key, long casId, Object value); <T> Future<Boolean> add(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> add(String key, int exp, Object o); <T> Future<Boolean> set(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> set(String key, int exp, Object o); <T> Future<Boolean> replace(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> replace(String key, int exp, Object o); <T> Future<T> asyncGet(String key, Transcoder<T> tc); Future<Object> asyncGet(String key); Future<CASValue<Object>> asyncGetAndTouch(final String key, final int exp); <T> Future<CASValue<T>> asyncGetAndTouch(final String key, final int exp, final Transcoder<T> tc); CASValue<Object> getAndTouch(String key, int exp); <T> CASValue<T> getAndTouch(String key, int exp, Transcoder<T> tc); <T> Future<CASValue<T>> asyncGets(String key, Transcoder<T> tc); Future<CASValue<Object>> asyncGets(String key); <T> CASValue<T> gets(String key, Transcoder<T> tc); CASValue<Object> gets(String key); <T> T get(String key, Transcoder<T> tc); Object get(String key); <T> BulkFuture<Map<String, T>> asyncGetBulk(Iterator<String> keys, Iterator<Transcoder<T>> tcs); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Iterator<Transcoder<T>> tcs); <T> BulkFuture<Map<String, T>> asyncGetBulk(Iterator<String> keys, Transcoder<T> tc); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); BulkFuture<Map<String, Object>> asyncGetBulk(Iterator<String> keys); BulkFuture<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> BulkFuture<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); BulkFuture<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Iterator<String> keys, Transcoder<T> tc); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc); Map<String, Object> getBulk(Iterator<String> keys); Map<String, Object> getBulk(Collection<String> keys); <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys); Map<String, Object> getBulk(String... keys); <T> Future<Boolean> touch(final String key, final int exp, final Transcoder<T> tc); <T> Future<Boolean> touch(final String key, final int exp); Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, long by); long incr(String key, int by); long decr(String key, long by); long decr(String key, int by); long incr(String key, long by, long def, int exp); long incr(String key, int by, long def, int exp); long decr(String key, long by, long def, int exp); long decr(String key, int by, long def, int exp); Future<Long> asyncIncr(String key, long by); Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, long by); Future<Long> asyncDecr(String key, int by); long incr(String key, long by, long def); long incr(String key, int by, long def); long decr(String key, long by, long def); long decr(String key, int by, long def); Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs);  Set<String> listSaslMechanisms(); }
public void shouldTestXRefsInSubSuites() throws Exception { WikiPageUtil.addPage(suite, PathParser.parse("SubSuite"), "!see .PageA\n!see .PageB"); WikiPage pageA = WikiPageUtil.addPage(root, PathParser.parse("PageA")); WikiPage pageB = WikiPageUtil.addPage(root, PathParser.parse("PageB")); SuiteContentsFinder finder = new SuiteContentsFinder(suite, null, root); List<WikiPage> xrefTestPages = finder.gatherCrossReferencedTestPages(); assertEquals(2, xrefTestPages.size()); assertTrue(xrefTestPages.contains(pageA)); assertTrue(xrefTestPages.contains(pageB)); }
public void testMakeInitErrorMetadataScript() { HtmlTag scriptTag = HtmlUtil.makeInitErrorMetadataScript(); String expected = "<script>initErrorMetadata();</script>"; assertSubString(expected, scriptTag.html()); }
public void takeSnapshot() throws IOException { takeSnapshot(false); }
public void testClientReconnect() throws IOException, InterruptedException { HostProvider hostProvider = mock(HostProvider.class); when(hostProvider.size()).thenReturn(1); InetSocketAddress inaddr = new InetSocketAddress(1111); when(hostProvider.next(anyLong())).thenReturn(inaddr); ZooKeeper zk = mock(ZooKeeper.class); sc = SocketChannel.open(); ClientCnxnSocketNIO nioCnxn = new MockCnxn(); ClientWatchManager watcher = mock(ClientWatchManager.class); ClientCnxn clientCnxn = new ClientCnxn( "tmp", hostProvider, 5000, zk, watcher, nioCnxn, false); clientCnxn.start(); countDownLatch.await(5000, TimeUnit.MILLISECONDS); Assert.assertTrue(countDownLatch.getCount() == 0); clientCnxn.close(); }
public void closeChunks() throws IOException { if (!dontChunk) { sender.send(("0" + CRLF).getBytes());
protected void engineSetSeed(byte[] bytes) { try { OutputStream out;
public void portRotates() throws Exception { for (int i = 1; i < 15; i++) { SlimClientBuilder clientBuilder = new SlimClientBuilder(new WikiPageDescriptor(root.getData(), false, getClassPath(root)));
private double exp() { boolean neg = false; if (s.charAt(0) == '-') { neg = true; advance(); } double result = paren(); while (!s.isEmpty()) { if (s.charAt(0) == '^') { result = exponentiate(result); } else break; } if (neg) result *= -1; return result; }
public void cheksThatValidationWorks() throws ServletException, IOException { DefaultValidator validator = new DefaultValidator(proxifier, result,logic); final Student guilherme = new Student(); mockery.checking(new Expectations() { { one(result).include((String) with(an(String.class)), with(an(Object.class))); one(result).forward("invalid"); } }); try { validator.checking(new Validations() {
public void testLeaderConversation(LeaderConversation conversation) throws Exception { Socket pair[] = getSocketPair(); Socket leaderSocket = pair[0]; Socket followerSocket = pair[1]; File tmpDir = File.createTempFile("test", "dir", testData); tmpDir.delete(); tmpDir.mkdir(); LeadThread leadThread = null; Leader leader = null; try { QuorumPeer peer = createQuorumPeer(tmpDir);
public void begin(final String name, final Attributes attrs) { Map typeLists = new HashMap(); typeLists.put("local", new ArrayList()); typeLists.put("stack", new ArrayList()); push(attrs.getValue("type")); push(attrs.getValue("count") == null ? "0" : attrs.getValue("count")); push(typeLists); }
private static void addLinkToActions(TagGroup actions, WikiPageAction action) { actions.add(makeAction(action));
public static XStreamBuilder cleanInstance(Converter...converters) { return new XStreamBuilderImpl( new XStreamConverters(Arrays.asList(converters), Collections.<SingleValueConverter>emptyList()),
public void DirectoryOfHtmlFilesIsExternalSuitePage() throws Exception { fileSystem.makeFile("./somepath/ExternalSuite/myfile.html", "stuff"); WikiPage page = rootPage.createChildPage("ExternalSuite"); assertEquals(ExternalSuitePage.class, page.getClass()); }
public void testNonexistentMutate() throws Exception { assertEquals(-1, client.incr("nonexistent", 1)); assertEquals(-1, client.decr("nonexistent", 1)); }
private void usage() { System.out.println("usage: java fit.FitServer [-v] host port socketTicket"); System.out.println("\t-v\tverbose"); System.exit(-1); }
public void canProvideAllRequestScopedComponents() { checkAvailabilityFor(false, HttpServletRequest.class, HttpServletResponse.class, VRaptorRequest.class, DefaultInterceptorStack.class, RequestExecution.class, ResourceLookupInterceptor.class, InstantiateInterceptor.class, DefaultResult.class, ExecuteMethodInterceptor.class, OgnlParametersProvider.class, Converters.class, HttpSession.class); checkAvailabilityFor(false, PageResult.class); mockery.assertIsSatisfied(); }
public Response makeResponse(FitNesseContext context, Request request) throws Exception { String resource = request.getResource(); HtmlPage page = context.htmlPageFactory.newPage(); Template template = VelocityFactory.getVelocityEngine().getTemplate("refactorForm.vm"); page.setMainTemplate("refactorForm.vm"); page.setTitle("Refactor: " + resource); page.setPageTitle(new PageTitle("Refactor", PathParser.parse(resource))); page.put("refactoredRootPage", resource); page.put("request", request); SimpleResponse response = new SimpleResponse(); response.setContent(page.html()); return response; }
public void nextPageAndItsTeardownShouldBeSkippedOnStopTestInSuiteSetUp() throws TestExecutionException { String exceptionId = SlimServer.EXCEPTION_STOP_TEST_TAG + "StopTestException"; slimTestSystem.newTestPage("SuiteSetUp"); slimTestSystem.processTable(table(exceptionId), false); slimTestSystem.newTestPage(); slimTestSystem.processTable(table("NextPage"), false); slimTestSystem.processTable(tearDownTable("NextPageTearDown"), false); assertTestRecords(fail(exceptionId), ignore("NextPage"), ignore("NextPageTearDown")); }
public void surroundGroupsOfTestPagesWithRespectiveSetUpAndTearDowns(List<WikiPage> pageList) throws Exception { this.pageList = pageList; Map<String, LinkedList<WikiPage>> pageSetUpTearDownGroups = new HashMap<String, LinkedList<WikiPage>>(); createPageSetUpTearDownGroups(pageSetUpTearDownGroups); pageList.clear(); reinsertPagesViaSetUpTearDownGroups(pageSetUpTearDownGroups); }
private static boolean deleteInBatch(ZooKeeper zk, List<String> tree, int batchSize) throws InterruptedException { int rateLimit = 10; List<Op> ops = new ArrayList<>(); BatchedDeleteCbContext context = new BatchedDeleteCbContext(rateLimit); MultiCallback cb = (rc, path, ctx, opResults) -> { ((BatchedDeleteCbContext)ctx).sem.release(); if (rc != Code.OK.intValue()) { ((BatchedDeleteCbContext)ctx).success.set(false); } };
public void testFixtureNameNotFound() throws Throwable { assertCannotLoadFixture("Successfully loaded a nonexistent fixture!", "BlahBlahBlah", NoSuchFixtureException.class);
public void verboseOutputIfSlimFlagSet() throws Exception { getResultsForPageContents("!define SLIM_FLAGS {-v}\n"); assertTrue(responder.getCommandLine().indexOf("java -cp classes fitnesse.slim.SlimService -v") != -1); }
Transcoder<Object> getTranscoder(); Future<Boolean> append(long cas, String key, Object val); <T> Future<Boolean> append(long cas, String key, T val, Transcoder<T> tc); Future<Boolean> prepend(long cas, String key, Object val); <T> Future<Boolean> prepend(long cas, String key, T val, Transcoder<T> tc); <T> Future<CASResponse> asyncCAS(String key, long casId, T value, Transcoder<T> tc); Future<CASResponse> asyncCAS(String key, long casId, Object value); <T> CASResponse cas(String key, long casId, T value, Transcoder<T> tc) throws OperationTimeoutException; CASResponse cas(String key, long casId, Object value) throws OperationTimeoutException; <T> Future<Boolean> add(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> add(String key, int exp, Object o); <T> Future<Boolean> set(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> set(String key, int exp, Object o); <T> Future<Boolean> replace(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> replace(String key, int exp, Object o); <T> Future<T> asyncGet(String key, Transcoder<T> tc); Future<Object> asyncGet(String key); <T> Future<CASValue<T>> asyncGets(String key, Transcoder<T> tc); Future<CASValue<Object>> asyncGets(String key); <T> CASValue<T> gets(String key, Transcoder<T> tc) throws OperationTimeoutException; CASValue<Object> gets(String key) throws OperationTimeoutException; <T> T get(String key, Transcoder<T> tc) throws OperationTimeoutException; Object get(String key) throws OperationTimeoutException; <T> Future<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); Future<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> Future<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); Future<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc) throws OperationTimeoutException; Map<String, Object> getBulk(Collection<String> keys) throws OperationTimeoutException; <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys) throws OperationTimeoutException; Map<String, Object> getBulk(String... keys) throws OperationTimeoutException; Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); long incr(String key, int by) throws OperationTimeoutException; long decr(String key, int by) throws OperationTimeoutException; long incr(String key, int by, int def) throws OperationTimeoutException; long decr(String key, int by, long def) throws OperationTimeoutException; Future<Boolean> delete(String key, int hold); Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); }
void start() throws IOException; Map<String, Object> invokeAndGetResponse(List<Instruction> statements) throws IOException; void bye() throws IOException; void kill() throws IOException; String getTestRunner(); ExecutionLog getExecutionLog(); }
private void initializeResponder(FitNesseContext context) { if (resultsDirectory == null) resultsDirectory = context.getTestHistoryDirectory(); todaysDate = Clock.currentDate(); }
private Response makeTestHistoryXmlResponse(TestHistory history) { SimpleResponse response = new SimpleResponse(); VelocityContext velocityContext = new VelocityContext(); velocityContext.put("testHistory", history); response.setContentType(Format.XML); response.setContent(VelocityFactory.translateTemplate(velocityContext, "testHistoryXML.vm")); return response; }
public void run() {
public void shouldAcceptNull() { assertThat((MyCustomEnum) converter.convert(null, MyCustomEnum.class), is(nullValue())); }
public void shouldAcceptFile() throws Exception { Method method = FakeResource.class.getMethod("file"); assertThat(interceptor, accepts(method)); }
public void visitIntInsn(final int opcode, final int operand) { mv.visitIntInsn(opcode, operand); if (constructor && (opcode != NEWARRAY)) { pushValue(OTHER);
protected void loadChildren() throws Exception {
public void testRightArrowOnPageThatDoesNotExist() throws Exception { WikiPage page = crawler.addPage(root, PathParser.parse("FrontPage")); AliasLinkWidget w = new AliasLinkWidget(new WidgetRoot(page), "[[tag][>TestPage]]"); assertEquals("tag<a href=\"FrontPage.TestPage?edit\">?</a>", w.render()); }
public void throwsInstanceNotCreatedErrorIfNoPublicDefaultConstructor() throws Exception { String result = (String) caller.create("x", getTestClassPath() + ".ClassWithNoPublicDefaultConstructor", new Object[0]); assertException("message:<<COULD_NOT_INVOKE_CONSTRUCTOR " + getTestClassPath() + ".ClassWithNoPublicDefaultConstructor[0]>>", result); }
public void testCollectEmptyStats() throws InterruptedException { RequestPathMetricsCollector requestPathMetricsCollector = new RequestPathMetricsCollector(); RequestPathMetricsCollector.PathStatsQueue pathStatsQueue = requestPathMetricsCollector.new PathStatsQueue(getChildren); Thread.sleep(5000); Map<String, Integer> newSlot = pathStatsQueue.mapReducePaths(3, pathStatsQueue.getCurrentSlot()); Assert.assertTrue(newSlot.isEmpty()); pathStatsQueue.start(); Thread.sleep(15000); newSlot = pathStatsQueue.collectStats(1); Assert.assertTrue(newSlot.size() == 0); newSlot = pathStatsQueue.collectStats(2); Assert.assertTrue(newSlot.size() == 0); newSlot = pathStatsQueue.collectStats(5); Assert.assertTrue(newSlot.size() == 0); }
public void testRegExp() throws Exception { assertMatches("!* Some title\n content \n*!"); assertMatches("!*> Some title\n content \n*!"); assertMatches("!********** Some title\n content \n**************!"); assertMatches("!* title\n * list\r*!"); assertNoMatch("!* title content *!"); assertNoMatch("!*missing a space\n content \n*!"); assertNoMatch("!* Some title\n content *!\n"); assertNoMatch("!* Some title\n content *!..."); }
public void close() { if (channel != null) { channel.close();
public void rollLog() throws IOException { txnLog.rollLog(); }
CASValue<Object> gets(String key) throws OperationTimeoutException; <T> T get(String key, Transcoder<T> tc) throws OperationTimeoutException; Object get(String key) throws OperationTimeoutException; <T> Future<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); Future<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> Future<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); Future<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc) throws OperationTimeoutException; Map<String, Object> getBulk(Collection<String> keys) throws OperationTimeoutException; <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys) throws OperationTimeoutException; Map<String, Object> getBulk(String... keys) throws OperationTimeoutException; Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, int by) throws OperationTimeoutException; long decr(String key, int by) throws OperationTimeoutException; long incr(String key, int by, long def, int exp) throws OperationTimeoutException; long decr(String key, int by, long def, int exp) throws OperationTimeoutException; Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, int by); long incr(String key, int by, long def) throws OperationTimeoutException; long decr(String key, int by, long def) throws OperationTimeoutException; Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs);  void authenticate(String mechs[], CallbackHandler cbh) throws OperationException;  Set<String> listSaslMechanisms(); }
private List<Assertion> callFunctions(int row) { List<Assertion> instructions = new ArrayList<Assertion>(); for (String functionName : funcsLeftToRight) { instructions.add(callFunctionInRow(functionName, row)); } return instructions; }
public boolean canHandle(String uri, HttpMethod method) { boolean acceptMethod = this.methods.isEmpty() || this.methods.contains(method); boolean acceptUri = control.matches(uri); return acceptUri && acceptMethod; }
private void sendBody(OutputStream output) throws Exception { for(Iterator iterator = bodyParts.iterator(); iterator.hasNext();) {
View getView(final String designDocumentName, final String viewName); List<View> getViews(final String designDocumentName);
public void setTickTime(int tickTime);  public int getMaxClientCnxnsPerHost();  public void setMaxClientCnxnsPerHost(int max);  public int getMinSessionTimeout();  public void setMinSessionTimeout(int min);  public int getMaxSessionTimeout();  public void setMaxSessionTimeout(int max);  public void resetStatistics();  public void resetLatency();  public void resetMaxLatency();  public long getNumAliveConnections(); }
public boolean matchIsNotLinedUp(int matchIndex) { MatchedPair matchedPair = matchedTables.get(matchIndex); return matchedPair.first > matchedPair.second; }
protected SlimServer createSlimServer(int timeout, boolean verbose) { return JavaSlimFactory.createJavaSlimFactory(new DefaultInteraction(), timeout, verbose).getSlimServer(); }
public Future<Map<String, T>> removeListener( BulkGetCompletionListener listener) { super.removeFromListeners((GenericCompletionListener) listener); return this; }
public Cursor fetchAllFiles() { Cursor ret; ret = mDb.query(FILE_TABLE, new String[] {KEY_FILE_ID, KEY_FILE_FILENAME, KEY_FILE_KEYFILE }, null, null, null, null, KEY_FILE_UPDATED + " DESC", Integer.toString(MAX_FILES)); return ret; }
public String runTestsAndGenerateHtml(PageData pageData) throws Exception { String html = pageData.getHtml(); if (html.length() == 0) client.send(emptyPageContent); else client.send(html); return html; }
Maybe<SourcePage> findIncludedPage(String pageName); SourcePage getParent(); Collection<SourcePage> getAncestors(); Collection<SourcePage> getChildren(); boolean hasProperty(String propertyKey); String getProperty(String propertyKey); String makeUrl(String wikiWordPath); }
void registerFormatters(FormatterRegistry registrar) throws PluginException; void registerTestSystemFactories(TestSystemFactoryRegistry testSystemFactoryRegistry) throws PluginException; void registerSlimTables(SlimTableFactory slimTableFactory) throws PluginException; void registerCustomComparators(CustomComparatorRegistry customComparatorRegistry) throws PluginException; }
public void testHtml() throws Exception { HashWidget widget = new HashWidget(new MockWidgetRoot(), "!{a:b,c:d}"); assertThat(widget.render(), matches(HTML_FOR_ABCD_HASH)); }
public void testUnrecoverableErrorCountFromRequestProcessor() throws Exception { ServerMetrics.getMetrics().resetAll(); processed = new CountDownLatch(1); PrepRequestProcessor processor = new MyPrepRequestProcessor(); processor.start(); processor.processRequest(new Request(null, 1L, 1, ZooDefs.OpCode.setData, ByteBuffer.wrap(new byte[10]), null)); processed.await(); processor.shutdown(); Map<String, Object> values = MetricsUtils.currentServerMetrics(); assertEquals(1L, values.get("unrecoverable_error_count")); }
public void testTestReferencesToSubWiki_2() throws Exception { PageData data = subWiki.getData(); data.setContent("Stuff ^PageTwo.DeepPage Stuff\n"); subWiki.commit(data); renamer.renameReferences(subWiki_pageTwo, "PageThree"); String updatedSubWikiContent = subWiki.getData().getContent(); assertEquals("Stuff ^PageThree.DeepPage Stuff\n", updatedSubWikiContent); }
void init(); void register(Class<? extends Converter<?>> converterClass); }
public PageData getDataVersion(String versionName) throws Exception { PageData data = getMeat(versionName); if(data == null) throw new NoSuchVersionException("There is no version '" + versionName + "'"); return data; }
public Result fail(String message) { return super.pass(message); }
public void flush(boolean sync) throws IOException { synchronized(this) { if (writeBuffer == null) { return; } writeBuffer.flip(); bc.write(writeBuffer); writeBuffer.clear(); writeBufferStartPosition = bc.position(); } if (sync) { bc.force(false);
protected void setUp() throws Exception { g = new BowlingGame(); }
MemcachedConnection createConnection(List<InetSocketAddress> addrs) throws IOException;  MemcachedNode createMemcachedNode(SocketAddress sa, SocketChannel c, int bufSize);  BlockingQueue<Operation> createOperationQueue();  BlockingQueue<Operation> createReadOperationQueue();  BlockingQueue<Operation> createWriteOperationQueue();  long getOpQueueMaxBlockTime();  ExecutorService getListenerExecutorService();  NodeLocator createLocator(List<MemcachedNode> nodes);  OperationFactory getOperationFactory();  long getOperationTimeout();  boolean isDaemon();  boolean useNagleAlgorithm();  Collection<ConnectionObserver> getInitialObservers();  FailureMode getFailureMode();  Transcoder<Object> getDefaultTranscoder();  boolean shouldOptimize();  int getReadBufSize();  HashAlgorithm getHashAlg();  long getMaxReconnectDelay();  AuthDescriptor getAuthDescriptor();  int getTimeoutExceptionThreshold();  MetricType enableMetrics();  MetricCollector getMetricCollector(); }
public void testOneSimpleRun_Fail() throws Exception { super.testOneSimpleRun_Fail(); }
public FitNesseContext makeFitNesseContext() throws IOException, PluginException { ComponentFactory componentFactory = new ComponentFactory(properties); WikiPageFactory wikiPageFactory = (WikiPageFactory) componentFactory.createComponent(ConfigurationParameter.WIKI_PAGE_FACTORY_CLASS, FileSystemPageFactory.class); FitNesseContext.Builder builder = new FitNesseContext.Builder(); builder.properties = properties; builder.port = getPort(); builder.rootPath = properties.getProperty(ConfigurationParameter.ROOT_PATH, DEFAULT_PATH); builder.rootDirectoryName = properties.getProperty(ConfigurationParameter.ROOT_DIRECTORY, DEFAULT_ROOT); builder.versionsController = (VersionsController) componentFactory.createComponent(ConfigurationParameter.VERSIONS_CONTROLLER_CLASS, ZipFileVersionsController.class); builder.versionsController.setHistoryDepth(getVersionDays()); builder.recentChanges = (RecentChanges) componentFactory.createComponent(ConfigurationParameter.RECENT_CHANGES_CLASS, RecentChangesWikiPage.class); builder.root = wikiPageFactory.makeRootPage(builder.rootPath, builder.rootDirectoryName); PluginsLoader pluginsLoader = new PluginsLoader(componentFactory); builder.logger = pluginsLoader.makeLogger(properties.getProperty(ConfigurationParameter.LOG_DIRECTORY)); builder.authenticator = pluginsLoader.makeAuthenticator(properties.getProperty(ConfigurationParameter.CREDENTIALS)); FitNesseContext context = builder.createFitNesseContext(); SymbolProvider symbolProvider = SymbolProvider.wikiParsingProvider; pluginsLoader.loadPlugins(context.responderFactory, symbolProvider); pluginsLoader.loadResponders(context.responderFactory); pluginsLoader.loadTestSystems((TestSystemFactoryRegistrar) context.testSystemFactory); pluginsLoader.loadSymbolTypes(symbolProvider); pluginsLoader.loadSlimTables(); pluginsLoader.loadCustomComparators(); ContentFilter contentFilter = pluginsLoader.loadContentFilter();
public String wrappedHtml() throws Exception { String txt = FitnesseFixtureContext.sender.sentData(); String txt2 = txt.replaceAll("(<br */?>)", "$1" + System.getProperty("line.separator")); return "<pre>" + HtmlUtil.escapeHTML(txt2) + "</pre>"; }
public void setUp() throws Exception { root = InMemoryPage.makeRoot("RooT"); PageData data = root.getData(); root.commit(data); }
public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) { super.onCreateOptionsMenu(menu, inflater); MenuInflater inflate = mActivity.getMenuInflater(); inflate.inflate(R.menu.password, menu); }
private void appendLength(int size) { result.append(String.format("%06d:", size)); }
public static void cancel(Context ctx) { AlarmManager am = (AlarmManager) ctx.getSystemService(Context.ALARM_SERVICE); Log.d(TAG, "Timeout cancel"); am.cancel(buildIntent(ctx)); ctx.stopService(new Intent(ctx, TimeoutService.class));
public static HtmlTag makeAppendElementScript(String idElementToAppend, String htmlToAppend) { HtmlTag scriptTag = new HtmlTag("script"); String getElement = "document.getElementById(\"" + idElementToAppend + "\")"; String escapedHtml = escapeHtmlForJavaScript(htmlToAppend); StringBuffer script = new StringBuffer(); script.append("var existingContent = ").append(getElement).append(".innerHTML;"); script.append(HtmlTag.endl); script.append(getElement).append(".innerHTML = existingContent + \"").append(escapedHtml).append("\";"); script.append(HtmlTag.endl); scriptTag.add(script.toString()); return scriptTag; }
void expire(Session session); long getServerId(); } long createSession(int sessionTimeout);  boolean addGlobalSession(long id, int to);  boolean addSession(long id, int to);  boolean touchSession(long sessionId, int sessionTimeout);  void setSessionClosing(long sessionId);  void shutdown();  void removeSession(long sessionId);  boolean isTrackingSession(long sessionId);  public void checkSession(long sessionId, Object owner) throws KeeperException.SessionExpiredException, KeeperException.SessionMovedException, KeeperException.UnknownSessionException;  public void checkGlobalSession(long sessionId, Object owner) throws KeeperException.SessionExpiredException, KeeperException.SessionMovedException; void setOwner(long id, Object owner) throws SessionExpiredException;  void dumpSessions(PrintWriter pwriter); }
public void testResultsHtml() throws Exception { formatter.testSystemStarted(null, "Fit", "laughing.fit"); formatter.announceNumberTestsToRun(2); formatter.announceStartNewTest("RelativeName", "FullName"); formatter.testOutputChunk("starting"); formatter.testOutputChunk(" output"); formatter.processTestResults("RelativeName", new TestSummary(1, 0, 0, 0)); formatter.testSystemStarted(null, "Slim", "very.slim"); formatter.announceStartNewTest("NewRelativeName", "NewFullName"); formatter.testOutputChunk("second"); formatter.testOutputChunk(" test"); formatter.processTestResults("NewRelativeName", new TestSummary(0, 1, 0, 0)); formatter.writeHead("Suite"); formatter.finishWritingOutput(); String results = pageBuffer.toString(); assertSubString("<h2>Test Output</h2>", results); assertSubString("<h2>Test System: Slim:very.slim</h2>", results); assertSubString("<div class=\"test_output_name\">", results); assertSubString("<a href=\"FullName\" id=\"RelativeName1\" class=\"test_name\">RelativeName</a>", results); assertSubString("<div class=\"alternating_block\">starting output</div>", results); assertSubString("<a href=\"NewFullName\" id=\"NewRelativeName2\" class=\"test_name\">NewRelativeName</a>", results); assertSubString("<div class=\"alternating_block\">second test</div>", results); }
public void write( byte[] b, int off, int len ) throws IOException { try { signatureGenerator.update(b, off, len);
public void setupMocks() { mockery = new Mockery(); pageResult = mockery.mock(PageResult.class); proxifier = mockery.mock(Proxifier.class); }
public int getMaxClientCnxnsPerHost();  public void setMaxClientCnxnsPerHost(int max);  public int getMinSessionTimeout();  public void setMinSessionTimeout(int min);  public int getMaxSessionTimeout();  public void setMaxSessionTimeout(int max);  public void resetStatistics();  public void resetLatency();  public void resetMaxLatency(); }
public static Document newDocument() { return getDocumentBuilder().newDocument(); }
private void startTestSystemAndExecutePages(TestSystem.Descriptor descriptor, List<WikiPage> testSystemPages) throws Exception { TestSystem testSystem = testSystemGroup.startTestSystem(descriptor, buildClassPath()); if (testSystem.isSuccessfullyStarted()) { executeTestSystemPages(testSystemPages, testSystem); waitForTestSystemToSendResults(); } else { throw new Exception("Test system not started"); } testSystem.bye(); }
public void testSystemStarted(TestSystem testSystem) throws IOException { formatters.testSystemStarted(testSystem); }
public void whenResultIsAFileShouldCreateAFileDownload() throws Exception { File tmp = File.createTempFile("test", "test"); new PrintWriter(tmp).append("abc").close(); when(info.getResult()).thenReturn(tmp); interceptor.intercept(stack, resourceMethod, null); verify(outputStream).write(argThat(is(arrayStartingWith("abc".getBytes()))), eq(0), eq(3));
public void commit(long zxid) { if (pendingTxns.size() == 0) { LOG.warn("Committing " + Long.toHexString(zxid) + " without seeing txn"); return; } long firstElementZxid = pendingTxns.element().zxid; if (firstElementZxid != zxid) { LOG.fatal("Committing zxid 0x" + Long.toHexString(zxid) + " but next pending txn 0x" + Long.toHexString(firstElementZxid)); System.exit(12); } Request request = pendingTxns.remove(); commitProcessor.commit(request); }
ResourceMethod parse(String uri, HttpMethod method, MutableRequest request);  void register(ResourceClass resource);  <T> String urlFor(Class<T> type, Method method, Object... params);  List<Route> allRoutes(); RouteBuilder builderFor(String uri); }
public void shouldBeAbleToConvert() { mockery.checking(new Expectations() { { exactly(1).of(request).getAttribute("javax.servlet.jsp.jstl.fmt.locale.request"); will(returnValue("pt_br")); } }); assertThat(converter.convert("05/06/2010", DateMidnight.class, bundle), is(equalTo(new DateMidnight(2010, 6, 5)))); mockery.assertIsSatisfied(); }
long getWeight(long id); boolean containsQuorum(HashSet<Long> set); }
public void testExceptionDoesNotCrashRun() throws Exception { ScheduleImpl schedule = new ScheduleImpl(250); Counter counter = new Counter(); schedule.add(new ExceptionThrower()); schedule.add(counter); PrintStream err = System.err; System.setErr(new PrintStream(new ByteArrayOutputStream())); schedule.start(); Thread.sleep(50); schedule.stop(); System.setErr(err); assertEquals(1, counter.count); }
public boolean waitForQueues(long timeout, TimeUnit unit) { CountDownLatch blatch = broadcastOp(new BroadcastOpFactory() { @Override public Operation newOp(final MemcachedNode n, final CountDownLatch latch) { return opFact.noop(new OperationCallback() { @Override public void complete() { latch.countDown(); } @Override public void receivedStatus(OperationStatus s) {
public void closeAll() throws Exception { closeChunks(); closeTrailer(); close(); }
boolean hasChildPage(String name); WikiPage getChildPage(String name); void removeChildPage(String name); List<WikiPage> getChildren(); String getName(); PageData getData(); ReadOnlyPageData readOnlyData(); Collection<VersionInfo> getVersions(); WikiPage getVersion(String versionName); String getHtml(); VersionInfo commit(PageData data); PageCrawler getPageCrawler(); WikiPage getHeaderPage(); WikiPage getFooterPage(); }
public boolean update() throws IOException { if (shouldUpdate()) { LOG.info("Unpacking new version of FitNesse resources. Please be patient..."); performAllupdates(); getProperties().put("Version", fitNesseVersion); saveProperties(); return true; } return false; }
public void writeFloat(float f, String tag) throws IOException { out.writeFloat(f); dataSize += 4; }
public int sendResponse(ReplyHeader h, Record r, String tag) throws IOException { return sendResponse(h, r, tag, null, null, -1); }
public void testLE() throws Exception { int count = 30; HashMap<Long,QuorumServer> peers = new HashMap<Long,QuorumServer>(count); ArrayList<LEThread> threads = new ArrayList<LEThread>(count); File tmpdir[] = new File[count]; int port[] = new int[count]; votes = new Vote[count]; for(int i = 0; i < count; i++) { peers.put(Long.valueOf(i), new QuorumServer(i, new InetSocketAddress("127.0.0.1", PortAssignment.unique()))); tmpdir[i] = ClientBase.createTmpDir(); port[i] = PortAssignment.unique(); } LeaderElection le[] = new LeaderElection[count]; leaderDies = true; boolean allowOneBadLeader = leaderDies; for(int i = 0; i < le.length; i++) { QuorumPeer peer = new QuorumPeer(peers, tmpdir[i], tmpdir[i], port[i], 0, i, 2, 2, 2); peer.startLeaderElection(); le[i] = new LeaderElection(peer); LEThread thread = new LEThread(le[i], peer, i); thread.start(); threads.add(thread); } for(int i = 0; i < threads.size(); i++) { threads.get(i).join(15000); if (threads.get(i).isAlive()) { Assert.fail("Threads didn't join"); } } long id = votes[0].id; for(int i = 1; i < votes.length; i++) { if (votes[i] == null) {
void validateSession(ServerCnxn cnxn, long clientId, int timeout) throws IOException, InterruptedException { ByteArrayOutputStream baos = new ByteArrayOutputStream(); DataOutputStream dos = new DataOutputStream(baos); dos.writeLong(clientId); dos.writeInt(timeout); dos.close(); QuorumPacket qp = new QuorumPacket(Leader.REVALIDATE, -1, baos .toByteArray(), null); pendingRevalidations.put(clientId, cnxn); ZooTrace.logTraceMessage(LOG, ZooTrace.SESSION_TRACE_MASK, "To validate session 0x" + Long.toHexString(clientId)); writePacket(qp); }
public void addChildTable(SlimTable slimtable, int row) { slimtable.id = id + "." + children.size(); slimtable.tableName = makeInstructionTag(instructionNumber) + "/" + slimtable.tableName; instructionNumber++; slimtable.parent = this; children.add(slimtable); Table parentTable = getTable(); Table childTable = slimtable.getTable();
Collection<ScenarioTable> getScenarios(); void incrementPassedTestsCount(); void incrementFailedTestsCount(); void incrementErroredTestsCount(); void incrementIgnoredTestsCount(); void increment(ExecutionResult testSummary); void increment(TestSummary testSummary); TestPage getPageToTest(); void setCurrentScriptClass(Class<? extends ScriptTable> currentScriptClass); Class<? extends ScriptTable> getCurrentScriptClass(); void setCurrentScriptActor(String currentScriptActor); String getCurrentScriptActor(); }
public void allTestingComplete(TimeMeasurement totalTimeMeasurement) throws IOException; public void setExecutionLogAndTrackingId(String stopResponderId, CompositeExecutionLog log); public void announceNumberTestsToRun(int testsToRun); public void testSystemStarted(TestSystem testSystem, String testSystemName, String testRunner); public void newTestStarted(WikiTestPage test, TimeMeasurement timeMeasurement) throws IOException; public void testOutputChunk(String output) throws IOException; public void testAssertionVerified(Assertion assertion, TestResult testResult); public void testExceptionOccurred(Assertion assertion, ExceptionResult exceptionResult); public void testComplete(WikiTestPage test, TestSummary testSummary, TimeMeasurement timeMeasurement) throws IOException; public void errorOccured(); }
public void testExecutionReport_Ok() throws Exception { MockCommandRunner mockCommandRunner = new MockCommandRunner(); ExecutionLog executionLog = new ExecutionLog(mockCommandRunner); ExecutionStatus result; if (executionLog.exceptionCount() > 0) result = ExecutionStatus.ERROR; else if (executionLog.hasCapturedOutput()) result = ExecutionStatus.OUTPUT; else result = ExecutionStatus.OK; assertSame(ExecutionStatus.OK, result); }
public void deleteRecursive(final String pathRoot, VoidCallback cb, Object ctx) throws InterruptedException, KeeperException { PathUtils.validatePath(pathRoot); List<String> tree = this.listSubTreeBFS(pathRoot); LOG.debug("Deleting " + tree); LOG.debug("Deleting " + tree.size() + " subnodes "); for (int i = tree.size() - 1; i >= 0 ; --i) {
protected void init(Fixture fixture, Class type) { this.fixture = fixture; this.type = type; }
Result on(Class<? extends Exception> exception);  boolean used();  Map<String, Object> included();  void forwardTo(String uri);  void redirectTo(String uri);  <T> T forwardTo(Class<T> controller);  <T> T redirectTo(Class<T> controller);  <T> T of(Class<T> controller);  <T> T redirectTo(T controller);  <T> T forwardTo(T controller);  <T> T of(T controller);  void nothing();  void notFound();  void permanentlyRedirectTo(String uri);  <T> T permanentlyRedirectTo(Class<T> controller);  <T> T permanentlyRedirectTo(T controller); }
long lastModified(File file); void rename(File file, File originalFile) throws IOException; }
private void parseChunks() throws Exception { StringBuffer bodyBuffer = new StringBuffer(); int chunkSize = readChunkSize(); while (chunkSize != 0) { bodyBuffer.append(input.read(chunkSize)); readCRLF(); chunkSize = readChunkSize(); } body = bodyBuffer.toString();
String genJavaGetSet(String fname, int fIdx) { String getFunc = " public "+mJavaName+" get"+capitalize(fname)+"() {\n"; getFunc += " return "+fname+";\n"; getFunc += " }\n"; String setFunc = " public void set"+capitalize(fname)+"("+mJavaName+" m_) {\n"; setFunc += " " + fname+"=m_;\n"; setFunc += " }\n"; return getFunc+setFunc; }
private void createPageSetUpTearDownGroups(Map<String, LinkedList<TestPage>> pageSetUpTearDownGroups) throws Exception { for (TestPage page : pageList) { makeSetUpTearDownPageGroupForPage(page, pageSetUpTearDownGroups);
protected void notifyListeners(final Future<?> future) { final List<GenericCompletionListener<? extends Future<T>>> copy = new ArrayList<GenericCompletionListener<? extends Future<T>>>(); synchronized(this) { copy.addAll(listeners); listeners = new ArrayList<GenericCompletionListener<? extends Future<T>>>(); } for (GenericCompletionListener<? extends Future<? super T>> listener : copy) {
public <T extends View> T onErrorUse(Class<T> view) { if (!hasErrors()) { return new MockResult(proxifier).use(view);
public void testExecutionLogLinkAppears() throws Exception { String results = runSuite();
public T call() throws Exception { T result = null; HttpSessionMock session = new HttpSessionMock(context, "session" + ++counter); HttpServletRequestMock httpRequest = new HttpServletRequestMock(session, mockery.mock(MutableRequest.class, "request" + counter), mockery); MutableResponse response = mockery.mock(MutableResponse.class, "response" + counter); RequestInfo request = new RequestInfo(context, null, httpRequest, response); VRaptorRequestHolder.setRequestForCurrentThread(request); RequestContextListener contextListener = new RequestContextListener(); contextListener.requestInitialized(new ServletRequestEvent(context, httpRequest)); result = execution.execute(request, counter); contextListener.requestDestroyed(new ServletRequestEvent(context, httpRequest)); VRaptorRequestHolder.resetRequestForCurrentThread(); return result; }
public void testClientReconnect() throws IOException, InterruptedException { HostProvider hostProvider = mock(HostProvider.class); when(hostProvider.size()).thenReturn(1); InetSocketAddress inaddr = new InetSocketAddress("127.0.0.1", 1111); when(hostProvider.next(anyLong())).thenReturn(inaddr); ZooKeeper zk = mock(ZooKeeper.class); when(zk.getClientConfig()).thenReturn(new ZKClientConfig()); sc = SocketChannel.open(); ClientCnxnSocketNIO nioCnxn = new MockCnxn(); ClientCnxn clientCnxn = new ClientCnxn( hostProvider, 5000, zk.getClientConfig(), DummyWatcher.INSTANCE, nioCnxn, false); clientCnxn.start(); countDownLatch.await(5000, TimeUnit.MILLISECONDS); assertTrue(countDownLatch.getCount() == 0); clientCnxn.close(); }
public void testMaxInProcessingDeadWatchers() { MyDeadWatcherListener listener = new MyDeadWatcherListener(); int delayMs = 1000; listener.setDelayMs(delayMs); WatcherCleaner cleaner = new WatcherCleaner(listener, 1, 60, 1, 1); cleaner.start(); listener.setCountDownLatch(new CountDownLatch(2)); long startTime = Time.currentElapsedTime(); cleaner.addDeadWatcher(1); cleaner.addDeadWatcher(2); long time = Time.currentElapsedTime() - startTime; System.out.println("time used " + time); assertTrue(Time.currentElapsedTime() - startTime >= delayMs); assertTrue(listener.wait(5000)); }
private void startupWithServerState(State state) { if (sessionTracker == null) { createSessionTracker(); } startSessionTracker(); setupRequestProcessors(); startRequestThrottler(); registerJMX(); startJvmPauseMonitor(); registerMetrics(); setState(state); requestPathMetricsCollector.start(); localSessionEnabled = sessionTracker.isLocalSessionsEnabled(); notifyAll(); }
public int readUnsignedShort() throws IOException { byte[] b = new byte[2]; readFully(b, 0, 2); return (((b[0] & 0xff) << 8) | (b[1] & 0xff)); }
int getByteCount() throws IOException; InputStream getResultStream() throws IOException; }
public void shouldInstantiateArrayListForListInterface() throws Exception { mockery.checking(new Expectations() { { one(removal).add(new ArrayList()); } }); GenericNullHandler handler = new GenericNullHandler(); List list = handler.instantiate(List.class, container); assertThat(list, is(notNullValue())); assertThat(list, is(instanceOf(ArrayList.class))); }
private LinkedList<String> getPasswordFileLines() throws Exception { LinkedList<String> lines = new LinkedList<String>(); if(passwordFile.exists()) lines = FileUtil.getFileLines(passwordFile); return lines; }
public PwManager openDatabase( InputStream inStream, String password, String keyfile ) throws IOException, InvalidKeyFileException, InvalidPasswordException { return openDatabase(inStream, password, keyfile, new UpdateStatus()); }
public static VRaptorRequest currentRequest() { return vraptorRequests.get(); }
private void ReadXmlStreamed(InputStream readerStream) throws IOException, InvalidDBException { try { ReadDocumentStreamed(CreatePullParser(readerStream));
public void shouldReportMultipleExceptions() throws IOException { CompositeTestSystemListener compositeListener = new CompositeTestSystemListener(); TestSystemListener throwingListener = mock(TestSystemListener.class); TestSystemListener anotherThrowingListener = mock(TestSystemListener.class); TestSystemListener behavingListener = mock(TestSystemListener.class); doThrow(IOException.class).when(throwingListener).testOutputChunk(anyString()); doThrow(IOException.class).when(anotherThrowingListener).testOutputChunk(anyString()); compositeListener.addTestSystemListener(throwingListener); compositeListener.addTestSystemListener(anotherThrowingListener); compositeListener.addTestSystemListener(behavingListener); try { compositeListener.testOutputChunk("Chunk"); fail("An exception should have been raised"); } catch (IOException e) { assertThat(e.getMessage(), is("2 test system listeners threw exceptions")); assertThat(((CompositeIOException) e).getCauses(), hasSize(2)); } verify(throwingListener).testOutputChunk("Chunk"); verify(anotherThrowingListener).testOutputChunk("Chunk"); verify(behavingListener).testOutputChunk("Chunk"); }
String getId(); String getKey(); String getValue(); Object getDocument(); }
public void testMultiToFollower() throws Exception { QuorumUtil qu = new QuorumUtil(1); CountdownWatcher watcher = new CountdownWatcher(); qu.startQuorum(); int index = 1; while(qu.getPeer(index).peer.leader == null) index++; ZooKeeper zk = new ZooKeeper( "127.0.0.1:" + qu.getPeer((index == 1)?2:1).peer.getClientPort(), ClientBase.CONNECTION_TIMEOUT, watcher); watcher.waitForConnected(CONNECTION_TIMEOUT); zk.multi(Arrays.asList( Op.create("/multi0", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi1", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.create("/multi2", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT) )); zk.getData("/multi0", false, null); zk.getData("/multi1", false, null); zk.getData("/multi2", false, null); zk.close(); }
public void testDefaultConnectionFactory() { (new DefaultConnectionFactory()).toString(); (new DefaultConnectionFactory(10, 1000)).toString(); (new DefaultConnectionFactory(100, 100, HashAlgorithm.KETAMA_HASH)).toString();
public void setup() { MockitoAnnotations.initMocks(this); this.restfulie = mock(Restfulie.class); when(restfulie.newRelationBuilder()).thenReturn(builder); Configuration config = mock(Configuration.class); when(config.getApplicationPath()).thenReturn("http://www.caelum.com.br"); xstream = new XStream(); ReflectionConverter base = new ReflectionConverter(xstream.getMapper(), xstream.getReflectionProvider()); xstream.registerConverter(new LinkConverter(base, restfulie, config)); }
private Response doRange(Matcher matcher) { boolean closedLeft = matcher.group(2).equals("="); boolean closedRight = matcher.group(3).equals("="); boolean pass = (arg1 < v && v < arg2) || (closedLeft && arg1 == v) || (closedRight && arg2 == v); return rangeMessage(pass); }
public KeyStore loadKeyStore() throws IOException, GeneralSecurityException { KeyStore ks = KeyStore.getInstance(JKS_KEY_STORE_TYPE); InputStream inputStream = null; try { inputStream = new FileInputStream(new File(keyStorePath));
public void output() throws IOException { outputBytes += 134;
public Symbol childAt(int index) { return getChildren().get(index); }
public static void bindVirtualLinkToPage(WikiPage host, WikiPage proxy) throws Exception { VirtualCouplingPage coupling = new VirtualCouplingPage(host, proxy); ((VirtualCouplingExtension) host.getExtension(VirtualCouplingExtension.NAME)).setVirtualCoupling(coupling); }
public void tableFinished(Parse table) { try { byte[] bytes = readTable(table);
public org.vafer.jdeb.mapping.Mapper createMapper() { if ("prefix".equalsIgnoreCase(mtype)) { return new PrefixMapper(strip, prefix); } else if ("ls".equalsIgnoreCase(mtype)) { try { return new LsMapper(new FileInputStream(src)); } catch (Exception e) { e.printStackTrace(); } } return new NullMapper(); }
public void visitFrame(final int type, final int nLocal, final Object[] local, final int nStack, final Object[] stack) { if (!ClassReader.FRAMES || (compute == FRAMES)) { return; } if (type == Opcodes.F_NEW) { startFrame(code.length, nLocal, nStack);
public void testToStringShouldParseTableWithMultipleRowsAndColumns() throws Exception { assertTable(fitPage); }
ResourceMethod getResourceMethod(MutableRequest request); Resource getResource(); }
private Document getXmlDocument(String documentType) throws Exception { String remotePathName = PathParser.render(remotePath); RequestBuilder builder = new RequestBuilder("/" + remotePathName); builder.addInput("responder", "proxy"); builder.addInput("type", documentType); builder.setHostAndPort(remoteHostname, remotePort); if(remoteUsername != null) builder.addCredentials(remoteUsername, remotePassword); ResponseParser parser = ResponseParser.performHttpRequest(remoteHostname, remotePort, builder); if(parser.getStatus() == 404) throw new Exception("The remote resource, " + remoteUrl() + ", was not found."); if(parser.getStatus() == 401) throw new AuthenticationRequiredException(remoteUrl()); String body = parser.getBody(); Document doc = XmlUtil.newDocument(body); return doc; }
public void notifyStopping(String threadName, int erroCode) { } }); } public void run() { throw new Error(); } @Override protected void handleException(String thName, Throwable e) { runningLatch.countDown(); } }  @Test @Timeout(value = 30) public void testUncaughtException() throws Exception { MyThread t1 = new MyThread("Test-Thread"); t1.start(); assertTrue(runningLatch.await(10000, TimeUnit.MILLISECONDS), "Uncaught exception is not properly handled."); runningLatch = new CountDownLatch(1); MyCriticalThread t2 = new MyCriticalThread("Test-Critical-Thread"); t2.start(); assertTrue(runningLatch.await(10000, TimeUnit.MILLISECONDS), "Uncaught exception is not properly handled."); } }
public synchronized void exceptionOccurred(Exception e) { try { log.addException(e);
public Maybe<String> findVariable(String name) { if (page == null) { return Maybe.noString; } if (!parsed) {
public static void startServerInstance(File dataDir, ServerCnxnFactory factory, String hostPort) throws IOException, InterruptedException { final int port = getPort(hostPort); LOG.info("STARTING server instance 127.0.0.1:{}", port); ZooKeeperServer zks = new ZooKeeperServer(dataDir, dataDir, 3000); factory.startup(zks); Assert.assertTrue("waiting for server up", ClientBase.waitForServerUp( "127.0.0.1:" + port, CONNECTION_TIMEOUT, factory.isSecure()));
long getNumAliveConnections();  long getDataDirSize();  long getLogDirSize();  String getSecureClientPort();  String getSecureClientAddress();  long getTxnLogElapsedSyncTime();  int getJuteMaxBufferSize();  int getLastClientResponseSize();  int getMinClientResponseSize();  int getMaxClientResponseSize(); long getFlushDelay(); void setFlushDelay(long delay); long getMaxWriteQueuePollTime(); void setMaxWriteQueuePollTime(long delay); int getMaxBatchSize(); void setMaxBatchSize(int size); }
HttpResult body(InputStream body); HttpResult body(Reader body);  @Deprecated void movedPermanentlyTo(String url);  @Deprecated <T> T movedPermanentlyTo(Class<T> controller); }
public <T extends Record> T readRequestRecordNoException(Supplier<T> constructor) { try { return readRequestRecord(constructor);
private void writeDocumentHeader() throws IOException { ByteArrayOutputStream output = new ByteArrayOutputStream(); XmlWriter writer = new XmlWriter(output); writer.write(document); writer.close(); String xmlText = output.toString(); int endIndex = xmlText.indexOf("</testResults>"); String head = xmlText.substring(0, endIndex); String tail = xmlText.substring(endIndex); tailBytes = tail.getBytes(); buffer.append(head); }
public void localizedEnsurePasses() throws Exception { assertScriptResults("|localized ensure|func|3|\n", ListUtility.<List<?>>list(
public void setup() { MockitoAnnotations.initMocks(this); this.proxifier = new DefaultProxifier(); this.typeFinder = new NoTypeFinder(); when(router.builderFor(anyString())).thenAnswer(new Answer<DefaultRouteBuilder>() { public DefaultRouteBuilder answer(InvocationOnMock invocation) throws Throwable { return new DefaultRouteBuilder(proxifier, typeFinder, converters, (String) invocation.getArguments()[0]); } }); parser = new ComponentRoutesParser(router); }
public void publish() throws Exception { addTestSystemRun("testSystem1"); addTestSystemRun("testSystem2"); log.publish(context.pageFactory); WikiPage errorLogPage = root.getChildPage(ErrorLogName); assertNotNull(errorLogPage); WikiPage testErrorLog = errorLogPage.getChildPage("TestPage"); assertNotNull(testErrorLog); String content = testErrorLog.getData().getContent(); assertSubString("!3 !-testSystem1", content); assertSubString("!3 !-testSystem2", content); assertSubString("'''Command: '''", content); assertSubString("!-some command-!", content); assertSubString("'''Exit code: '''", content); assertSubString("123", content); assertSubString("'''Date: '''", content); assertSubString("'''Time elapsed: '''", content); assertSubString("Test Page tags", testErrorLog.getData().getAttribute(PageData.PropertySUITES)); }
public void testRoundTrip() throws IOException { MultiResponse response = new MultiResponse(); response.add(new OpResult.CheckResult()); response.add(new OpResult.CreateResult("foo-bar")); response.add(new OpResult.DeleteResult()); Stat s = new Stat(); s.setCzxid(546); response.add(new OpResult.SetDataResult(s)); MultiResponse decodedResponse = codeDecode(response); assertEquals(response, decodedResponse); assertEquals(response.hashCode(), decodedResponse.hashCode()); }
private void addPageXmlToElement(Document document, Element context, WikiPage page) throws Exception { if (pageMeetsConditions(page)) context.appendChild(createXmlFromPage(document, page));
public void run() { try { barrier.await(); rv = callable.call(); } catch (Throwable t) { throwable = t; } latch.countDown(); }
public void onEachFile( InputStream inputStream, String filename, String linkname, String user, int uid, String group, int gid, int mode, long size ) throws IOException { filename = fixPath(filename);
public void close() { if (closed) { return; } closed = true; synchronized (factory.cnxns) { factory.cnxns.remove(this); } if (zk != null) { zk.removeCnxn(this); } ZooLog.logTextTraceMessage("close NIOServerCnxn: " + sock, ZooLog.SESSION_TRACE_MASK); try {  sock.socket().shutdownOutput(); } catch (IOException e) {
public void toString_should_return_string_represents_empy_list_when_list_is_empty() throws Exception { List<String> value = new ArrayList<>(); String current = ListConverterHelper.toString(value); assertEquals("[]", current); }
public void NewParserDefine() { runNewParser("big define", definePageContent); }
public void testMetricsProviderLifecycle() throws Exception { ClientBase.setupTestEnv(); MetricsProviderCapturingLifecycle.reset(); final int CLIENT_PORT = PortAssignment.unique(); final String configs = "metricsProvider.className="+MetricsProviderCapturingLifecycle.class.getName()+"\n"+ "metricsProvider.httpPort=1234\n"; MainThread main = new MainThread(CLIENT_PORT, true, configs); main.start(); Assert.assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT)); clientConnected = new CountDownLatch(1); ZooKeeper zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT, this); Assert.assertTrue("Failed to establish zkclient connection!", clientConnected.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)); zk.create("/foo", "foobar".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); Assert.assertEquals(new String(zk.getData("/foo", null, null)), "foobar"); zk.close(); main.shutdown(); main.join(); main.deleteDirs(); Assert.assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT)); Assert.assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.configureCalled.get()); Assert.assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.startCalled.get()); Assert.assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.getRootContextCalled.get()); Assert.assertTrue("metrics provider lifecycle error", BaseTestMetricsProvider.MetricsProviderCapturingLifecycle.stopCalled.get());
public static void main(String[] args) { if (args.length != 3) { System.err.println( "USAGE: ZKAuditLoggerPerformance connectionString parentPath numberOfRecords"); System.exit(1); } String cxnString = args[0]; CountdownWatcher watcher = new CountdownWatcher(); ZooKeeper zkClient = null; try { zkClient = new ZooKeeper(cxnString, 60000, watcher); watcher.waitForConnected(30000); } catch (InterruptedException | TimeoutException | IOException e) { String msg = "ZooKeeper client can not connect to " + cxnString; logErrorAndExit(e, msg); } String parentPath = args[1]; try { Stat exists = zkClient.exists(parentPath, false); if (exists == null) { System.err.println( "Parent path '" + parentPath + "' must exist."); System.exit(1); } } catch (KeeperException | InterruptedException e1) { String msg = "Error while checking the existence of parent path"; logErrorAndExit(e1, msg); } int recordCount = 0; try { recordCount = Integer.parseInt(args[2]); } catch (NumberFormatException e) { String msg = "Failed to parse '" + args[2] + "' to integer"; LOG.error(msg, e); System.err.println(msg); System.exit(1); } ZKAuditLoggerPerformance auditLoggingPerf = new ZKAuditLoggerPerformance( zkClient, parentPath, recordCount); AuditLogPerfReading doOperations = null; try { doOperations = auditLoggingPerf.doOperations(); } catch (Exception e) { String msg = "Error while doing operations."; LOG.error(msg, e); System.err.println(msg); System.exit(1); } System.out .println("Time taken for " + recordCount + " operations are:"); System.out.println(doOperations.report()); System.exit(0); }
Future<CASValue<Object>> asyncGets(String key); <T> CASValue<T> gets(String key, Transcoder<T> tc); CASValue<Object> gets(String key); <T> T get(String key, Transcoder<T> tc); Object get(String key); <T> BulkFuture<Map<String, T>> asyncGetBulk(Iterator<String> keys, Iterator<Transcoder<T>> tcs); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Iterator<Transcoder<T>> tcs); <T> BulkFuture<Map<String, T>> asyncGetBulk(Iterator<String> keys, Transcoder<T> tc); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); BulkFuture<Map<String, Object>> asyncGetBulk(Iterator<String> keys); BulkFuture<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> BulkFuture<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); BulkFuture<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Iterator<String> keys, Transcoder<T> tc); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc); Map<String, Object> getBulk(Iterator<String> keys); Map<String, Object> getBulk(Collection<String> keys); <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys); Map<String, Object> getBulk(String... keys); <T> Future<Boolean> touch(final String key, final int exp, final Transcoder<T> tc); <T> Future<Boolean> touch(final String key, final int exp); Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, long by); long incr(String key, int by); long decr(String key, long by); long decr(String key, int by); long incr(String key, long by, long def, int exp); long incr(String key, int by, long def, int exp); long decr(String key, long by, long def, int exp); long decr(String key, int by, long def, int exp); Future<Long> asyncIncr(String key, long by); Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, long by); Future<Long> asyncDecr(String key, int by); long incr(String key, long by, long def); long incr(String key, int by, long def); long decr(String key, long by, long def); long decr(String key, int by, long def); Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs);  Set<String> listSaslMechanisms(); }
protected WikiPage findInheritedPage(String pageName) { return sourcePage.getPageCrawler().getClosestInheritedPage(sourcePage, pageName); }
void createSlimService(String args) throws IOException { while (!tryCreateSlimService(args)) try {
protected void beforeContextCreated(File configFile, String rootPath, String fitNesseRoot, int port) throws InitializationError { try { new PluginsClassLoader(rootPath).addPluginsToClassLoader(); } catch (Exception e) { throw new InitializationError(e); } super.beforeContextCreated(configFile, rootPath, fitNesseRoot, port); }
public void testCalculateFileSizeWithPaddingWhenCloseToCurrentSize() { Assert.assertEquals("file should be padded an additional 10 KB", 20 * KB, FileTxnLog.calculateFileSizeWithPadding(7 * KB, 10 * KB, 10 * KB));
private static void serializeTree(int depth, int width, int len) throws InterruptedException, IOException, KeeperException.NodeExistsException, KeeperException.NoNodeException { DataTree tree = new DataTree(); createNodes(tree, "/", depth, width, tree.getNode("/").stat.getCversion(), new byte[len]); int count = tree.getNodeCount(); BinaryOutputArchive oa = BinaryOutputArchive.getArchive(new NullOutputStream()); System.gc(); long start = System.nanoTime(); tree.serialize(oa, "test"); long end = System.nanoTime(); long durationms = (end - start) / 1000000L; long pernodeus = ((end - start) / 1000L) / count; LOG.info( "Serialized {} nodes in {} ms ({}us/node), depth={} width={} datalen={}",
public String rawSubstring(int startAt, int endBefore) { return input.subSequence(startAt, endBefore).toString(); }
public boolean canHandle(String uri, HttpMethod method) { boolean acceptMethod = this.methods.isEmpty() || this.methods.contains(method); boolean uriMatches = parameters.matches(uri); return uriMatches && acceptMethod; }
public Maybe<Symbol> parse(Parser parser) { Scanner scanner = parser.getScanner(); Symbol body = Parser.makeIgnoreFirst(getPage(), scanner, SymbolType.CloseEvaluator).parse(); if (scanner.isEnd()) return Symbol.Nothing; return new Maybe<Symbol>(new Symbol(SymbolType.Evaluator).add(body)); }
public Fixture images() { return new GridFixture(new ImageNameGraphic[][] { { new ImageNameGraphic("images/wall.jpg"),
protected List<SlimAssertion> instructionsForRow(int row) throws TestExecutionException { String firstCell = table.getCellContents(0, row).trim(); List<SlimAssertion> assertions; String match; if (firstCell.equalsIgnoreCase(getStartKeyword())) assertions = startActor(row); else if (firstCell.equalsIgnoreCase(getCheckKeyword())) assertions = checkAction(row); else if (firstCell.equalsIgnoreCase(getCheckNotKeyword())) assertions = checkNotAction(row); else if (firstCell.equalsIgnoreCase(getRejectKeyword())) assertions = reject(row); else if (firstCell.equalsIgnoreCase(getEnsureKeyword())) assertions = ensure(row); else if (firstCell.equalsIgnoreCase(getShowKeyword())) assertions = show(row); else if (firstCell.equalsIgnoreCase(getNoteKeyword())) assertions = note(row); else if ((match = isSymbolAssignment(0, row)) != null) assertions = actionAndAssign(match, row); else if (firstCell.isEmpty()) assertions = note(row); else if (firstCell.trim().startsWith("#") || firstCell.trim().startsWith("*")) assertions = note(row); else {
public void testReadNumberOfBytesAsString() throws Exception { startReading(new ReadCount(100)); StringBuffer buffer = new StringBuffer(); for (int i = 0; i < 100; i++) { buffer.append("*"); writeToPipe("*"); } finishReading(); assertEquals(buffer.toString(), readResult); }
protected T makeSlimTableAndBuildInstructions(String pageContents) throws Exception { tableUnderTest = createSlimTable(pageContents); instructions.addAll(Assertion.getInstructions(tableUnderTest.getAssertions())); return tableUnderTest; }
void updateContent(int row, Result result); @Deprecated void setCell(int col, int row, Result response); @Deprecated void appendContent(int col, int row, Result response); public Table asTemplate(CellContentSubstitution substitution) throws SyntaxError; interface CellContentSubstitution { String substitute(int col, int row, String content) throws SyntaxError; } }
public void incrementPacketsSent() { packetsSent.incrementAndGet(); }
public Response makeResponse(FitNesseContext context, Request request) throws Exception { SimpleResponse response = new SimpleResponse(); String resource = request.getResource(); String version = (String) request.getInput("version"); if (version == null) return new ErrorResponder("missing version").makeResponse(context, request); WikiPagePath path = PathParser.parse(resource); WikiPage page = context.root.getPageCrawler().getPage(context.root, path); if (page == null) return new NotFoundResponder().makeResponse(context, request); PageData data = page.getDataVersion(version); page.commit(data); RecentChanges.updateRecentChanges(data); response.redirect(resource); return response; }
public WikiPage getPage(WikiPage context, WikiPagePath path) throws Exception { if(path == null) return null; if(path.isEmpty()) return context; String firstPathElement = path.getFirst(); WikiPagePath restOfPath = path.getRest(); if(firstPathElement.equals(WikiPagePath.ROOT)) return getPage(getRoot(context), restOfPath); WikiPage childPage = context.getChildPage(firstPathElement); if(childPage != null) return getPage(childPage, restOfPath);
public void addData( File file ) { final Data data = new Data(); data.setSrc(file); dataProducers.add(data); }
public static ASN1Object convertValueToObject( X509Extension ext) throws IllegalArgumentException { try {
void testStarted(TestPage testPage) throws IOException; void testComplete(TestPage testPage, TestSummary testSummary) throws IOException; void testSystemStopped(TestSystem testSystem, ExecutionLog executionLog, Throwable cause ); void testAssertionVerified(Assertion assertion, TestResult testResult); void testExceptionOccurred(Assertion assertion, ExceptionResult exceptionResult); }
public static Database GetDb(Context ctx, String asset, String password, String keyfile, String filename) throws InvalidKeyFileException, IOException, InvalidPasswordException { AssetManager am = ctx.getAssets(); InputStream is = am.open(asset, AssetManager.ACCESS_STREAMING); Database Db = new Database(); Db.LoadData(ctx, is, password, keyfile, ImporterV3.DEBUG); Db.mFilename = filename; return Db;
public void digestFromTxnLogsMatchesTree() throws Exception {
public void fromString_should_return_throw_Exception_when_value_is_not_a_long() { String value = "foo"; String errorMessage = "no error"; try { converter.fromString(value); } catch (SlimError e) { errorMessage = e.getMessage(); } assertEquals("message:<<Can't convert foo to long.>>", errorMessage); }
public void testBadRequest() throws Exception { String output = getSocketOutput("Bad Request \r\n\r\n", new MockWikiPage()); assertSubString("400 Bad Request", output); assertSubString("The request string is malformed and can not be parsed", output); }
public void addingAValidDvd() throws Exception { Dvd dvd = new Dvd(); dvd.setId(2l); willAddTheDvdCopy(dvd); controller.addToMyList(userInfo.getUser(), dvd);
ReadOnlyPageData readOnlyData(); Collection<VersionInfo> getVersions(); WikiPage getVersion(String versionName); String getHtml(); VersionInfo commit(PageData data); PageCrawler getPageCrawler(); WikiPage getHeaderPage(); WikiPage getFooterPage(); }
public void testReadHeader() throws Exception { Context ctx = getContext(); AssetManager am = ctx.getAssets(); InputStream is = am.open("test.kdbx", AssetManager.ACCESS_STREAMING); ImporterV4 importer = new ImporterV4(); PwDatabaseV4 db = importer.openDatabase(is, "12345", ""); assertEquals(6000, db.numKeyEncRounds); assertTrue(db.dataCipher.equals(CipherFactory.AES_CIPHER)); am.close();
public void shouldConvertToZeroWhenNull() { assertThat((Long) converter.convert(null, long.class, errors, bundle), is(equalTo(0L))); }
public boolean hasChildPage(final String pageName) { return subWikiPageFactory.getChildPage(this, pageName) != null; }
public void scanMessages(RangeScanRequest request) { queuer.pushAndMaybeRun(request.topic, new RangeScanOp(request)); }
private String createSearchResultsFooter() throws Exception { VelocityContext velocityContext = new VelocityContext(); StringWriter writer = new StringWriter(); Template template = VelocityFactory.getVelocityEngine().getTemplate( "searchResultsFooter.vm"); velocityContext.put("hits", hits); template.merge(velocityContext, writer); return writer.toString(); }
private HtmlTag buildContentsDiv(WikiPage wikiPage, int currentDepth) throws Exception { HtmlTag div = makeDivTag(currentDepth); div.add(buildList(wikiPage, currentDepth)); return div; }
public void shutdown(){} }, "0", false); } public void testStart() { this.stopped = false; this.workerPool = new WorkerService( "CommitProcWork", 1, true); } public void addToCommittedRequests(Request req) { this.committedRequests.add(req); } public void addToNextPending(Request req) { this.nextPending.set(req); } public void addToQueuedRequests(Request req) {
public void testBadFlags() throws Exception { CachedData cd = tc.encode(9284); assertNull(tc.decode(new CachedData(cd.getFlags() + 1, cd.getData(), CachedData.MAX_SIZE)));
public long getOutstandingRequests();  public int getSessionTimeout();  public void terminateSession();  public void terminateConnection();  long getMinLatency();  long getAvgLatency();  long getMaxLatency();  String getLastOperation();  String getLastCxid();  String getLastZxid();  String getLastResponseTime();  long getLastLatency();  void resetCounters(); }
public boolean isReady() { return controller != null && controller.isReady(); }
private void readPayload() throws IOException, InterruptedException { if (incomingBuffer.remaining() != 0) {
public void defaultView() { String to = resolver.pathFor(requestInfo.getResourceMethod()); logger.debug("forwarding to {}", to); try { request.getRequestDispatcher(to).forward(request.getOriginalRequest(), response.getOriginalResponse());
protected void readRequest() throws IOException { RequestHeader h = new RequestHeader(); ByteBufferInputStream.byteBuffer2Record(incomingBuffer, h); RequestRecord request = RequestRecord.fromBytes(incomingBuffer.slice()); zkServer.processPacket(this, h, request); }
public void testEnterChildPageWhenRemotePageNotModified() throws Exception { importer.enterChildPage(pageOne, Clock.currentDate()); importer.exitPage(); PageData data = pageOne.getData(); data.setContent("new content"); pageOne.commit(data); importer.enterChildPage(pageOne, new Date(0)); assertEquals("new content", pageOne.getData().getContent()); }
public void resetMaxLatency();  public void resetFsyncThresholdExceedCount();  public long getNumAliveConnections();  public long getDataDirSize();  public long getLogDirSize();  public String getSecureClientPort();  public String getSecureClientAddress();  public long getTxnLogElapsedSyncTime();  public int getJuteMaxBufferSize(); }
public void setUp() throws Exception { context = FitNesseUtil.makeTestContext(); request = new MockRequest(); customComparatorRegistry = new CustomComparatorRegistry(); responder = getSlimResponder(customComparatorRegistry); responder.setFastTest(true);
public void testChildPagesStayIntactWhenParentIsRenamed() throws Exception { pageBuilder.addPage(root, pageOnePath, "page one"); pageBuilder.addPage(root, PathParser.parse("PageOne.ChildPage"), "child page"); pageBuilder.addPage(root, PathParser.parse("PageOne.ChildPage.GrandChild"), "grand child"); doRename(pageOneName, pageTwoName, true); WikiPagePath path = PathParser.parse("PageTwo.ChildPage"); PageCrawler crawler = root.getPageCrawler(); assertTrue(crawler.pageExists(path)); WikiPage page = crawler.getPage(path); assertNotNull(page); assertEquals("child page", page.getData().getContent()); WikiPagePath grandChildPath = PathParser.parse("PageTwo.ChildPage.GrandChild"); assertTrue(crawler.pageExists(grandChildPath)); page = crawler.getPage(grandChildPath); assertNotNull(page); assertEquals("grand child", page.getData().getContent()); }
public Response makeResponse(FitNesseContext context, Request request) throws UnsupportedEncodingException { this.context = context; WikiPage root = context.getRootPage(); WikiPage page = root.getPageCrawler().getPage(PathParser.parse(request.getResource())); SuiteFilter filter = SuiteResponder.createSuiteFilter(request, page.getPageCrawler().getFullPath().toString()); SuiteContentsFinder suiteTestFinder = new SuiteContentsFinder(page, filter, root); List<WikiPage> pagelist = suiteTestFinder.getAllPagesToRunForThisSuite(); SuiteOverviewTree treeview = new SuiteOverviewTree(pagelist); treeview.findLatestResults(context.getTestHistoryDirectory()); treeview.countResults(); WikiPagePath path = PathParser.parse(request.getResource()); SimpleResponse response = makeResponse(treeview, path, request); return response;
private void runInternal(boolean displayCmd) throws Exception { String[] argArray = args.toArray(new String[] {}); if (displayCmd) { requester .getLog() .info("cmd : " + mainClassName + "(" + StringUtils.join(argArray, ",") + ")"); } MainHelper.runMain(mainClassName, args, _cl); }
public void testInstallOnly() throws Exception { Arguments args = new Arguments(); args.setInstallOnly(true); FitNesse fitnesse = mock(FitNesse.class); FitNesseMain.update(args, fitnesse); FitNesseMain.launch(args, context, fitnesse); verify(fitnesse, never()).start(); verify(fitnesse, times(1)).applyUpdates(); }
public void allTestingComplete(TimeMeasurement totalTimeMeasurement) throws IOException; public void setExecutionLogAndTrackingId(String stopResponderId, CompositeExecutionLog log); public void announceNumberTestsToRun(int testsToRun); public void testSystemStarted(TestSystem testSystem); public void newTestStarted(WikiTestPage test, TimeMeasurement timeMeasurement) throws IOException; public void testOutputChunk(String output) throws IOException; public void testAssertionVerified(Assertion assertion, TestResult testResult); public void testExceptionOccurred(Assertion assertion, ExceptionResult exceptionResult); public void testComplete(WikiTestPage test, TestSummary testSummary, TimeMeasurement timeMeasurement) throws IOException; public void errorOccured(); }
private void endGroup() throws IllegalArgumentException, IllegalStateException, IOException { xml.endTag(null, ElemGroup); }
private void checkForMethodBinding(String name, boolean expected) throws Throwable { Binding binding = null; try { binding = Binding.create(fixture, name); } catch(NoSuchMethodFitFailureException e) { assertFalse("method not found", expected); return; } assertTrue("method was found", expected); assertTrue(binding instanceof Binding.QueryBinding); assertEquals("intMethod", binding.adapter.method.getName()); }
public Future<String> set(String key, int exp, Object o) { return asyncStore(StoreOperation.StoreType.set, key, exp, o); }
private void generateState() { digestAddCounter(stateCounter++); digestUpdate(state); digestUpdate(seed); digestDoFinal(state); if ((stateCounter % CYCLE_COUNT) == 0) {
public void testReconfigFailWithAuthWithNoACL() throws InterruptedException { resetZKAdmin(); QuorumPeerConfig.setReconfigEnabled(true); try { zkAdmin.addAuthInfo("digest", "user:test".getBytes());
public void getOwner(ByteString topic, boolean shouldClaim, Callback<HedwigSocketAddress> cb, Object ctx);  public void addTopicOwnershipChangeListener(TopicOwnershipChangeListener listener);  public void releaseTopic(ByteString topic, Callback<Void> cb, Object ctx); }
public void start() throws AdminServerException { try { server.start(); } catch (Exception e) {
public void hit(WikiPage page) throws Exception { hits++; String fullPathName = PathParser.render(getPageCrawler().getFullPath(page)); HtmlTag row = new HtmlTag("tr"); row.addAttribute("class", "resultsRow" + getRow()); HtmlTag link = new HtmlTag("a", fullPathName) ; link.addAttribute("href", fullPathName); row.add(new HtmlTag("td", link)); row.add(new HtmlTag("td", "" + page.getData().getProperties().getLastModificationTime())); response.add(row.html()); }
public boolean hasExtension(String extensionName); public Extension getExtension(String extensionName); public String getHelpText() throws Exception; public List<WikiPageAction> getActions() throws Exception; }
public void shouldDeferToContainerIfStaticFile() throws IOException, ServletException { VRaptor raptor = new VRaptor(); final HttpServletRequest request = mockery.mock(HttpServletRequest.class); final HttpServletResponse response = mockery.mock(HttpServletResponse.class); final StaticContentHandler handler = mockery.mock(StaticContentHandler.class); final FilterChain chain = mockery.mock(FilterChain.class); mockery.checking(new Expectations() { { one(handler).requestingStaticFile(request); will(returnValue(true)); one(handler).deferProcessingToContainer(chain, request, response); allowing(request).setCharacterEncoding("UTF-8"); allowing(response).setCharacterEncoding("UTF-8"); } }); raptor.init(new DoNothingProvider(), handler); raptor.doFilter(request, response, chain); mockery.assertIsSatisfied(); }
public void testUpdateServerList_UnResolvedWithResolvedAddress_ForceDisconnect() throws UnknownHostException {
private void insideMap(String tag) { printBeginEnvelope(tag); compoundStack.push("map"); }
public void canConvertGunkBackToHtml() throws Exception { String html_format = "gunk<body>gunk<table%s>gunk<tr>gunk<td>x</td>gunk<br>gunk</tr>gunk</table>gunk</body>"; String html = String.format(html_format, ""); scan(html); String expectedPattern = String.format(html_format, " _TABLENUMBER=\\d+"); assertHasRegexp(expectedPattern,ts.toHtml()); }
public void configureAutoUpdateSetting(WikiPage page) throws Exception { PageData data = page.getData(); WikiPageProperties props = data.getProperties(); WikiImportProperty importProps = WikiImportProperty.createFrom(props); if(importProps != null) configureAutoUpdateSetting(importProps, data, page);
public void testInvalidKey4() throws Exception { try { Object val = client.get("Key\r");
public void traverse(TraversalListener<WikiPage> observer) { WikiPage root = InMemoryPage.makeRoot("root"); PageBuilder pageBuilder = new PageBuilder(); observer.process(pageBuilder.addPage(root, PathParser.parse("PageOne"), "PageOne")); observer.process(pageBuilder.addPage(root, PathParser.parse("PageTwo"), "PageOne")); observer.process(pageBuilder.addPage(root, PathParser.parse("ChildPage"), ".PageOne")); }
public void setExecutionLogAndTrackingId(String stopResponderId, CompositeExecutionLog log) throws Exception { } @Override public void testSystemStarted(TestSystem testSystem, String testSystemName, String testRunner) throws Exception { } @Override public void newTestStarted(WikiPage test, TimeMeasurement timeMeasurement) throws Exception { } @Override public void testOutputChunk(String output) throws Exception { } @Override public void testComplete(WikiPage test, TestSummary testSummary, TimeMeasurement timeMeasurement) throws Exception { } @Override public void writeHead(String pageType) throws Exception { } }
public String getClasspath(WikiPage page) throws Exception { List<String> paths = getInheritedPathElements(page, new HashSet<WikiPage>()); return createClassPathString(paths, getPathSeparator(page)); }
void setConnectionDropIncrease(double val); double getConnectionDropDecrease(); void setConnectionDropDecrease(double val); double getConnectionDecreaseRatio(); void setConnectionDecreaseRatio(double val); int getCommitProcMaxReadBatchSize(); void setCommitProcMaxReadBatchSize(int size); int getCommitProcMaxCommitBatchSize(); void setCommitProcMaxCommitBatchSize(int size); int getRequestThrottleLimit(); void setRequestThrottleLimit(int requests); int getRequestThrottleStallTime(); void setRequestThrottleStallTime(int time); boolean getRequestThrottleDropStale(); void setRequestThrottleDropStale(boolean drop); boolean getRequestStaleLatencyCheck(); void setRequestStaleLatencyCheck(boolean check); boolean getRequestStaleConnectionCheck(); void setRequestStaleConnectionCheck(boolean check); int getLargeRequestMaxBytes(); void setLargeRequestMaxBytes(int bytes); int getLargeRequestThreshold(); void setLargeRequestThreshold(int threshold);  void resetStatistics();  void resetLatency();  void resetMaxLatency();  void resetFsyncThresholdExceedCount();  long getNumAliveConnections();  long getDataDirSize();  long getLogDirSize();  String getSecureClientPort();  String getSecureClientAddress();  long getTxnLogElapsedSyncTime();  int getJuteMaxBufferSize();  int getLastClientResponseSize();  int getMinClientResponseSize();  int getMaxClientResponseSize(); long getFlushDelay(); void setFlushDelay(long delay); long getMaxWriteQueuePollTime(); void setMaxWriteQueuePollTime(long delay); int getMaxBatchSize(); void setMaxBatchSize(int size); }
void shutdown();  void removeSession(long sessionId);  boolean isTrackingSession(long sessionId);  public void checkSession(long sessionId, Object owner) throws KeeperException.SessionExpiredException, KeeperException.SessionMovedException, KeeperException.UnknownSessionException;  public void checkGlobalSession(long sessionId, Object owner) throws KeeperException.SessionExpiredException, KeeperException.SessionMovedException; void setOwner(long id, Object owner) throws SessionExpiredException;  void dumpSessions(PrintWriter pwriter);  Map<Long, Set<Long>> getSessionExpiryMap();  public long getLocalSessionCount(); }
private void addChildFromXml(Element pageElement, WikiPage context, XmlizerPageHandler handler) throws Exception { String name = XmlUtil.getTextValue(pageElement, "name"); String modifiedDateString = XmlUtil.getTextValue(pageElement, "lastModified"); Date modifiedDate = dateFormat.parse(modifiedDateString); WikiPage childPage = context.getChildPage(name); if(childPage == null) childPage = context.addChildPage(name); handler.enterChildPage(childPage, modifiedDate); addChildrenFromXml(pageElement, childPage, handler); handler.exitPage(); }
public void buildFullySpecifiedTestSystemNameForDebugRun() throws Exception { WikiPage testPage = WikiPageUtil.addPage(root, PathParser.parse("TestPage"), "!define TEST_SYSTEM {system}\n" + "!define TEST_RUNNER {runner}\n"); WikiPageDescriptor descriptor = new WikiPageDescriptor(testPage.readOnlyData(), true, false, ""); MockClientBuilder clientBuilder = new MockClientBuilder(descriptor); String testSystemName = clientBuilder.getTestSystemName(); Assert.assertEquals("system:runner", testSystemName); }
BlockingQueue<Operation> createWriteOperationQueue();  NodeLocator createLocator(List<MemcachedNode> nodes);  OperationFactory getOperationFactory();  long getOperationTimeout();  boolean isDaemon(); }
public void setUp() throws Exception { root = InMemoryPage.makeRoot("RooT"); page = root.getPageCrawler().addPage(root, PathParser.parse("PageOne"), "some content"); }
public void shouldRequireGenericTypeInformationToBePresent() { new ComponentFactoryIntrospector().targetTypeForComponentFactory(FactoryWithoutTargetType.class); }
public void testLsrLeafCommand() throws Exception { final ZooKeeper zk = createClient(); ZooKeeperMain zkMain = new ZooKeeperMain(zk); zkMain.executeLine("create /b"); zkMain.executeLine("create /b/c"); LsCommand cmd = new LsCommand(); cmd.setZk(zk); cmd.parse("ls -R /b/c".split(" ")); List<String> expected = new ArrayList<String>(); expected.add("/b/c"); runCommandExpect(cmd, expected); }
private static WikiPagePath makePath(String pathName, WikiPagePath path) { if (pathName.equals("")) { return path;
private String makeHtml(FitNesseContext context) { HtmlPage page = context.pageFactory.newPage(); page.addTitles("Not Found:" + resource); page.put("name", resource); page.put("shouldCreate", PathParser.isWikiPath(resource)); page.setMainTemplate("notFoundPage.vm"); return page.html(); }
public void testClearSign() throws Exception { final InputStream ring = getClass().getClassLoader().getResourceAsStream("org/vafer/gpg/secring.gpg"); assertNotNull(ring); String input = "TEST1\n-TEST2 \n \nTEST3\n"; final String expectedOutputStr = "-----BEGIN PGP SIGNED MESSAGE-----\n" + "Hash: SHA1\n" + "\n" + "TEST1\n" + "- -TEST2\n" + "\n" + "TEST3\n" + "-----BEGIN PGP SIGNATURE-----\n" + "Version: BCPG v1.50\n" + "\n" + "iEYEARECABAFAkax1rgJEHM9pIAuB02PAABIJgCghFmoCJCZ0CGiqgVLGGPd/Yh5\n" + "FQQAnRVqvI2ij45JQSHYJBblZ0Vv2meN\n" + "=aAAT\n" + "-----END PGP SIGNATURE-----\n"; final byte[] expectedOutput = expectedOutputStr.getBytes("UTF-8"); final ByteArrayOutputStream os = new ByteArrayOutputStream(); PGPSigner signer = new PGPSigner(ring, "2E074D8F", "test"); signer.clearSign(input, os); final byte[] output = fixCRLF(os.toByteArray()); final int from = expectedOutputStr.indexOf("iEYEAREC"); final int until = expectedOutputStr.indexOf("=aAAT") + 5; Arrays.fill(output, from, until, (byte) '?'); Arrays.fill(expectedOutput, from, until, (byte) '?'); assertEquals(new String(expectedOutput), new String(output)); }
public void shouldValidateParameters() throws Exception { final ResourceMethod method = mockery.methodFor(Component.class, "otherMethod", int.class); mockery.checking(new Expectations() {{ Object[] values = new Object[]{0}; one(parametersProvider).getParametersFor(method, errors, bundle); will(doAll(addErrorsToList("error1"),returnValue(values))); allowing(session).getAttribute(ParametersInstantiatorInterceptor.FLASH_PARAMETERS); will(returnValue(null)); one(validator).addAll(errors); one(stack).next(method, null); one(params).setParameters(values); }}); instantiator.intercept(stack, method, null); mockery.assertIsSatisfied(); }
public void pageHistoryLinkIsIncluded() throws Exception { responder.turnOffChunking(); doSimpleRun(passFixtureTable()); assertSubString("href=\"TestPage?pageHistory\">", results); assertSubString("Page History", results); }
protected static boolean isPrimitive(Class<?> type) { return type.isPrimitive() || type.isEnum() || Number.class.isAssignableFrom(type) || type.equals(String.class) || Date.class.isAssignableFrom(type) || Calendar.class.isAssignableFrom(type)
private void closeSocket(Socket sock) { try { sock.close();
public boolean walkPostOrder(SymbolTreeWalker walker) { if (walker.visitChildren(this)) { for (Symbol child: children) { if (!child.walkPostOrder(walker)) return false; } } return walker.visit(this); }
protected List<WikiPage> gatherCrossReferencedTestPages() { List<WikiPage> pages = new LinkedList<WikiPage>(); addAllXRefs(pages, pageToRun); return pages; }
public void testChildrenGetMovedIfParentMoves() throws Exception { final String sourceChildOne = "PageOne.PageA.ChildOne"; final String sourceChildTwo = "PageOne.PageA.ChildTwo"; final String sourceGrandChild = "PageOne.PageA.ChildTwo.ChildTwoDotOne"; final String parentToMove = "PageOne.PageA"; final String destinationParent = "PageTwo"; final String destinationPage = "PageTwo.PageA"; final String destinationChildOne = "PageTwo.PageA.ChildOne"; final String destinationChildTwo = "PageTwo.PageA.ChildTwo"; final String destinationGrandChild = "PageTwo.PageA.ChildTwo.ChildTwoDotOne"; WikiPagePath sourceChildOnePath = PathParser.parse(sourceChildOne); WikiPagePath sourceChildTwoPath = PathParser.parse(sourceChildTwo); WikiPagePath sourceGrandChildPath = PathParser.parse(sourceGrandChild); WikiPagePath destinationPagePath = PathParser.parse(destinationPage); WikiPagePath destinationChildOnePath = PathParser.parse(destinationChildOne); WikiPagePath destinationChildTwoPath = PathParser.parse(destinationChildTwo); WikiPagePath destinationGrandChildPath = PathParser.parse(destinationGrandChild); WikiPageUtil.addPage(root, sourceChildOnePath, "child1Content"); WikiPageUtil.addPage(root, sourceChildTwoPath, "child2Content"); WikiPageUtil.addPage(root, sourceGrandChildPath, ""); movePage(parentToMove, destinationParent, true); WikiPage movedPage = crawler.getPage(destinationPagePath); assertFalse(crawler.pageExists(sourceChildOnePath)); assertFalse(crawler.pageExists(sourceChildTwoPath)); List<?> children = movedPage.getChildren(); assertEquals(2, children.size()); assertTrue(crawler.pageExists(destinationChildOnePath)); assertTrue(crawler.pageExists(destinationChildTwoPath)); assertTrue(crawler.pageExists(destinationGrandChildPath)); }
void commit() throws IOException;  long getTxnLogSyncElapsedTime();  void setTotalLogSize(long size);  long getTotalLogSize();  interface TxnIterator extends Closeable {  TxnHeader getHeader();  Record getTxn();  boolean next() throws IOException;  long getStorageSize() throws IOException; } }
public void testLogFormat() throws Exception { String line = l.formatLogLine(ld); assertEquals(logLine, line); }
public boolean isUsable() { return (name != null && name.length() > 0); }
private String[] splitSuitesIntoArray(String suitesInput) { if (suitesInput == null || suitesInput.trim().length() == 0) return new String[0]; return suitesInput.split("\\s*,\\s*"); }
public Fixture imagesForImageFixture() { return new ImageFixture(new String[][] { { "images/wall.jpg",
public void testVersionsExpire() throws Exception { PageVersionPruner.daysTillVersionsExpire = 3; PageData data = page.makePageData(); Set versions = data.getVersions(); for (Iterator iterator = versions.iterator(); iterator.hasNext();) page.removeVersion(iterator.next().toString()); data.getProperties().setLastModificationTime(dateFormat().parse("20031213000000")); page.makeVersion(data); data.getProperties().setLastModificationTime(dateFormat().parse("20031214000000")); page.makeVersion(data); data.getProperties().setLastModificationTime(dateFormat().parse("20031215000000")); page.makeVersion(data); data.getProperties().setLastModificationTime(dateFormat().parse("20031216000000")); page.makeVersion(data); versions = page.makePageData().getVersions(); PageVersionPruner.pruneVersions(page, versions); versions = page.makePageData().getVersions(); assertEquals(3, versions.size()); List versionsList = new LinkedList(versions); Collections.sort(versionsList); assertTrue(versionsList.get(0).toString().endsWith("20031214000000")); assertTrue(versionsList.get(1).toString().endsWith("20031215000000")); assertTrue(versionsList.get(2).toString().endsWith("20031216000000")); }
public List getXrefPages() throws Exception { return getTextOfWidgets(xrefWidgetBuilder); }
public void testExpandedOrCollapsedOrInvisible() throws Exception { CollapsableWidget widget = new CollapsableWidget(new MockWidgetRoot(), "!* title\ncontent\n*!"); assertTrue(widget.expanded); assertFalse(widget.invisible); widget = new CollapsableWidget(new MockWidgetRoot(), "!*> title\ncontent\n*!"); assertFalse(widget.expanded); assertFalse(widget.invisible);
public void shouldIncludeExtractedNameWhenSimplyIncluding() throws Exception { Account account = new Account(); when(extractor.nameFor(Account.class)).thenReturn("account"); result.include(account); verify(request).setAttribute("account", account);
public void shouldIgnoreCollapsedTables() throws Exception { String table1text = "<table><tr><td>has collapsed table</td><td><div class=\"collapse_rim\"> <tr><td>bleh1</td></tr></div></td></tr></table>"; String table2text = "<table><tr><td>has collapsed table</td><td><div class=\"collapse_rim\"> <tr><td>HAHA</td></tr></div></td></tr></table>"; Table table1 = (new HtmlTableScanner(table1text)).getTable(0); Table table2 = (new HtmlTableScanner(table2text)).getTable(0); double score = HistoryComparer.compareTables(table1, table2); assertEquals(1.2,score,.01 ); assertTrue(comparer.theTablesMatch(score)); }
protected void tearDown() throws Exception { LOG.info("tearDown starting"); stopServer(); if (tmpDir != null) {
void testSystemStarted(TestSystem testSystem, String testSystemName, String testRunner); void testOutputChunk(String output) throws IOException; void testComplete(TestSummary testSummary) throws IOException; void exceptionOccurred(Throwable e); void testAssertionVerified(Assertion assertion, TestResult testResult); void testExceptionOccurred(Assertion assertion, ExceptionResult exceptionResult); }
public DERObject toASN1Object() { ASN1EncodableVector v = new ASN1EncodableVector(); v.add(version); v.add(sid); v.add(digAlgorithm); if (authenticatedAttributes != null) { v.add(new DERTaggedObject(false, 0, authenticatedAttributes)); } v.add(digEncryptionAlgorithm); v.add(encryptedDigest); if (unauthenticatedAttributes != null) { v.add(new DERTaggedObject(false, 1, unauthenticatedAttributes)); } return new DERSequence(v); }
Collection<? extends VersionInfo> history(File... files);  VersionInfo makeVersion(FileVersion... fileVersion) throws IOException;  VersionInfo addDirectory(final FileVersion filePath) throws IOException;  void rename(FileVersion fileVersion, File originalFile) throws IOException;  void delete(FileVersion... files); }
public void testTakeWait2() throws Exception{ String dir = "/testTakeWait2"; final String testString = "Hello World"; final int num_clients = 1; final ZooKeeper[] clients = new ZooKeeper[num_clients]; final DistributedQueue[] queueHandles = new DistributedQueue[num_clients]; for(int i=0; i < clients.length; i++){ clients[i] = createClient(); queueHandles[i] = new DistributedQueue(clients[i], dir, null); } int num_attempts =2; for(int i=0; i< num_attempts; i++){ final byte[] takeResult[] = new byte[1][];
BlockingQueue<Operation> createReadOperationQueue();  BlockingQueue<Operation> createWriteOperationQueue();  long getOpQueueMaxBlockTime();  ExecutorService getListenerExecutorService();  boolean isDefaultExecutorService();  NodeLocator createLocator(List<MemcachedNode> nodes);  OperationFactory getOperationFactory();  long getOperationTimeout();  boolean isDaemon();  boolean useNagleAlgorithm();  Collection<ConnectionObserver> getInitialObservers();  FailureMode getFailureMode();  Transcoder<Object> getDefaultTranscoder();  boolean shouldOptimize();  int getReadBufSize();  HashAlgorithm getHashAlg();  long getMaxReconnectDelay();  AuthDescriptor getAuthDescriptor();  int getTimeoutExceptionThreshold();  MetricType enableMetrics();  MetricCollector getMetricCollector();  long getAuthWaitTime(); }
public void functionCallWithOneArgumentAndTrailingName() throws Exception { buildInstructionsFor("|function|arg|trail|\n", false); List<CallInstruction> expectedInstructions = list( new CallInstruction("scriptTable_id_0", "scriptTableActor", "functionTrail", new Object[]{"arg"}) ); assertEquals(expectedInstructions, instructions()); }
public DERObject toASN1Object() { return uri.getDERObject(); }
public static Database GetDb1(Context ctx) throws Exception { return GetDb1(ctx, false); }
public void logRequest(TxnHeader hdr, Record txn, TxnDigest digest) { final Request request = buildRequestToProcess(hdr, txn, digest); syncProcessor.processRequest(request); }
public void testComplete(WikiTestPage test, TestSummary testSummary, TimeMeasurement timeMeasurement) throws IOException {} @Override public void errorOccurred(Throwable cause) {} }
public void testClearSign() throws Exception { final InputStream ring = getClass().getClassLoader().getResourceAsStream("org/vafer/gpg/secring.gpg"); assertNotNull(ring); String input = "TEST1\n-TEST2 \n \nTEST3\n"; final String expectedOutputStr = "-----BEGIN PGP SIGNED MESSAGE-----\n" + "Hash: SHA1\n" + "\n" + "TEST1\n" + "- -TEST2\n" + "\n" + "TEST3\n" + "-----BEGIN PGP SIGNATURE-----\n" + "Version: BCPG v1.58\n" + "\n" + "iEYEARECABAFAkax1rgJEHM9pIAuB02PAABIJgCghFmoCJCZ0CGiqgVLGGPd/Yh5\n" + "FQQAnRVqvI2ij45JQSHYJBblZ0Vv2meN\n" + "=aAAT\n" + "-----END PGP SIGNATURE-----\n"; final byte[] expectedOutput = expectedOutputStr.getBytes("UTF-8"); final ByteArrayOutputStream os = new ByteArrayOutputStream(); PGPSigner signer = new PGPSigner(ring, "2E074D8F", "test", PGPUtil.SHA1); signer.clearSign(input, os); final byte[] output = fixCRLF(os.toByteArray()); final int from = expectedOutputStr.indexOf("iEYEAREC"); final int until = expectedOutputStr.indexOf("=aAAT") + 5; Arrays.fill(output, from, until, (byte) '?'); Arrays.fill(expectedOutput, from, until, (byte) '?'); assertEquals(new String(expectedOutput), new String(output)); }
@Override public void invoke(TestSystemListener listener) throws IOException { listener.testComplete(testPage, testSummary); }
public void translatesWithDayIncrements() { SystemTimeKeeper.instance = new TestTimeKeeper(new GregorianCalendar(2002, 2, 4, 15, 6, 7).getTime()); ParserTestHelper.assertTranslatesTo("!today +5", "09 Mar, 2002"); ParserTestHelper.assertTranslatesTo("!today -5", "27 Feb, 2002"); }
private void startFitNesse() { try { FitNesseMain.main(new String[]{"-p", String.valueOf(fitnessePort), "-d", wikiDirectoryRootPath, "-e", "0", "-o"}); } catch (Exception e) { throw new BuildException("Failed to start FitNesse. Error Msg: " + e.getMessage(), e); } log("Sucessfully Started Fitnesse on port " + fitnessePort); }
void createSlimService(String[] args) throws IOException { while (!tryCreateSlimService(args)) try {
WikiPagePath getFullPath(); String getRelativeName(WikiPage page); WikiPage getRoot(); void traverse(TraversalListener<? super WikiPage> callback); void traversePageAndAncestors(TraversalListener<? super WikiPage> callback); void traverseUncles(String uncleName, TraversalListener<? super WikiPage> callback); WikiPage getSiblingPage(WikiPagePath pathRelativeToSibling); WikiPage findAncestorWithName(String name); WikiPage getClosestInheritedPage(String pageName); }
public void remove() { throw new UnsupportedOperationException(); }
protected void evaluateResults(Map<String, Object> pseudoResults, String expectedTable) { SlimAssertion.evaluateExpectations(assertions, pseudoResults); org.junit.Assert.assertEquals(expectedTable, qt.getTable().toString()); }
public void scanSingleMessage(ScanRequest request) {
public abstract void addOption(String key, String value);  public abstract void addOption(String key, File value);  public abstract void addOption(String key, boolean value);
private Artifact fallbackJLine(final VersionNumber scalaVersion) {
public void simpleDecisionTable() throws Exception { getResultsForTable( "|DT:fitnesse.slim.test.TestSlim|\n" + "|returnInt?|\n" + "|7|\n" ); assertTestResultsContain("!style_pass(7)"); }
public void visitMethodInsn(final int opcode, final String owner, final String name, final String desc) { instructions.add(new MethodInsnNode(opcode, owner, name, desc)); }
protected void onActivityResult(int requestCode, int resultCode, Intent data) { if (resultCode == RESULT_OK) { String generatedPassword = data.getStringExtra("com.keepassdroid.password.generated_password");
protected void closeSlimService() throws InterruptedException { SlimService.waitForServiceToStopAsync(); assertFalse(SlimService.service.isAlive()); }
private byte[] serialize(Object o) { assert o != null; byte[] rv=null; try { ByteArrayOutputStream bos=new ByteArrayOutputStream(); ObjectOutputStream os=new ObjectOutputStream(bos); os.writeObject(o); os.close(); bos.close(); rv=bos.toByteArray(); } catch(IOException e) { getLogger().warn("Caught IOException encoding %s", o, e); } return rv; }
private void testSuiteMetaTestSummaryWithoutTestResults(String pageName) throws Exception { formatter.processTestResults(pageName, new TestSummary(0, 0, 0, 0)); formatter.finishWritingOutput(); assertSubString("<span class=\\\"results pass\\\">0 right, 0 wrong, 0 ignored, 0 exceptions</span>", pageBuffer.toString()); assertSubString("<strong>Test Pages:</strong> 0 right, 0 wrong, 1 ignored, 0 exceptions", pageBuffer.toString()); assertSubString("<strong>Assertions:</strong> 0 right, 0 wrong, 0 ignored, 0 exceptions", pageBuffer.toString()); }
public String getSecureClientPort();  public String getSecureClientAddress();  public long getTxnLogElapsedSyncTime();  public int getJuteMaxBufferSize();  public int getLastClientResponseSize();  public int getMinClientResponseSize();  public int getMaxClientResponseSize(); }
boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs);  void authenticate(String mechs[], CallbackHandler cbh) throws OperationException;  Set<String> listSaslMechanisms(); }
public final Operation removeCurrentWriteOp() { Operation rv=optimizedOp; if(rv == null) { rv=writeQ.remove(); } else { optimizedOp=null; } return rv; }
public void readyToSend(ResponseSender sender) throws Exception { try { addStandardHeaders();
public void hashWithNullsDoesNotThrow() throws Exception { a.setLinkName(null); a.setPageName(null); a.setQuery(null); a.setShortcutKey(null); a.setNewWindow(!aa.isNewWindow()); a.hashCode(); }
public void handleLine(String line) { if (line.equals("END")) { cb.receivedStatus(END);
public String encrypt(String value) { byte[] crypted = repeatEncryption(theMagicLock.getBytes(), value.getBytes()); byte[] squeezed = fillToSize(crypted,15); byte[] encoded = Base64.encode(squeezed); return new String(encoded); }
private final int jjMoveStringLiteralDfa3_0(long old0, long active0) { if (((active0 &= old0)) == 0L) return jjStartNfa_0(1, old0); try { curChar = input_stream.readChar(); } catch(java.io.IOException e) { jjStopStringLiteralDfa_0(2, active0); return 3; } switch(curChar) { case 97: return jjMoveStringLiteralDfa4_0(active0, 0x40000L); case 98: return jjMoveStringLiteralDfa4_0(active0, 0x80000L); case 101: if ((active0 & 0x4000L) != 0L) return jjStartNfaWithStates_0(3, 14, 4); break; case 102: return jjMoveStringLiteralDfa4_0(active0, 0x200000L); case 103: if ((active0 & 0x20000L) != 0L) return jjStartNfaWithStates_0(3, 17, 4); break; case 108: return jjMoveStringLiteralDfa4_0(active0, 0xa000L); case 114: return jjMoveStringLiteralDfa4_0(active0, 0x100000L); case 115: return jjMoveStringLiteralDfa4_0(active0, 0x1000L); case 116: return jjMoveStringLiteralDfa4_0(active0, 0x400000L); case 117: return jjMoveStringLiteralDfa4_0(active0, 0x800L); default : break; } return jjStartNfa_0(2, active0); }
private void checkNotAction(int row) { int lastColInAction = table.getColumnCountInRow(row) - 1; String expected = table.getCellContents(lastColInAction, row); addExpectation(new RejectedValueExpectation(getInstructionTag(), lastColInAction, row)); invokeAction(1, lastColInAction - 1, row); }
void fillWriteBuffer(boolean optimizeGets);  void transitionWriteItem();  Operation getCurrentReadOp();  Operation removeCurrentReadOp();  Operation getCurrentWriteOp();  Operation removeCurrentWriteOp();  boolean hasReadOp();  boolean hasWriteOp();  void addOp(Operation op);  int getSelectionOps();  ByteBuffer getRbuf();  ByteBuffer getWbuf();  SocketAddress getSocketAddress();  boolean isActive();  void reconnecting();  void connected();  int getReconnectCount();  void registerChannel(SocketChannel ch, SelectionKey selectionKey);  void setChannel(SocketChannel to);  SocketChannel getChannel();  void setSk(SelectionKey to);  SelectionKey getSk();  int getBytesRemainingToWrite();  int writeSome() throws IOException;  void fixupOps(); }
public void encodeMessageToSend() throws IOException { ByteArrayOutputStream writer = new ByteArrayOutputStream(); SlimStreamReader.sendSlimMessage(writer, "foo bar baz"); assertEquals("000011:foo bar baz", writer.toString()); }
public Operation removeCurrentWriteOp() { throw new UnsupportedOperationException(); }
public void shouldBeAbleToDeserializeADogWithDeserializerAdapter() throws Exception { List<JsonDeserializer<?>> deserializers = new ArrayList<JsonDeserializer<?>>(); deserializers.add(new DogDeserializer()); deserializer = new GsonDeserialization(provider, deserializers); InputStream stream = new ByteArrayInputStream("{'dog':{'name':'Renan Reis','age':'0'}}".getBytes()); when(provider.parameterNamesFor(bark.getMethod())).thenReturn(new String[] { "dog" }); when(provider.parameterNamesFor(bark.getMethod())).thenReturn(new String[] { "dog" }); Object[] deserialized = deserializer.deserialize(stream, bark); assertThat(deserialized.length, is(1)); assertThat(deserialized[0], is(instanceOf(Dog.class))); Dog dog = (Dog) deserialized[0]; assertThat(dog.name, is("Renan")); assertThat(dog.age, is(25)); }
private void initializeBundle() { Object bundle = findByKey(Config.FMT_LOCALIZATION_CONTEXT); ResourceBundle unsafe = extractUnsafeBundle(bundle); this.bundle = new SafeResourceBundle(unsafe); }
protected List<Character> stringToCharacterList(final String s) { if (s == null || s.isEmpty()) { return Collections.<Character> emptyList(); } List<Character> characterList = new ArrayList<>(s.length()); for (char c : s.toCharArray()) { characterList.add(c); } return characterList; }
void pageImported(WikiPage localPage) throws Exception; void pageImportError(WikiPage localPage, Exception e) throws Exception; }
private HtmlPage makeHtml() { PageCrawler pageCrawler = page.getPageCrawler(); WikiPagePath fullPath = pageCrawler.getFullPath(page); String fullPathName = PathParser.render(fullPath); HtmlPage htmlPage = context.pageFactory.newPage(); htmlPage.setTitle(getTitle() + ": " + fullPathName); htmlPage.setPageTitle(new PageTitle(getTitle(), fullPath, data.getAttribute(PageData.PropertySUITES))); htmlPage.setNavTemplate("testNav.vm"); htmlPage.put("actions", new WikiPageActions(page)); htmlPage.setMainTemplate(mainTemplate()); htmlPage.put("testExecutor", new TestExecutor()); htmlPage.setFooterTemplate("wikiFooter.vm"); htmlPage.put("footerContent", new WikiPageFooterRenderer()); htmlPage.setErrorNavTemplate("errorNavigator"); htmlPage.put("errorNavOnDocumentReady", false); WikiImportProperty.handleImportProperties(htmlPage, page); return htmlPage; }
private HtmlTag makeTitle() { HtmlTag title = new HtmlTag("title"); title.add("FitNesse"); return title; }
public String getClasspath(WikiPage page) throws Exception { List paths = getInheritedPathElements(page, new HashSet(89)); String classPathString = createClassPathString(paths, getPathSeparator(page)); return classPathString; }
<T> Future<CASResponse> asyncCAS(String key, long casId, T value, Transcoder<T> tc); Future<CASResponse> asyncCAS(String key, long casId, Object value); Future<CASResponse> asyncCAS(String key, long casId, int exp, Object value); <T> OperationFuture<CASResponse> asyncCAS(String key, long casId, int exp, T value, Transcoder<T> tc); <T> CASResponse cas(String key, long casId, int exp, T value, Transcoder<T> tc); CASResponse cas(String key, long casId, Object value); CASResponse cas(String key, long casId, int exp, Object value); <T> CASResponse cas(String key, long casId, T value, Transcoder<T> tc); <T> Future<Boolean> add(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> add(String key, int exp, Object o); <T> Future<Boolean> set(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> set(String key, int exp, Object o); <T> Future<Boolean> replace(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> replace(String key, int exp, Object o); <T> Future<T> asyncGet(String key, Transcoder<T> tc); Future<Object> asyncGet(String key); Future<CASValue<Object>> asyncGetAndTouch(final String key, final int exp); <T> Future<CASValue<T>> asyncGetAndTouch(final String key, final int exp, final Transcoder<T> tc); CASValue<Object> getAndTouch(String key, int exp); <T> CASValue<T> getAndTouch(String key, int exp, Transcoder<T> tc); <T> Future<CASValue<T>> asyncGets(String key, Transcoder<T> tc); Future<CASValue<Object>> asyncGets(String key); <T> CASValue<T> gets(String key, Transcoder<T> tc); CASValue<Object> gets(String key); <T> T get(String key, Transcoder<T> tc); Object get(String key); <T> BulkFuture<Map<String, T>> asyncGetBulk(Iterator<String> keys, Iterator<Transcoder<T>> tcs); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Iterator<Transcoder<T>> tcs); <T> BulkFuture<Map<String, T>> asyncGetBulk(Iterator<String> keys, Transcoder<T> tc); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); BulkFuture<Map<String, Object>> asyncGetBulk(Iterator<String> keys); BulkFuture<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> BulkFuture<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); BulkFuture<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Iterator<String> keys, Transcoder<T> tc); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc); Map<String, Object> getBulk(Iterator<String> keys); Map<String, Object> getBulk(Collection<String> keys); <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys); Map<String, Object> getBulk(String... keys); <T> Future<Boolean> touch(final String key, final int exp, final Transcoder<T> tc); <T> Future<Boolean> touch(final String key, final int exp); Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, long by); long incr(String key, int by); long decr(String key, long by); long decr(String key, int by); long incr(String key, long by, long def, int exp); long incr(String key, int by, long def, int exp); long decr(String key, long by, long def, int exp); long decr(String key, int by, long def, int exp); Future<Long> asyncIncr(String key, long by); Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, long by); Future<Long> asyncDecr(String key, int by); long incr(String key, long by, long def); long incr(String key, int by, long def); long decr(String key, long by, long def); long decr(String key, int by, long def); Future<Boolean> delete(String key); Future<Boolean> delete(String key, long cas); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs); CountDownLatch broadcastOp(final BroadcastOpFactory of); CountDownLatch broadcastOp(final BroadcastOpFactory of, Collection<MemcachedNode> nodes);  Set<String> listSaslMechanisms(); }
private StringBuffer makeColumnFixtureTemplate(String defaultTableTemplate, Class fixtureClass) { return makeFixtureTemplate(defaultTableTemplate, fixtureClass, ColumnFixture.class); }
public void replaceSymbolsShouldReplaceSameSymbolMoreThanOnce() throws Exception { SlimTable table = new MockTable(); table.setSymbol("x", "a"); assertEquals("this is a and a again", table.replaceSymbols("this is $x and $x again")); }
private void makeSetUpTearDownPageGroupForPage(WikiPage page, Map<String, List<WikiPage>> pageSetUpTearDownGroups) { String group = getSetUpTearDownGroup(page); pageSetUpTearDownGroups.computeIfAbsent(group, g -> new LinkedList<>()).add(page); }
protected String createHtmlResults(SlimTable startWithTable, SlimTable stopBeforeTable) { evaluateTables(); String exceptionsString = exceptions.toHtml(); Table start = (startWithTable != null) ? startWithTable.getTable() : null; Table end = (stopBeforeTable != null) ? stopBeforeTable.getTable() : null; String testResultHtml = tableScanner.toHtml(start, end); return exceptionsString + testResultHtml; }
private void verifyCreateFails(String path, ZooKeeper zk) throws Exception { try { zk.create(path, null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); } catch (IllegalArgumentException e) {
<T> Map<String, T> getBulk(Transcoder<T> tc, String... keys) throws OperationTimeoutException; Map<String, Object> getBulk(String... keys) throws OperationTimeoutException; Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, int by) throws OperationTimeoutException; long decr(String key, int by) throws OperationTimeoutException; Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, int by); long incr(String key, int by, long def) throws OperationTimeoutException; long decr(String key, int by, long def) throws OperationTimeoutException; Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); }
public void testHasSubpageCallsLoadChildrenNoMoreThanNeeded() throws Exception { proxy.getNormalChildren(); ProxyPage.retrievalCount = 0; proxy.hasChildPage("ChildTwo"); assertEquals(0, ProxyPage.retrievalCount); proxy.hasChildPage("SomeMissingChild"); assertEquals(1, ProxyPage.retrievalCount); }
public void simpleInputAndOutputPassing() throws Exception { makeTables( "!|scenario|echo|input|giving|output|\n" + "|check|echo|@input|@output|\n" + "\n" + "!|script|\n" + "|echo|7|giving|7|\n" ); Map<String, Object> pseudoResults = SlimCommandRunningClient.resultToMap( list( list("scriptTable_id_0/scriptTable_s_id_0", "7") ) ); SlimAssertion.evaluateExpectations(assertions, pseudoResults); String scriptTable = script.getChildren().get(0).getTable().toString(); String expectedScript = "[[scenario, echo, input, giving, output], [check, echo, 7, pass(7)]]"; assertEquals(expectedScript, scriptTable); String dtHtml = script.getTable().toString(); assertEquals(1, getTestSummary().getRight()); assertEquals(0, getTestSummary().getWrong()); assertEquals(0, getTestSummary().getIgnores()); assertEquals(0, getTestSummary().getExceptions()); }
public abstract void setNumRonuds(long rounds) throws NumberFormatException; }
public void testStarted(WikiTestPage test) { String pageName = PathParser.render(test.getSourcePage().getPageCrawler().getFullPath()); timeMeasurement = new TimeMeasurement().start(); referenceToCurrentTest = new SuiteExecutionReport.PageHistoryReference(pageName, timeMeasurement.startedAt()); }
void substitute(int col, int row, String content); int addRow(List<String> list); void addColumnToRow(int row, String content); void appendChildTable(int row, Table table); void updateContent(int row, TestResult testResult); void updateContent(int col, int row, SlimTestResult testResult); void updateContent(int col, int row, SlimExceptionResult exceptionResult); Table asTemplate(CellContentSubstitution substitution) throws SyntaxError;
private String trimDoubleDollars(String s) { if (s != null) { int doubleDollarIndex = 0; while ((doubleDollarIndex = s.indexOf("$$")) != -1) { s = s.substring(0, doubleDollarIndex) + s.substring(doubleDollarIndex + 1); } } return s; }
private void sendResponse(Response response) throws IOException { response.sendTo(this); }
public void tableWithException() throws Exception { getResultsForPageContents( "|DT:NoSuchClass|\n" + "|returnInt?|\n" + "|7|\n" ); assertTestResultsContain("!<DT:NoSuchClass>! !style_error(Could not invoke constructor for NoSuchClass[0])"); }
public void visitLocalVariable(final String name, final String desc, final String signature, final Label start, final Label end, final int index) { mv.visitLocalVariable(name, desc, signature, start, end, index); }
private void addShade(HtmlTag row) { if (shade++ % 2 == 0) row.addAttribute("style", "background-color: #EFEFEF;");
private void literalizeTable() { if (isLiteralTable) { table.setAsNotLiteralTable();
private void assertExceptionReturned(String returnTag) { Map<String, Object> results = SlimClient.resultToMap(executor.execute(statements)); String result = (String) results.get(returnTag); assertTrue(result.indexOf(SlimServer.EXCEPTION_TAG) != -1); }
public static void deserializeSnapshot(DataTree dt, InputArchive ia, Map<Long, Integer> sessions) throws IOException { int count = ia.readInt("count"); while (count > 0) { long id = ia.readLong("id"); int to = ia.readInt("timeout"); sessions.put(id, to); if (LOG.isTraceEnabled()) { ZooTrace.logTraceMessage( LOG, ZooTrace.SESSION_TRACE_MASK, "loadData --- session in archive: " + id + " with timeout: " + to); } count--; } dt.deserialize(ia, "tree"); }
public static Symbol parse(WikiPage page) { return Parser.make(new ParsingPage(new WikiSourcePage(page)), page.getData().getContent()).parse(); }
public void setup() throws Exception { Security.addProvider(new BouncyCastleProvider()); x509TestContext1 = X509TestContext.newBuilder() .setTempDir(dir1) .setKeyStoreKeyType(X509KeyType.EC) .setTrustStoreKeyType(X509KeyType.EC) .build(); x509TestContext2 = X509TestContext.newBuilder() .setTempDir(dir2) .setKeyStoreKeyType(X509KeyType.EC) .setTrustStoreKeyType(X509KeyType.EC) .build(); keyStoreFile1 = x509TestContext1.getKeyStoreFile(KeyStoreFileType.PEM); trustStoreFile1 = x509TestContext1.getTrustStoreFile(KeyStoreFileType.PEM); keyStoreFile2 = x509TestContext2.getKeyStoreFile(KeyStoreFileType.PEM); trustStoreFile2 = x509TestContext2.getTrustStoreFile(KeyStoreFileType.PEM); String testDataPath = System.getProperty("test.data.dir", "src/test/resources/data"); }
public void doCommit(PageData data) throws Exception { data.getProperties().setLastModificationTime(new Date()); saveContent(data.getContent()); saveAttributes(data.getProperties());
public void shouldThrowExceptionInNoUpdateFileExists() throws Exception { FileUtil.deleteFile(updateList); updater.parseResource(GradleSupport.TEST_CLASSES_DIR + "/Resources/updateList"); }
private static void usage() { System.out.println( "\nUsage: java -jar yuicompressor-x.y.z.jar [options] [input file]\n\n"
Future<Boolean> set(String key, int exp, Object o); <T> Future<Boolean> replace(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> replace(String key, int exp, Object o); <T> Future<T> asyncGet(String key, Transcoder<T> tc); Future<Object> asyncGet(String key); Future<CASValue<Object>> asyncGetAndTouch(final String key, final int exp); <T> Future<CASValue<T>> asyncGetAndTouch(final String key, final int exp, final Transcoder<T> tc); CASValue<Object> getAndTouch(String key, int exp); <T> CASValue<T> getAndTouch(String key, int exp, Transcoder<T> tc); <T> Future<CASValue<T>> asyncGets(String key, Transcoder<T> tc); Future<CASValue<Object>> asyncGets(String key); <T> CASValue<T> gets(String key, Transcoder<T> tc); CASValue<Object> gets(String key); <T> T get(String key, Transcoder<T> tc); Object get(String key); <T> BulkFuture<Map<String, T>> asyncGetBulk(Iterator<String> keys, Iterator<Transcoder<T>> tcs); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Iterator<Transcoder<T>> tcs); <T> BulkFuture<Map<String, T>> asyncGetBulk(Iterator<String> keys, Transcoder<T> tc); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); BulkFuture<Map<String, Object>> asyncGetBulk(Iterator<String> keys); BulkFuture<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> BulkFuture<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); BulkFuture<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Iterator<String> keys, Transcoder<T> tc); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc); Map<String, Object> getBulk(Iterator<String> keys); Map<String, Object> getBulk(Collection<String> keys); <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys); Map<String, Object> getBulk(String... keys); <T> Future<Boolean> touch(final String key, final int exp, final Transcoder<T> tc); <T> Future<Boolean> touch(final String key, final int exp); Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, long by); long incr(String key, int by); long decr(String key, long by); long decr(String key, int by); long incr(String key, long by, long def, int exp); long incr(String key, int by, long def, int exp); long decr(String key, long by, long def, int exp); long decr(String key, int by, long def, int exp); Future<Long> asyncIncr(String key, long by); Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, long by); Future<Long> asyncDecr(String key, int by); long incr(String key, long by, long def); long incr(String key, int by, long def); long decr(String key, long by, long def); long decr(String key, int by, long def); Future<Boolean> delete(String key); Future<Boolean> delete(String key, long cas); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs); CountDownLatch broadcastOp(final BroadcastOpFactory of); CountDownLatch broadcastOp(final BroadcastOpFactory of, Collection<MemcachedNode> nodes);  Set<String> listSaslMechanisms(); }
public void testSpacesInFileName() throws Exception { request.setResource("files/test%20File%20With%20Spaces%20In%20Name"); responder = new FileResponder(); responder.makeResponse(context, request); assertEquals(context.getRootPagePath() + File.separator + "files" + File.separator + "test File With Spaces In Name", responder.requestedFile.getPath()); }
protected String buildCommand(TestSystem.Descriptor descriptor, String classPath) throws Exception { ; String commandPattern = descriptor.commandPattern; String command = replace(commandPattern, "%p", classPath); command = replace(command, "%m", descriptor.testRunner); return command; }
public void tearDown() throws Exception { super.tearDown(); c.destroy(); zk.close(); ZooKeeperService.close(BASEURI); threadSelector.stopEndpoint(); }
public void findsInheritedMethodsWithDefaultNames() throws SecurityException, NoSuchMethodException { this.resource = mockery.resource(NiceClients.class); ResourceMethod method = router.parse("/NiceClients/toInherit", HttpMethod.POST, request); assertThat(method, is(VRaptorMatchers.resourceMethod(Clients.class.getMethod("toInherit")))); mockery.assertIsSatisfied(); }
public void acceptResults(TestSystem.TestSummary testSummary) throws Exception { assertionCounts.tally(testSummary); }
public void register(Class<? extends ComponentFactory> componentFactoryClass) { Class<?> targetType = componentFactoryIntrospector.targetTypeForComponentFactory(componentFactoryClass); if (componentFactoryClass.isAnnotationPresent(ApplicationScoped.class)) { if (logger.isDebugEnabled()) {
public void routes() { routeFor("/clients/add").with(HttpMethod.GET).is(MyControl.class).add(null); }
public void testFailOnMissingSrcIgnoreFileMissing() throws IOException { data.setSrc(missingFile); data.setMissingSrc("ignore"); data.produce(null, console); assertEquals(0, console.warn.size()); }
private void makeHeadingRow(HtmlTableListingBuilder table, Set<String> attributesNames) throws Exception { List<HtmlTag> tags = new ArrayList<HtmlTag>(); tags.add(new HtmlTag("strong", "Test")); tags.add(new HtmlTag("strong", "Page")); for (String attributeName : attributesNames) { tags.add(new HtmlTag("strong", attributeName)); } tags.add(new HtmlTag("strong", PropertiesResponder.SUITES)); addTagsToTableRow(table, tags); }
public void ifNull(final Label label) { mv.visitJumpInsn(Opcodes.IFNULL, label); }
public void write(String output) { executionLogListener.stdErr(output); }
public Map<String, Class<? extends Responder>> getResponders() throws PluginException { Map<String, Class<? extends Responder>> responders = super.getResponders(); addEachNamedClass(ConfigurationParameter.RESPONDERS, responders); return responders; }
private Response saveEdits(FitNesseContext context, Request request, WikiPage page) { Response response = new SimpleResponse(); setData(); VersionInfo commitRecord = page.commit(data); response.addHeader("Current-Version", commitRecord.getName()); context.recentChanges.updateRecentChanges(data); if (request.hasInput("redirect")) response.redirect(request.getInput("redirect").toString()); else response.redirect(request.getResource()); return response; }
public String makeHtml(FitNesseContext context) throws Exception { WikiPage page = pageData.getWikiPage(); HtmlPage html = context.htmlPageFactory.newPage(); WikiPagePath fullPath = page.getPageCrawler().getFullPath(page); String fullPathName = PathParser.render(fullPath); html.title.use(fullPathName); html.header.use(HtmlUtil.makeBreadCrumbsWithCurrentPageNotLinked(fullPathName)); html.actions.use(HtmlUtil.makeActions(pageData)); html.main.use(HtmlUtil.addHeaderAndFooter(page, HtmlUtil.testableHtml(pageData))); WikiImportProperty importProperty = WikiImportProperty.createFrom(pageData.getProperties()); if(importProperty != null && !importProperty.isRoot()) html.body.addAttribute("class", "imported"); else if(page instanceof ProxyPage) html.body.addAttribute("class", "virtual"); return html.html(); }
public void shouldResolveSessionScopedAnnotationToSessionScope() { ScopeMetadata scopeMetadata = readScopeMetadata(SessionScopedComponent.class); Assert.assertEquals(ScopedProxyMode.NO, scopeMetadata.getScopedProxyMode()); Assert.assertEquals(WebApplicationContext.SCOPE_SESSION, scopeMetadata.getScopeName()); }
public void onEachLink(TarArchiveEntry entry) throws IOException {
public void start(ServletContext context) { container = new GuiceContainer(); injector = Guice.createInjector(new VRaptorAbstractModule(REQUEST, SESSION, context, container)); }
boolean commitSession(long id, int to);  boolean touchSession(long sessionId, int sessionTimeout);  void setSessionClosing(long sessionId);  void shutdown();  void removeSession(long sessionId);  boolean isTrackingSession(long sessionId);  void checkSession(long sessionId, Object owner) throws KeeperException.SessionExpiredException, KeeperException.SessionMovedException, KeeperException.UnknownSessionException;  void checkGlobalSession(long sessionId, Object owner) throws KeeperException.SessionExpiredException, KeeperException.SessionMovedException; void setOwner(long id, Object owner) throws SessionExpiredException;  void dumpSessions(PrintWriter pwriter);  Map<Long, Set<Long>> getSessionExpiryMap();  long getLocalSessionCount(); boolean isLocalSessionsEnabled();  Set<Long> globalSessions();  Set<Long> localSessions(); }
public void write(Document doc) throws Exception { write("<?xml version=\"1.0\"?>"); write(endl); write(doc.getDocumentElement(), 0); }
public void shouldExecuteTestPagesGroupedByTestSystem() throws TestExecutionException { WikiPage testPage1 = addTestPage(suite, "TestPage1", "!define TEST_SYSTEM {A}"); WikiPage testPage2 = addTestPage(suite, "TestPage2", "!define TEST_SYSTEM {B}"); MultipleTestsRunner runner = new MultipleTestsRunner(createRun(testPage1, testPage2), testSystemFactory); runner.executeTestPages(); verify(testSystemFactory).create(forTestSystem("B")); verify(testSystemFactory).create(forTestSystem("A")); }
private void filter() { filteredEntries = new Vector<PwEntryV3>(); for (int i = 0; i < mGroup.childEntries.size(); i++) { PwEntryV3 entry = (PwEntryV3) mGroup.childEntries.elementAt(i);
public void shouldBeAbleToConvertByName() { assertThat(converter.convert("FIRST", MyCustomEnum.class, bundle), is(equalTo(MyCustomEnum.FIRST)));
public static Arguments parseCommandLine(String[] args) { CommandLine commandLine = new CommandLine( "[-v][-p port][-d dir][-r root][-l logDir][-f config][-e days][-o][-i][-a userpass][-c command][-b output]"); Arguments arguments = null; if (commandLine.parse(args)) { arguments = new Arguments(); if (commandLine.hasOption("v")) arguments.setVerboseLogging(true); if (commandLine.hasOption("p")) arguments.setPort(commandLine.getOptionArgument("p", "port")); if (commandLine.hasOption("d")) arguments.setRootPath(commandLine.getOptionArgument("d", "dir")); if (commandLine.hasOption("r")) arguments.setRootDirectory(commandLine.getOptionArgument("r", "root")); if (commandLine.hasOption("l")) arguments.setLogDirectory(commandLine.getOptionArgument("l", "logDir")); if (commandLine.hasOption("e")) arguments.setDaysTillVersionsExpire(commandLine.getOptionArgument("e", "days")); if (commandLine.hasOption("a")) arguments.setUserpass(commandLine.getOptionArgument("a", "userpass")); if (commandLine.hasOption("c")) arguments.setCommand(commandLine.getOptionArgument("c", "command")); if (commandLine.hasOption("b")) arguments.setOutput(commandLine.getOptionArgument("b", "output")); if (commandLine.hasOption("f")) arguments.setConfigFile(commandLine.getOptionArgument("f", "config")); arguments.setOmitUpdates(commandLine.hasOption("o")); arguments.setInstallOnly(commandLine.hasOption("i")); } return arguments; }
<T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc); Map<String, Object> getBulk(Collection<String> keys); <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys); Map<String, Object> getBulk(String... keys); <T> Future<Boolean> touch(final String key, final int exp, final Transcoder<T> tc); <T> Future<Boolean> touch(final String key, final int exp); Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, int by); long decr(String key, int by); long incr(String key, int by, long def, int exp); long decr(String key, int by, long def, int exp); Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, int by); long incr(String key, int by, long def); long decr(String key, int by, long def); Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs);  Set<String> listSaslMechanisms(); }
public Symbol putProperty(String key, String value) { if (properties == null) properties = new HashMap<>(1); properties.put(key, value); return this; }
private LeaderElectionSupport createLeaderElectionSupport() { LeaderElectionSupport electionSupport = new LeaderElectionSupport(); electionSupport.setZooKeeper(zooKeeper); electionSupport.setRootNodeName(TEST_ROOT_NODE + Thread.currentThread().getId()); electionSupport.setHostName("foohost"); return electionSupport; }
public String pass(String s) { return String.format("<span class=\"pass\">%s</span>", s); }
public Object convert(String value, Class type) { if(value==null || value=="") { return 0F; } try { return Float.parseFloat(value);
static void launch(Arguments arguments, FitNesseContext context, FitNesse fitnesse) throws Exception { if (!arguments.isInstallOnly()) { boolean started = fitnesse.start();
public void testIndividualTestTimingsShouldAppearInSummary() throws Exception { TimeMeasurement totalTimeMeasurement = newConstantElapsedTimeMeasurement(900).start(); formatter.page = new WikiPageDummy(); formatter.announceNumberTestsToRun(2); WikiTestPage firstPage = new WikiTestPage(new WikiPageDummy("page1", "content")); WikiTestPage secondPage = new WikiTestPage(new WikiPageDummy("page2", "content")); formatter.newTestStarted(firstPage); clock.elapse(670); formatter.testComplete(firstPage, new TestSummary(1, 2, 3, 4)); formatter.newTestStarted(secondPage); clock.elapse(890); formatter.testComplete(secondPage, new TestSummary(5, 6, 7, 8)); formatter.allTestingComplete(totalTimeMeasurement.stop()); assertHasRegexp("<li.*\\(page1\\).*<span.*>\\(0\\.670 seconds\\)</span>.*</li>", pageBuffer.toString()); assertHasRegexp("<li.*\\(page2\\).*<span.*>\\(0\\.890 seconds\\)</span>.*</li>", pageBuffer.toString()); }
String getPath(); String getContent(); boolean targetExists(String wikiWordPath); String makeFullPathOfTarget(String wikiWordPath); String findParentPath(String targetName); Maybe<SourcePage> findIncludedPage(String pageName); Collection<SourcePage> getAncestors(); Collection<SourcePage> getChildren(); boolean hasProperty(String propertyKey); String getProperty(String propertyKey); }
long getLastCxid();  long getLastZxid();  long getLastResponseTime();  long getLastLatency();  void resetStats(); }
public HtmlTag makeHelpTextHtml(PageData pageData) { return makeInputField("Help Text:", PropertyHELP, "HelpText", 90, pageData);
public boolean matchesFor(SymbolType type) { return (parent != null && parent.matchesFor(type)) || symbolTypes.contains(type); }
public String getClientPort();  public String getVersion();  public String getStartTime();  public long getMinRequestLatency();  public double getAvgRequestLatency();  public long getMaxRequestLatency();  public long getPacketsReceived();  public long getPacketsSent();  public long getFsyncThresholdExceedCount();  public long getOutstandingRequests();  public int getTickTime();  public void setTickTime(int tickTime);  public int getMaxClientCnxnsPerHost();  public void setMaxClientCnxnsPerHost(int max);  public int getMinSessionTimeout();  public void setMinSessionTimeout(int min);  public int getMaxSessionTimeout();  public void setMaxSessionTimeout(int max); public boolean getResponseCachingEnabled(); public void setResponseCachingEnabled(boolean isEnabled);  public void resetStatistics();  public void resetLatency();  public void resetMaxLatency();  public void resetFsyncThresholdExceedCount();  public long getNumAliveConnections();  public long getDataDirSize();  public long getLogDirSize();  public String getSecureClientPort();  public String getSecureClientAddress();  public long getTxnLogElapsedSyncTime();  public int getJuteMaxBufferSize();  public int getLastClientResponseSize();  public int getMinClientResponseSize();  public int getMaxClientResponseSize(); }
private void parseViews(File file) throws IOException { if (!file.exists()) { return; } logger.warn("Vraptor 2 views.properties found - remember to migrate to vraptor3"); Properties p = new Properties(); FileInputStream stream = new FileInputStream(file); p.load(stream); for (Object key : p.keySet()) { results.put((String) key, p.getProperty((String) key)); logger.debug("Mapped: " + key + " to " + p.getProperty((String) key)); } logger.warn("[MIGRATION] You still have to migrate " + p.size() + " forwards found at " + file.getAbsolutePath()); stream.close(); }
public void willAddValidationMessagesForConversionErrors() throws Exception { ResourceMethod setId = mockery.methodFor(Dog.class, "setId", int.class); final ResourceBundle resourceBundle = mockery.stubResourceBundle(this, "is_not_a_valid_integer", "is_not_a_valid_integer"); mockery.checking(new Expectations() {{ allowing(mockHttpServletRequest).getParameterNames(); will(returnValue(enumerationFor("id"))); allowing(mockHttpServletRequest).getParameterValues("id"); will(returnValue(new String[] {"asdf"})); allowing(mockNameProvider).parameterNamesFor(with(any(Method.class))); will(returnValue(new String [] {"id"})); allowing(mockContainer).instanceFor(PrimitiveIntConverter.class); will(returnValue(new PrimitiveIntConverter())); allowing(mockLocalization).getBundle(); will(returnValue(resourceBundle)); }}); iogiProvider.getParametersFor(setId, errors, resourceBundle); assertThat(errors.size(), is(equalTo(1))); }
public String execute(RequestInfo request, int counter) { assertNotNull(getFromContainerInCurrentThread(LocalDateConverter.class, request)); assertNotNull(getFromContainerInCurrentThread(LocalTimeConverter.class, request)); Converters converters = getFromContainerInCurrentThread(Converters.class, request); assertTrue(converters.existsFor(LocalDate.class)); assertTrue(converters.existsFor(LocalTime.class)); return null; }
public String makeFullPath(String prefix, String... name){ StringBuilder sb=new StringBuilder(prefix == null ? "/" : (prefix.equals("/")?prefix:prefix+"/")); boolean first=true; for (String s : name) { if(s==null) continue; if(!first){ sb.append("/"); }else first=false; sb.append(s); } return sb.toString(); }
<T> Future<Boolean> add(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> add(String key, int exp, Object o); <T> Future<Boolean> set(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> set(String key, int exp, Object o); <T> Future<Boolean> replace(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> replace(String key, int exp, Object o); <T> Future<T> asyncGet(String key, Transcoder<T> tc); Future<Object> asyncGet(String key); <T> Future<CASValue<T>> asyncGets(String key, Transcoder<T> tc); Future<CASValue<Object>> asyncGets(String key); <T> CASValue<T> gets(String key, Transcoder<T> tc) throws OperationTimeoutException; CASValue<Object> gets(String key) throws OperationTimeoutException; <T> T get(String key, Transcoder<T> tc) throws OperationTimeoutException; Object get(String key) throws OperationTimeoutException; <T> Future<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); Future<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> Future<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); Future<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc) throws OperationTimeoutException; Map<String, Object> getBulk(Collection<String> keys) throws OperationTimeoutException; <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys) throws OperationTimeoutException; Map<String, Object> getBulk(String... keys) throws OperationTimeoutException; Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, int by) throws OperationTimeoutException; long decr(String key, int by) throws OperationTimeoutException; long incr(String key, int by, long def, int exp) throws OperationTimeoutException; long decr(String key, int by, long def, int exp) throws OperationTimeoutException; Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, int by); long incr(String key, int by, long def) throws OperationTimeoutException; long decr(String key, int by, long def) throws OperationTimeoutException; Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs);  void authenticate(String mechs[], CallbackHandler cbh) throws OperationException; }
protected abstract List getItemsFromPage(WikiPage page) throws Exception; }
void setHandlingNode(MemcachedNode to);  void timeOut();  boolean isTimedOut();  boolean isTimedOut(long ttlMillis);  boolean isTimedOutUnsent();  long getWriteCompleteTimestamp();  byte[] getErrorMsg(); }
private static String wordsToString(List<Object> words) { StringBuilder result = new StringBuilder(); result.append("["); for (Object word : words) { result.append(word); result.append(","); } int end = result.length() - 1; if (result.charAt(end) == ',') { result.deleteCharAt(end); } result.append("]"); return result.toString(); }
public static String[] findFiles(File dir, String[] includes, String[] excludes) { DirectoryScanner scanner = new DirectoryScanner(); scanner.setBasedir(dir); scanner.setIncludes(includes); scanner.setExcludes(excludes); scanner.addDefaultExcludes(); scanner.scan(); return scanner.getIncludedFiles(); }
public void startup(ZooKeeperServer zks) throws IOException, InterruptedException { start(); zks.startup(); setZooKeeperServer(zks); }
public void testNoWatcherServerException() throws InterruptedException, IOException, TimeoutException { CountdownWatcher watcher = new CountdownWatcher(); MyZooKeeper zk = new MyZooKeeper(hostPort, CONNECTION_TIMEOUT, watcher); boolean nw = false; watcher.waitForConnected(CONNECTION_TIMEOUT); try { zk.removeWatches("/nowatchhere", watcher, WatcherType.Data, false); } catch (KeeperException nwe) { if (nwe.code().intValue() == Code.NOWATCHER.intValue()) { nw = true; } } Assert.assertTrue("Server didn't return NOWATCHER", zk.getRemoveWatchesRC() == Code.NOWATCHER.intValue()); Assert.assertTrue("NoWatcherException didn't happen", nw); }
private void process(List<Op> ops) throws Exception { pLatch = new CountDownLatch(1); processor = new PrepRequestProcessor(zks, new MyRequestProcessor()); Record record = new MultiTransactionRecord(ops); Request req = createRequest(record, OpCode.multi); processor.pRequest(req); Assert.assertTrue("request hasn't been processed in chain", pLatch.await(5, TimeUnit.SECONDS)); }
static int decodeInt(byte[] data, int i) { return (data[i] & 0xff) << 24 | (data[i+1] & 0xff) << 16
WikiPage getParent();  boolean isRoot();  WikiPage addChildPage(String name); boolean hasChildPage(String name); WikiPage getChildPage(String name);  @Deprecated void removeChildPage(String name);  void remove();  List<WikiPage> getChildren(); String getName(); PageData getData();  Collection<VersionInfo> getVersions(); WikiPage getVersion(String versionName); String getHtml();  VersionInfo commit(PageData data); PageCrawler getPageCrawler(); String getVariable(String name); }
public void pageImportError(WikiPage localPage, Exception e) { errorOccured = true; System.out.println("Exception while importing \"local page\": " + localPage.getName() + ", exception: " + e.getMessage()); if (e.getCause() != null) System.out.println(" cause: " + e.getCause().getMessage()); e.printStackTrace(System.out); testResponder.addToResponse(e.toString()); }
public void run() { PwGroup parent = mEntry.parent;
public List<Symbol> peek(int count, ParseSpecification specification) { List<Symbol> result = new ArrayList<>(count); int startPosition = next; for (int i = 0; i < count; i++) { Step step = makeNextStep(specification, startPosition); result.add(step.token); if (input.isEnd()) break; startPosition = step.nextPosition; } return result; }
protected abstract String getTestClassName(); @Test public void callNiladicFunction() throws Exception { caller.call("testSlim", "nilad"); assertTrue(testSlim.niladWasCalled()); } @Test public void throwMethodNotCalledErrorIfNoSuchMethod() throws Exception { String response = (String) caller.call("testSlim", "noSuchMethod"); assertTrue(response, response.indexOf(SlimServer.EXCEPTION_TAG) != -1 && response.indexOf("message:<<NO_METHOD_IN_CLASS noSuchMethod[0] " + getTestClassName() + ".>>") != -1); } @Test public void methodReturnsString() throws Exception { Object retval = caller.call("testSlim", "returnString"); assertEquals("string", retval); } @Test public void methodReturnsInt() throws Exception { Object retval = caller.call("testSlim", "returnInt"); assertEquals("7", retval); } @Test public void methodReturnsVoid() throws Exception { Object retval = caller.call("testSlim", "nilad"); assertEquals(VoidConverter.VOID_TAG, retval); } @Test public void methodTakesAndReturnsBooleanTrue() throws Exception { Object retval = caller.call("testSlim", "echoBoolean", "true"); assertEquals(BooleanConverter.TRUE, retval); } @Test public void methodTakesAndReturnsBooleanFalse() throws Exception { Object retval = caller.call("testSlim", "echoBoolean", "false"); assertEquals(BooleanConverter.FALSE, retval); } @Test public void passOneString() throws Exception { caller.call("testSlim", "oneString", "string"); assertEquals("string", testSlim.getStringArg()); } @Test public void passOneInt() throws Exception { caller.call("testSlim", "oneInt", "42"); assertEquals(42, testSlim.getIntArg()); } @Test public void passOneDouble() throws Exception { caller.call("testSlim", "oneDouble", "3.14159"); assertEquals(3.14159, testSlim.getDoubleArg(), .000001); } @Test public void passOneDate() throws Exception { caller.call("testSlim", "oneDate", "5-May-2009"); assertEquals((Date) new DateConverter().fromString("5-May-2009"), testSlim.getDateArg()); } @Test public void passOneList() throws Exception { caller.call("testSlim", "oneList", list("one", "two")); assertEquals(list("one", "two"), testSlim.getListArg()); } @Test public void passManyArgs() throws Exception { caller.call("testSlim", "manyArgs", "1", "2.1", "c"); assertEquals(1, testSlim.getIntegerObjectArg().intValue()); assertEquals(2.1, testSlim.getDoubleObjectArg(), .00001); assertEquals('c', testSlim.getCharArg()); } @Test public void convertLists() throws Exception { caller.call("testSlim", "oneList", "[1 ,2, 3,4, hello Bob]"); assertEquals(list("1", "2", "3", "4", "hello Bob"), caller.call("testSlim", "getListArg")); } @Test public void convertArraysOfStrings() throws Exception { caller.call("testSlim", "setStringArray", "[1 ,2, 3,4, hello Bob]"); assertEquals("[1, 2, 3, 4, hello Bob]", caller.call("testSlim", "getStringArray")); } @Test public void convertArraysOfIntegers() throws Exception { caller.call("testSlim", "setIntegerArray", "[1 ,2, 3,4]"); assertEquals("[1, 2, 3, 4]", caller.call("testSlim", "getIntegerArray")); } @Test public void convertArrayOfIntegersThrowsExceptionIfNotInteger() throws Exception { Object result = caller.call("testSlim", "setIntegerArray", "[1 ,2, 3,4, hello]"); String resultString = (String) result; assertTrue(resultString, resultString.indexOf("message:<<CANT_CONVERT_TO_INTEGER_LIST>>") != -1); } @Test public void convertArraysOfBooleans() throws Exception { caller.call("testSlim", "setBooleanArray", "[true ,false, false,true]"); assertEquals("[true, false, false, true]", caller.call("testSlim", "getBooleanArray")); } @Test public void convertArraysOfDoubles() throws Exception { caller.call("testSlim", "setDoubleArray", "[1 ,2.2, -3e2,0.04]"); assertEquals("[1.0, 2.2, -300.0, 0.04]", caller.call("testSlim", "getDoubleArray")); } @Test public void convertArrayOfDoublesThrowsExceptionIfNotInteger() throws Exception { Object result = caller.call("testSlim", "setDoubleArray", "[1 ,2, 3,4, hello]"); String resultString = (String) result; assertTrue(resultString, resultString.indexOf("message:<<CANT_CONVERT_TO_DOUBLE_LIST>>") != -1); } @Test public void handleReturnNull() throws Exception { Object result = caller.call("testSlim", "nullString"); Assert.assertNull(result); } @Test public void handleEchoNull() throws Exception { Object result = caller.call("testSlim", "echoString", new Object[]{null}); Assert.assertNull(result); } @Test public void handleNullSymbols() throws Exception { caller.setVariable("x", null); Object result = caller.call("testSlim", "echoString", new Object[]{"$x"}); assertEquals("null", result); } }
public void passManyArgs() throws Exception { caller.call("testSlim", "manyArgs", "1", "2.1", "c"); assertEquals(1, testSlim.getIntegerObjectArg().intValue()); assertEquals(2.1, testSlim.getDoubleObjectArg(), .00001); assertEquals('c', testSlim.getCharArg()); }
private DependencyNodeFilter createScalaDistroDependencyFilter() { List<DependencyNodeFilter> filters = new ArrayList<>(); filters.add(new ScalaDistroArtifactFilter(getScalaOrganization())); return new AndDependencyNodeFilter(filters); }
protected String ifSymbolAssignment(int col, int row) { String expected = table.getCellContents(col, row); Matcher matcher = SYMBOL_ASSIGNMENT_PATTERN.matcher(expected); return matcher.find() ? matcher.group(1) : null; }
private Pattern compilePattern(String originalPattern, Map<String, String> parameterPatterns) { Map<String, String> parameters = new HashMap<String, String>(parameterPatterns); Matcher matcher = Pattern.compile("\\{([^\\}]+?)\\}").matcher(originalPattern); while (matcher.find()) { String value = matcher.group(1); String defaultPattern = value.endsWith("*")? ".*" : "[^/]*"; if (!parameters.containsKey(value)) { parameters.put(value, defaultPattern); } this.parameters.add(value.replace("*", "")); } String patternUri = originalPattern; for (Entry<String, String> parameter : parameters.entrySet()) { patternUri = patternUri.replace("{" + parameter.getKey() + "}", "(" + parameter.getValue() + ")"); } logger.debug("For " + originalPattern + " retrieved " + patternUri + " with " + parameters); return Pattern.compile(patternUri); }
public void replacesPageContentWithGroups() throws Exception { WikiPage wikiPage1 = createPageWithContent("|update no param|"); observer = new MethodReplacingSearchObserver("|update no param|", "|updated no param|"); observer.process(wikiPage1); assertTrue(wikiPage1.getData().getContent().contains("|updated no param|")); WikiPage wikiPage2 = createPageWithContent("|Update no param|"); observer = new MethodReplacingSearchObserver("|update no param|", "|updated no param|"); observer.process(wikiPage2); assertTrue(wikiPage2.getData().getContent().contains("|updated no param|")); WikiPage wikiPage3 = createPageWithContent("|ensure|update no param|"); observer = new MethodReplacingSearchObserver("|updateNoParam|", "|updated no param|"); observer.process(wikiPage3); assertTrue(wikiPage3.getData().getContent().contains("|updated no param|")); WikiPage wikiPage4 = createPageWithContent("|reject|update no param|"); observer = new MethodReplacingSearchObserver("|updateNoParam|", "|updated no param|"); observer.process(wikiPage4); assertTrue(wikiPage4.getData().getContent().contains("|updated no param|")); WikiPage wikiPage5 = createPageWithContent("|check|update no param|someValue|"); observer = new MethodReplacingSearchObserver("|updateNoParam|", "|updated no param|"); observer.process(wikiPage5); assertTrue(wikiPage5.getData().getContent().contains("|updated no param|")); WikiPage wikiPage6 = createPageWithContent("|check not|update no param|someValue|"); observer = new MethodReplacingSearchObserver("|updateNoParam|", "|updated no param|"); observer.process(wikiPage6); assertTrue(wikiPage6.getData().getContent().contains("|updated no param|")); WikiPage wikiPage7 = createPageWithContent("|note|update no param|"); observer = new MethodReplacingSearchObserver("|updateNoParam|", "|updated no param|"); observer.process(wikiPage7); assertTrue(wikiPage7.getData().getContent().contains("|updated no param|")); WikiPage wikiPage8 = createPageWithContent("| |update no param|"); observer = new MethodReplacingSearchObserver("|updateNoParam|", "|updated no param|"); observer.process(wikiPage8); assertTrue(wikiPage8.getData().getContent().contains("|updated no param|")); WikiPage wikiPage9 = createPageWithContent("|show|update no param|"); observer = new MethodReplacingSearchObserver("|updateNoParam|", "|updated no param|"); observer.process(wikiPage9); assertTrue(wikiPage9.getData().getContent().contains("|updated no param|")); WikiPage wikiPage10 = createPageWithContent("|$value=|update no param|"); observer = new MethodReplacingSearchObserver("|updateNoParam|", "|updated no param|"); observer.process(wikiPage10); assertTrue(wikiPage10.getData().getContent().contains("|updated no param|")); }
public void simpleRegularExpression() throws Exception { assertExpectationMessage("=~/Bob/", "Bob", "pass(/Bob/ found in: Bob)"); }
public void assertPasses(String pageName, String pageType, String suiteFilter) throws Exception{ TestSummary summary=helper.run(pageName, pageType, suiteFilter); Assert.assertEquals("wrong", 0, summary.wrong); Assert.assertEquals("exceptions", 0, summary.exceptions); Assert.assertTrue("at least one test executed",summary.right>0); }
public SASLAuthOperation saslAuth(String[] mech, String serverName, Map<String, ?> props, AuthHandlerBridge cb) { throw new UnsupportedOperationException(); }
public void shouldValidateParameters() throws Exception { final ResourceMethod method = mockery.methodFor(Component.class, "otherMethod", int.class); mockery.checking(new Expectations() {{ Object[] values = new Object[]{new Object()}; one(parametersProvider).getParametersFor(method, errors, bundle); will(doAll(addErrorsToList("error1"),returnValue(values))); one(validator).add(errors); one(stack).next(method, null); one(params).setParameters(new Object[]{0}); Map<String, String> params = new HashMap<String, String>(); params.put("param1.id", "value1"); params.put("param2.id", "value2"); one(request).getParameterMap();will(returnValue(params)); allowing(request).getAttribute("param1");will(returnValue("originalValue1")); allowing(request).getAttribute("param2");will(returnValue(null)); allowing(request).setAttribute(with(equal("param2")), with(any(RequestOutjectMap.class))); }}); instantiator.intercept(stack, method, null); mockery.assertIsSatisfied(); }
public T insideRequest(Container secondContainer) { if (componentToRegister != null && !isAppScoped(secondContainer, componentToRegister)) { ComponentRegistry registry = secondContainer.instanceFor(ComponentRegistry.class); registry.register(componentToRegister, componentToRegister); } ResourceMethod secondMethod = mockery.mock(ResourceMethod.class, "rm" + counter); secondContainer.instanceFor(MethodInfo.class).setResourceMethod(secondMethod); return secondContainer.instanceFor(component); }
private static void validateFormat(String s) { if ("(x,y)".length() > s.length() || !s.contains("(") || !s.contains(",") || !s.contains(")")) {
public void loadSlimTables() throws PluginException { forEachNamedObject(ConfigurationParameter.SLIM_TABLES, new Registrar() { @Override public void register(String key, Class clazz) {
protected ScriptTable createChild(ScenarioTestContext testContext, Table newTable) { ScriptTable scriptTable = new ScriptTable(newTable, id, testContext); scriptTable.setCustomComparatorRegistry(customComparatorRegistry); return scriptTable; }
protected boolean classExists(String className) { try { Class.forName(className);
public void addAuthInfo(String scheme, byte auth[]) { cnxn.addAuthInfo(scheme, auth); }
@Test public void translatesContents() throws Exception { WikiPage pageOne = makePages(); ParserTest.assertTranslatesTo(pageOne, "!contents", contentsWithPages("PageThree", "PageTwo"));
public void testFallbackLocale() { when(request.getAttribute(FMT_FALLBACK_LOCALE + ".request")).thenReturn(PT_BR); assertThat(localization.getFallbackLocale(), equalTo(PT_BR)); }
public boolean isConnected() { return slimServerVersionMessage != null && slimServerVersionMessage.startsWith(SlimVersion.SLIM_HEADER); }
public static synchronized void createInstanceIfNeeded(SlimTableFactory factory) { if (INSTANCE == null) { INSTANCE = new SlimTableDefaultColoring(factory);
public void testCnxManager() throws Exception { CnxManagerThread thread = new CnxManagerThread(); thread.start(); QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 1000, 2, 2, 2); QuorumCnxManager cnxManager = peer.createCnxnManager(); QuorumCnxManager.Listener listener = cnxManager.listener; if (listener != null) { listener.start(); } else { LOG.error("Null listener when initializing cnx manager"); } cnxManager.toSend(0L, createMsg(ServerState.LOOKING.ordinal(), 1, -1, 1)); Message m = null; int numRetries = 1; while ((m == null) && (numRetries++ <= THRESHOLD)) { m = cnxManager.pollRecvQueue(3000, TimeUnit.MILLISECONDS); if (m == null) { cnxManager.connectAll(); } } assertTrue(numRetries <= THRESHOLD, "Exceeded number of retries"); thread.join(5000); if (thread.isAlive()) { fail("Thread didn't join"); } else { if (thread.failed) { fail("Did not receive expected message"); } } cnxManager.halt(); assertFalse(cnxManager.listener.isAlive()); }
public void shouldConvertToZeroWhenEmpty() { assertThat((Character) converter.convert("", char.class, bundle), is(equalTo('\u0000'))); }
public void setUp() throws Exception { count = 3; peers = new HashMap<Long, QuorumServer>(count); tmpdir = new File[count]; port = new int[count]; }
protected void setUp() throws Exception { LOG.info("STARTING " + getName());
private double trig() { double ans = 0; boolean found = false; if (s.indexOf("sin") == 0) { s = s.substring(3); ans = Math.sin(trig()); found = true; } else if (s.indexOf("cos") == 0) { s = s.substring(3); ans = Math.cos(trig()); found = true; } else if (s.indexOf("tan") == 0) { s = s.substring(3); ans = Math.tan(trig()); found = true; } if (!found) { ans = exp(); } return ans; }
public void shouldCallMethodOnInstallLibraryWhenMethodIsNotFoundInAFixture_WithSystemUnderTestInFixture() throws Exception { createNamedFixture(); FileSupport library = createFileSupportLibrary(); assertNotNull(library); Object result = statementExecutor.call(INSTANCE_NAME, deleteMethodName(), "filename.txt"); assertEquals(voidMessage(), result); assertTrue(library.deleteCalled()); }
String makeFullPathOfTarget(String wikiWordPath); String findParentPath(String targetName); Maybe<SourcePage> findIncludedPage(String pageName); Collection<SourcePage> getChildren(); boolean hasProperty(String propertyKey); String getProperty(String propertyKey); String makeUrl(String wikiWordPath); List<Symbol> getSymbols(SymbolType symbolType); }
public void testAppend() throws Exception { final String key = "append.key"; assertTrue(client.set(key, 5, "test").get()); OperationFuture<Boolean> op = client.append(0, key, "es"); assertTrue(op.get()); assertEquals(StatusCode.SUCCESS, op.getStatus().getStatusCode()); assert op.getStatus().isSuccess(); assertEquals("testes", client.get(key)); }
private Leader createMockLeader(File tmpDir, QuorumPeer peer) throws IOException, NoSuchFieldException, IllegalAccessException{ LeaderZooKeeperServer zk = prepareLeader(tmpDir, peer); return new MockLeader(peer, zk); }
public void testGetContentAndAttributes() throws Exception { Object obj = doSetUpWith(root, "meat"); assertNotNull(obj); assertTrue(obj instanceof PageData); PageData data = (PageData) obj; assertEquals("this is page one", data.getContent()); WikiPageProperties props = data.getProperties(); assertTrue(props.has("Attr1")); }
protected HtmlTag createTag(Map<?, ?> hash) {
public void testFindReferencingPagesOnSiblingAndChild() throws Exception { WhereUsedPageFinder whereUsed = new WhereUsedPageFinder(pageOne, hits); whereUsed.search(root); hits.assertPagesFound(pageTwo.getName(), pageTwoChild.getName()); }
public void constructorAcceptsTestSlimFromSymbol() throws Exception { statements.add(list("id1", "callAndAssign", "v", "testSlim", "createTestSlimWithString", "test string")); statements.add(list("m2", "make", "newTestSlim", testClass, "4", "$v")); statements.add(list("id2", "call", "newTestSlim", "getStringArg")); respondsWith(list(list("id1", "TestSlim: 0, test string"), list("m2", "OK"), list("id2", "test string"))); }
public void testExecutionStatusHtml() throws Exception { TimeMeasurement totalTimeMeasurement = new TimeMeasurement().start(); TimeMeasurement timeMeasurement = new TimeMeasurement(); formatter.writeHead("test"); formatter.setExecutionLogAndTrackingId("2", new CompositeExecutionLog(root.addChildPage("ErrorLogs"))); formatter.announceNumberTestsToRun(1); formatter.newTestStarted(page, timeMeasurement.start()); formatter.testComplete(page, new TestSummary(4, 1, 0, 0), timeMeasurement.stop()); formatter.allTestingComplete(totalTimeMeasurement.stop()); assertSubString("Tests Executed OK", pageBuffer.toString()); }
private void refreshList() { ((BaseAdapter) mAdapter).notifyDataSetChanged(); }
private boolean allows(T resource, Method method) { try { List<br.com.caelum.vraptor.restfulie.relation.Relation> transitions = resource.getRelations(restfulie);
public void nullInteractionService_returnsDefaultClass() { String defaultInteractionName = JavaSlimFactory.createInteraction(null).getClass().getName(); SlimService.Options options = SlimService.parseCommandLine(new String[]{"8099"}); assertEquals(defaultInteractionName, options.interaction.getClass().getName()); }
public void newTestStarted(WikiPage test, TimeMeasurement timeMeasurement) throws Exception { } public void setExecutionLogAndTrackingId(String stopResponderId, CompositeExecutionLog log) throws Exception { } public void testComplete(WikiPage test, TestSummary testSummary, TimeMeasurement timeMeasurement) throws Exception { recordTestResult(new WikiPagePath(test).toString(), testSummary, timeMeasurement.elapsed()); } public void testOutputChunk(String output) throws Exception { } public void testSystemStarted(TestSystem testSystem, String testSystemName, String testRunner) throws Exception { } }
public void shouldStoreFirstVersionAsZero() { WikiPage root = wikiPageFactory.makeRootPage(null, "RooT"); root.commit(root.getData()); assertEquals(1, root.getVersions().size()); assertEquals("0", root.getVersions().iterator().next().getName()); }
public Optional<String> findVariable(String requestedName) { return requestedName.equals(name) ? Optional.ofNullable(value) : Optional.empty(); }
public void testResponse() throws Exception { MockRequest request = new MockRequest(); request.setResource("PageOne"); WhereUsedResponder responder = new WhereUsedResponder(); Response response = responder.makeResponse(context, request); MockResponseSender sender = new MockResponseSender(); response.sendTo(sender); String content = sender.sentData(); assertEquals(200, response.getStatus()); assertHasRegexp("Where Used", content); assertHasRegexp("PageOne", content); assertHasRegexp("PageTwo", content); assertHasRegexp("PageTwo\\.ChildPage", content); }
public void shouldAcceptAResultWithOptionsWebMethod() throws SecurityException, NoSuchMethodException { List<Route> routes = parser.rulesFor(new DefaultResourceClass(ClientsController.class)); Route route = getRouteMatching(routes, "/clients/options"); assertThat(route.allowedMethods(), is(EnumSet.of(HttpMethod.OPTIONS))); }
public void testVersionConversion() { Calendar cal = new GregorianCalendar(2013, Calendar.FEBRUARY, 17); assertEquals("should match", "1.0", Utils.convertToDebianVersion("1.0", false, "SNAPSHOT", cal.getTime())); assertEquals("should match", "1.0~SNAPSHOT", Utils.convertToDebianVersion("1.0+SNAPSHOT", false, "SNAPSHOT", cal.getTime())); assertEquals("should match", "1.0~SNAPSHOT", Utils.convertToDebianVersion("1.0-SNAPSHOT", false, "SNAPSHOT", cal.getTime())); assertEquals("should match", "1.0~20130217000000", Utils.convertToDebianVersion("1.0+SNAPSHOT", true, "SNAPSHOT", cal.getTime())); assertEquals("should match", "1.0~RC2", Utils.convertToDebianVersion("1.0-RC2", true, "SNAPSHOT", cal.getTime())); assertEquals("should match", "1.0~alpha3", Utils.convertToDebianVersion("1.0-alpha3", true, "SNAPSHOT", cal.getTime())); assertEquals("should match", "1.0~Beta+4", Utils.convertToDebianVersion("1.0.Beta-4", true, "SNAPSHOT", cal.getTime())); assertEquals("should match", "1.0~milestone+4", Utils.convertToDebianVersion("1.0-milestone-4", true, "SNAPSHOT", cal.getTime())); assertEquals("should match", "1.0~a+4", Utils.convertToDebianVersion("1.0-a-4", true, "SNAPSHOT", cal.getTime())); assertEquals("should match", "1.0~b+4", Utils.convertToDebianVersion("1.0-b-4", true, "SNAPSHOT", cal.getTime())); assertEquals("should match", "1.0~rc7", Utils.convertToDebianVersion("1.0rc7", true, "SNAPSHOT", cal.getTime())); }
public void visitAttribute(final Attribute attr) { cv.visitAttribute(attr); }
public static String replaceHostPattern(String principal) { String[] components = principal.split("[/@]"); if (components == null || components.length < 2
private void makeEditForm(HtmlPage html, String resource, boolean firstTimeForNewPage, String defaultNewPageContent) { html.put("resource", resource); html.put(TIME_STAMP, String.valueOf(SaveRecorder.timeStamp())); html.put(TICKET_ID, String.valueOf(SaveRecorder.newTicket())); if (request.hasInput("redirectToReferer") && request.hasHeader("Referer")) { String redirectUrl = request.getHeader("Referer").toString(); int questionMarkIndex = redirectUrl.indexOf("?"); if (questionMarkIndex > 0) redirectUrl = redirectUrl.substring(0, questionMarkIndex); redirectUrl += "?" + request.getInput("redirectAction").toString(); html.put("redirect", redirectUrl); } html.put(HELP_TEXT, pageData.getAttribute(PageData.PropertyHELP)); html.put("suites", pageData.getAttribute(PageData.PropertySUITES)); html.put(CONTENT_INPUT_NAME, Utils.escapeHTML(firstTimeForNewPage ? defaultNewPageContent : content)); List<String> templateList = new ArrayList<String>(); templateList.add("Sample 1"); templateList.add("Sample 2"); templateList.add("Sample 3"); html.put(TEMPLATE_LIST, templateList); }
public void endTag() { Tag tag = tags.pop(); if (tag.open) { html.append(" />"); } else { if (html.length() == lastEndLine) { indentTag(); } html.append("</"); html.append(tag.name); html.append('>'); } if (!tag.inline) writeEndLine(); }
private void extendRow(Table table, int row, List<Object> cellList) { while (table.getColumnCountInRow(row) < cellList.size()) table.appendCellToRow(row, (String) cellList.get(table.getColumnCountInRow(row)));
public String toString() { StringBuffer result = new StringBuffer(); result.append("["); for (Object word : words) { result.append(word); result.append(","); } int end = result.length() - 1; if (result.charAt(end) == ',') result.deleteCharAt(end); result.append("]"); return result.toString(); }
public TwoWayConverter<?> twoWayConverterFor(Class<?> type) { throw new UnsupportedOperationException( "no new features for VRaptor 2 compatibility, sorry");
abstract void cleanup();  abstract void packetAdded();  abstract void onClosing();  abstract void saslCompleted();  abstract void connectionPrimed();  abstract void doTransport(int waitTimeOut, List<Packet> pendingQueue, ClientCnxn cnxn) throws IOException, InterruptedException;  abstract void testableCloseSocket() throws IOException;  abstract void close();  abstract void sendPacket(Packet p) throws IOException; }
public void shouldAddInterceptorsInOrder() throws InterceptionException, IOException { final Sequence sequence = mockery.sequence("executionSequence"); mockery.checking(new Expectations() { { one(stack).add(ResourceLookupInterceptor.class); inSequence(sequence); one(stack).add(URLParameterExtractorInterceptor.class); inSequence(sequence); one(stack).add(InterceptorListPriorToExecutionExtractor.class); inSequence(sequence); one(stack).add(MultipartInterceptor.class); inSequence(sequence); one(stack).add(instantiator); inSequence(sequence); one(stack).add(ParametersInstantiatorInterceptor.class); inSequence(sequence); one(stack).add(HibernateValidatorPluginInterceptor.class); inSequence(sequence); one(stack).add(ValidatorInterceptor.class); inSequence(sequence); one(stack).add(ExecuteAndViewInterceptor.class); inSequence(sequence); one(stack).add(OutjectionInterceptor.class); inSequence(sequence); one(stack).add(AjaxInterceptor.class); inSequence(sequence); one(stack).add(ViewInterceptor.class); inSequence(sequence); one(stack).next(null, null); inSequence(sequence); } }); execution.execute(); mockery.assertIsSatisfied(); }
public static byte[] encodeByte(byte in) { return new byte[]{in}; }
public static void assertParses(String input, String expected) throws Exception { WikiPage page = new TestRoot().makePage("TestPage", input); Symbol result = parse(page, input); assertEquals(expected, serialize(result)); }
protected boolean matchesSafely(List<T> item) { for (int i = 0; i < elements.length - 1; i++) { if (item.indexOf(elements[i]) > item.indexOf(elements[i+1])) { return false; } } return true; }
public void testSine() throws Exception { assertEquals("1.8509", new EvaluatorWidget(widgetRoot, "${=%5.4f: 1 + sin 45 =}").render()); }
public Value merge(final Value v, final Value w) { if (!v.equals(w)) { return BasicValue.UNINITIALIZED_VALUE; } return v; }
public void exitCode(int exitCode) { suiteExecutionReport.exitCode(exitCode); if (testHistoryFormatter != null) { testHistoryFormatter.exitCode(exitCode);
public abstract void setNumRounds(long rounds) throws NumberFormatException; public abstract boolean appSettingsEnabled(); }
void visit(String name, Object value);  void visitEnum(String name, String desc, String value);  AnnotationVisitor visitAnnotation(String name, String desc);  AnnotationVisitor visitArray(String name);  void visitEnd(); }
protected ClientCnxn createConnection( String chrootPath, HostProvider hostProvider, int sessionTimeout, ZooKeeper zooKeeper, ClientWatchManager watcher, ClientCnxnSocket clientCnxnSocket, boolean canBeReadOnly) throws IOException { return new TestableClientCnxn( chrootPath,
private Payload payload(String payload) { return new Payload(payload); }
public void executesInternalValidationIfSuccessful() { final Client guilherme = new Client(); guilherme.age = 10; validations.that(guilherme).shouldBe(notNullValue()).otherwise(new Validations() { public void check(){ that(guilherme.getAge()).shouldBe(greaterThan(17)); that(guilherme.getAge()).shouldBe(greaterThanOrEqualTo(12)); } }); assertThat(validations.getErrors(), hasSize(2)); }
private void includeScenarioLibrariesIfAny(LibraryFilter libraryFilter) { List<WikiPage> uncles = PageCrawlerImpl.getAllUncles("ScenarioLibrary", testPage.getSourcePage()); List<WikiPage> filteredUncles = filter(uncles, libraryFilter); if (filteredUncles.size() > 0) includeScenarioLibraries(filteredUncles);
public void portRotates() throws Exception { SlimTestSystem sys = new HtmlSlimTestSystem(root, dummyListener); for (int i=1; i<15; i++) assertEquals(8085 + (i%10), sys.getNextSlimSocket());
public void setup() { this.mockery = new VRaptorMockery(); this.resource = mockery.resource(Clients.class); this.request = mockery.mock(MutableRequest.class); this.router = new DefaultRouter(new RoutesConfiguration() { public void config(Router router) { } }, new PathAnnotationRoutesCreator(), null, null); router.register(resource); }
public void testButtons() throws Exception { request.setResource("files/testDir/"); Responder responder = FileResponder.makeResponder(request, SampleFileUtility.base); response = (SimpleResponse) responder.makeResponse(context, request); assertHasRegexp("upload form", response.getContent()); assertHasRegexp("create directory form", response.getContent()); }
private final void ReInitRounds() { int i; jjround = 0x80000001; for (i = 5; i-- > 0;) jjrounds[i] = 0x80000000;
protected void finish(boolean result, String message) { if ( mFinish != null ) { mFinish.setResult(result, message);
public void testRootWatchTriggered() throws Exception { class MyWatcher implements Watcher{ boolean fired=false; public void process(WatchedEvent event) { if(event.getPath().equals("/")) fired=true; } } MyWatcher watcher=new MyWatcher();
void at(String uri); }  <T> T relation(Class<T> type); List<Relation> getRelations(); }
public void testSimpleCounter() { SimpleCounter metric = new SimpleCounter("test"); testSimpleCounter(metric, 0); testSimpleCounter(metric, 1); for (int i = 0; i < RANDOM_TRIALS; ++i) { testSimpleCounter(metric, RANDOM_SIZE);
public void testCreate2OK() throws Exception { zkClient.create(PARENT_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, null); zkClientB.create(CHILD_PATH, DATA, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT, null); Assert.assertEquals("OutstandingRequests not decremented", 0,
abstract void encode(DEROutputStream out) throws IOException; public String toString() { return "[" + tagNo + "]" + obj; } }
protected void unpackXml(Document xmlDoc) { Element historyDocument = xmlDoc.getDocumentElement(); unpackCommonFields(historyDocument); unpackResults(historyDocument); unpackExecutionLogs(historyDocument); }
public static void walk(ArchiveInputStream in, ArchiveVisitor visitor) throws IOException { try { ArchiveEntry entry;
public void testKerberosLogin() throws Exception { MiniKdc kdc = getKdc(); File workDir = getWorkDir(); LoginContext loginContext = null; try { String principal = "foo";
private GcTimes subtract(GcTimes other) { return new GcTimes(this.gcCount - other.gcCount, this.gcTimeMillis - other.gcTimeMillis); }
public void testThatSpecialCharsAreNotEscapedTwice() throws Exception { PageData d = new PageData(new WikiPageDummy().getData(), "<b>"); String html = d.getHtml(); assertEquals("&lt;b&gt;", html); }
public boolean accepts(ResourceMethod method) { return ServletFileUpload.isMultipartContent(request); }
public OperationFuture<Boolean> replace(String key, int exp, Object o) { return asyncStore(StoreType.replace, key, exp, o, transcoder); }
public void allTestingComplete() throws Exception { for (BaseFormatter formatter : formatters) formatter.allTestingComplete();
private HtmlTag makeHeader(String resource, String title, boolean firstTimeForNewPage) throws Exception { return HtmlUtil.makeBreadCrumbsWithPageType(resource, title + "Page:"); }
public void cannotHandleTypeWhenItsAnotherType() throws SecurityException, NoSuchMethodException { PatternBasedStrategy strategy = new PatternBasedStrategy(new PatternBasedType("Another"), new PatternBasedType("list"), null); assertThat(strategy.canHandle(MyComponent.class, MyComponent.class.getDeclaredMethod("list")), is(equalTo(false))); }
public void setUp() throws Exception { root = InMemoryPage.makeRoot("RooT"); request = new MockRequest(); }
public void produce( final DataConsumer pReceiver ) { if (!src.exists()) { System.err.println("ATTENTION: \"" + src + " \" is not existing. Ignoring unexisting data providers is deprecated. This will fail your build in later releases."); return; } org.vafer.jdeb.mapping.Mapper[] mappers = new org.vafer.jdeb.mapping.Mapper[mapperWrapper.size()]; final Iterator it = mapperWrapper.iterator(); for (int i = 0; i < mappers.length; i++) { mappers[i] = ((Mapper)it.next()).createMapper(); } if (src.isFile()) { new DataProducerArchive(
public void copyHeader(PwDbHeaderV3 header) { dbHeader = header; }
public void setup() { this.mockery = new VRaptorMockery(); this.converters = mockery.mock(Converters.class); this.mockHttpServletRequest = mockery.mock(HttpServletRequest.class); this.mockNameProvider = mockery.mock(ParameterNameProvider.class); Instantiator<Object> instantiator = new Instantiator<Object>(){ private Iogi iogi = new Iogi(new NullDependencyProvider(), new DefaultLocaleProvider()); @Override public Object instantiate(Target<?> target, Parameters parameters) { return iogi.instantiate(target, parameters); } @Override public boolean isAbleToInstantiate(Target<?> arg0) { return true; } };; this.provider = new IogiParametersProvider(mockNameProvider, mockHttpServletRequest, instantiator ); this.errors = new ArrayList<Message>(); mockery.checking(new Expectations() { {
boolean exists(File file); String[] list(File path); String getContent(File file) throws IOException; InputStream getInputStream(File file) throws IOException; void delete(File path); long lastModified(File file); }
public String getStartTime();  public long getMinRequestLatency();  public long getAvgRequestLatency();  public long getMaxRequestLatency();  public long getPacketsReceived();  public long getPacketsSent();  public long getOutstandingRequests();  public int getTickTime();  public void setTickTime(int tickTime);  public int getMaxClientCnxnsPerHost();  public void setMaxClientCnxnsPerHost(int max);  public int getMinSessionTimeout();  public void setMinSessionTimeout(int min);  public int getMaxSessionTimeout();  public void setMaxSessionTimeout(int max);  public void resetStatistics();  public void resetLatency();  public void resetMaxLatency();  public long getNumAliveConnections();  public long getDataDirSize();  public long getLogDirSize(); }
public void testPad() throws Exception { File tmpDir = ClientBase.createTmpDir(); FileTxnLog txnLog = new FileTxnLog(tmpDir); TxnHeader txnHeader = new TxnHeader(0xabcd, 0x123, 0x123, Time.currentElapsedTime(), ZooDefs.OpCode.create); Record txn = new CreateTxn("/Test", new byte[0], null, false, 1); txnLog.append(txnHeader, txn); FileInputStream in = new FileInputStream(tmpDir.getPath() + "/log." + Long.toHexString(txnHeader.getZxid())); BinaryInputArchive ia = BinaryInputArchive.getArchive(in); FileHeader header = new FileHeader(); header.deserialize(ia, "fileheader"); LOG.info("Received magic : " + header.getMagic() + " Expected : " + FileTxnLog.TXNLOG_MAGIC); Assert.assertTrue("Missing magic number ", header.getMagic() == FileTxnLog.TXNLOG_MAGIC);
public void translatesImageLinks() { ParserTestHelper.assertTranslatesTo("http://some.jpg", "<img src=\"http://some.jpg\"/>"); ParserTestHelper.assertTranslatesTo("http://files/myfile.jpg", "<img src=\"files/myfile.jpg\"/>"); ParserTestHelper.assertTranslatesTo("http://files/myfile.gif", "<img src=\"files/myfile.gif\"/>"); ParserTestHelper.assertTranslatesTo("http://files/myfile.png", "<img src=\"files/myfile.png\"/>"); ParserTestHelper.assertTranslatesTo("http://files/myfile.svg", "<img src=\"files/myfile.svg\"/>"); }
public void setUp() throws Exception { testData = new WikiImporterTest(); testData.createRemoteRoot(); testData.createLocalRoot(); FitNesseUtil.startFitnesse(testData.remoteRoot); baseUrl = "http://localhost:" + FitNesseUtil.PORT + "/"; createResponder(); }
public WikiPageProperties defaultPageProperties() { WikiPageProperties properties = new WikiPageProperties(); properties.set(PageData.PropertyEDIT); properties.set(PageData.PropertyPROPERTIES); properties.set(PageData.PropertyREFACTOR); properties.set(PageData.PropertyWHERE_USED); properties.set(PageData.PropertyRECENT_CHANGES); properties.set(PageData.PropertyFILES); properties.set(PageData.PropertyVERSIONS); properties.set(PageData.PropertySEARCH); properties.setLastModificationTime(Clock.currentDate()); PageType pageType = PageType.getPageTypeForPageName(getName()); if (STATIC.equals(pageType)) return properties; properties.set(pageType.toString()); return properties; }
<T> Map<String, T> getBulk(Iterator<String> keys, Transcoder<T> tc); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc); Map<String, Object> getBulk(Iterator<String> keys); Map<String, Object> getBulk(Collection<String> keys); <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys); Map<String, Object> getBulk(String... keys); <T> Future<Boolean> touch(final String key, final int exp, final Transcoder<T> tc); <T> Future<Boolean> touch(final String key, final int exp); Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, long by); long incr(String key, int by); long decr(String key, long by); long decr(String key, int by); long incr(String key, long by, long def, int exp); long incr(String key, int by, long def, int exp); long decr(String key, long by, long def, int exp); long decr(String key, int by, long def, int exp); Future<Long> asyncIncr(String key, long by); Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, long by); Future<Long> asyncDecr(String key, int by); long incr(String key, long by, long def); long incr(String key, int by, long def); long decr(String key, long by, long def); long decr(String key, int by, long def); Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs);  Set<String> listSaslMechanisms(); }
private void assertRevisionControlHeaderPresent(String html) { assertSubString(REVISION_CONTROL_HEADER, html); }
public void shouldNotComplainAboutNull() { assertThat(converter.convert(null, BigInteger.class, errors, bundle), is(nullValue())); }
public void testComplete_shouldCountTestResultsForTestHistoryFormatter() throws Exception { countTestResultsForFormatter(pageHistoryFormatter); }
public void shouldRollbackTransactionIfStillActiveWhenExecutionFinishes() throws Exception { HibernateTransactionInterceptor interceptor = new HibernateTransactionInterceptor(session, validator); when(session.beginTransaction()).thenReturn(transaction); when(transaction.isActive()).thenReturn(true); interceptor.intercept(stack, method, instance); verify(transaction).rollback(); }
public Object nextElement() { hasNext = false; return getId(); }
private String buildConfirmationHtml(WikiPage root, String qualifiedPageName, FitNesseContext context) throws Exception { HtmlPage html = context.htmlPageFactory.newPage(); html.title.use("Delete Confirmation"); html.header.use(HtmlUtil.makeBreadCrumbsWithPageType(qualifiedPageName, "/", "Confirm Deletion")); html.main.use(makeMainContent(root, qualifiedPageName)); return html.html(); }
public void deXmlizeSkippingRootLevel(Document document, WikiPage context, XmlizerPageHandler handler) { Element pageElement = document.getDocumentElement(); addChildrenFromXml(pageElement, context, handler); }
public Class<?> targetTypeForComponentFactory(Class<?> type) { Class<?> c = targetTypeForComponentFactory0(type); if(c == null) { throw new ComponentRegistrationException( "Class does not implements ComponentFactory " + type); } return c; }
public long getAvgRequestLatency();  public long getMaxRequestLatency();  public long getPacketsReceived();  public long getPacketsSent();  public long getFsyncThresholdExceedCount();  public long getOutstandingRequests();  public int getTickTime();  public void setTickTime(int tickTime);  public int getMaxClientCnxnsPerHost();  public void setMaxClientCnxnsPerHost(int max);  public int getMinSessionTimeout();  public void setMinSessionTimeout(int min);  public int getMaxSessionTimeout();  public void setMaxSessionTimeout(int max);  public void resetStatistics();  public void resetLatency();  public void resetMaxLatency();  public void resetFsyncThresholdExceedCount();  public long getNumAliveConnections();  public long getDataDirSize();  public long getLogDirSize();  public String getSecureClientPort();  public String getSecureClientAddress();  public long getTxnLogElapsedSyncTime();  public int getJuteMaxBufferSize();  public int getLastClientResponseSize();  public int getMinClientResponseSize();  public int getMaxClientResponseSize(); }
private static String resource(PageData data) throws Exception { WikiPagePath fullPath = data.getWikiPage().getPageCrawler().getFullPath(data.getWikiPage()); String resource = PathParser.render(fullPath); return resource; }
public void startServers() throws IOException { for(int i = 0; i < serverCount; i++) { startServer(i);
synchronized private SaslClient createSaslClient(final String servicePrincipal) throws LoginException { try { if (login == null) {
private void startTestSystemAndExecutePages(WikiPageDescriptor descriptor, List<WikiTestPage> testSystemPages) throws IOException, InterruptedException { TestSystem testSystem = null; try { if (!isStopped) {
public void visitEnd() { if (clinit != null) { clinit.visitInsn(Opcodes.RETURN); clinit.visitMaxs(0, 0); } cv.visitEnd(); }
private void wakeup(int sel) { synchronized(factory) { sk.selector().wakeup();
public void translatesTestTablesIntoLiteralTables() throws Exception { DecisionTable dt = makeDecisionTableAndBuildInstructions("!" + simpleDecisionTable); int n=0; Map<String, Object> pseudoResults = SlimCommandRunningClient.resultToMap( list( list(id(n++), "OK"), list(id(n++), VoidConverter.VOID_TAG), list(id(n++), VoidConverter.VOID_TAG),
public void testCallParseMethod() throws Exception { Object o = Fixture.callParseMethod(HasParseMethod.class, "target"); assertTrue(o instanceof String); String s = (String) o; assertEquals("target found", s); }
public void testQueueSizes() { ConnectionFactory cf = new DefaultConnectionFactory(100, 1024); assertEquals(100, cf.createOperationQueue().remainingCapacity()); assertEquals(Integer.MAX_VALUE, cf.createWriteOperationQueue() .remainingCapacity()); assertEquals(Integer.MAX_VALUE, cf.createReadOperationQueue() .remainingCapacity());
private void executeTests() { int exitCode = executeRunnerClassAsForked(); if (exitCode != 0) { log("Finished executing FitNesse tests: " + exitCode + " failures/exceptions");
public void testExceptionOccurred(Assertion assertion, ExceptionResult exceptionResult) { } @Override public void testComplete(TestPage test, TestSummary testSummary, TimeMeasurement timeMeasurement) { } }
protected void checkRow(int row) { int columns = table.getColumnCountInRow(row); if (columns < headerColumns) throw new SyntaxError(
public void allTestingComplete(TimeMeasurement totalTimeMeasurement) throws IOException { suiteTime.stop(); super.allTestingComplete(totalTimeMeasurement); if (writerFactory != null) writer = writerFactory.getWriter(context, page, getPageCounts(), suiteTime.startedAt()); VelocityContext velocityContext = new VelocityContext(); velocityContext.put("suiteExecutionReport", suiteExecutionReport); VelocityEngine velocityEngine = context.pageFactory.getVelocityEngine(); Template template = velocityEngine.getTemplate("suiteHistoryXML.vm"); template.merge(velocityContext, writer); writer.close(); }
public void copyHeader(PwDbHeaderV3 header) {
protected void processWord( byte[] in, int inOff) { W[wOff++] = ((long)(in[inOff] & 0xff) << 56) | ((long)(in[inOff + 1] & 0xff) << 48) | ((long)(in[inOff + 2] & 0xff) << 40) | ((long)(in[inOff + 3] & 0xff) << 32) | ((long)(in[inOff + 4] & 0xff) << 24) | ((long)(in[inOff + 5] & 0xff) << 16) | ((long)(in[inOff + 6] & 0xff) << 8) | ((in[inOff + 7] & 0xff)); if (wOff == 16) {
protected Frame newFrame(final Frame src) { return new Frame(src); }
public void shouldRegisterVRaptorInfoByDefault() throws SecurityException { final ResourceMethod method = mockery.mock(ResourceMethod.class); mockery.checking(new Expectations() { { one(methodLookup).methodFor("/is_using_vraptor", "GET"); will(returnValue(method)); } }); assertThat(registry.gimmeThis("/is_using_vraptor", "GET"), is(equalTo(method))); mockery.assertIsSatisfied(); }
public Maybe<String> render(Scanner scanner) { String body = new Translator().translate(scanner, terminator.getType()); if (scanner.isEnd()) return Maybe.noString; return new Maybe<String>(HtmlUtil.makeSpanTag(getContent(), body).html()); }
public static void assertTranslatesTo(WikiPage page, String expected) throws Exception { assertEquals(expected, translateTo(page)); }
public void dealSocketTo(int ticket, SocketDoner doner) throws Exception { SocketSeeker seeker = waitingList.get(ticket); seeker.acceptSocketFrom(doner); waitingList.remove(ticket); }
public void process(WatchedEvent event) { lastEvent = event; if (latch != null) { latch.countDown(); } LOG.info("Latch got event :: " + event); }
public void shouldExecuteInterceptorIfItAcceptsMethod() throws Exception { mockery.checking(new Expectations() { { one(interceptor).accepts(method); will(returnValue(true)); one(interceptor).intercept(stack, method, null); never(stack).next(method, null); } }); handler.execute(stack, method, null); mockery.assertIsSatisfied(); }
public void shouldThreatViewURIAsAjax() { final HttpServletRequest request = mockery.mock(HttpServletRequest.class); mockery.checking(new Expectations() { { one(request).getRequestURI(); will(returnValue("somethig.ajax.logic")); } }); assertThat(Info.isAjax(request), is(equalTo(true))); mockery.assertIsSatisfied(); }
public void login(User user) { this.user = user; session.setAttribute(CURRENT_USER, this.user); }
public boolean equals(Object o) { if (this == o) { return true; } if (!(o instanceof CreateResult)) { return false; } CreateResult other = (CreateResult) o; boolean statsAreEqual = stat == null && other.stat == null || (stat != null && other.stat != null && stat.getMzxid() == other.stat.getMzxid()); return getType() == other.getType() && path.equals(other.getPath()) && statsAreEqual; }
<T> Future<Boolean> prepend(String key, T val, Transcoder<T> tc); <T> Future<CASResponse> asyncCAS(String key, long casId, T value, Transcoder<T> tc); Future<CASResponse> asyncCAS(String key, long casId, Object value); <T> CASResponse cas(String key, long casId, int exp, T value, Transcoder<T> tc); CASResponse cas(String key, long casId, Object value); CASResponse cas(String key, long casId, int exp, Object value); <T> Future<Boolean> add(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> add(String key, int exp, Object o); <T> Future<Boolean> set(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> set(String key, int exp, Object o); <T> Future<Boolean> replace(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> replace(String key, int exp, Object o); <T> Future<T> asyncGet(String key, Transcoder<T> tc); Future<Object> asyncGet(String key); Future<CASValue<Object>> asyncGetAndTouch(final String key, final int exp); <T> Future<CASValue<T>> asyncGetAndTouch(final String key, final int exp, final Transcoder<T> tc); CASValue<Object> getAndTouch(String key, int exp); <T> CASValue<T> getAndTouch(String key, int exp, Transcoder<T> tc); <T> Future<CASValue<T>> asyncGets(String key, Transcoder<T> tc); Future<CASValue<Object>> asyncGets(String key); <T> CASValue<T> gets(String key, Transcoder<T> tc); CASValue<Object> gets(String key); <T> T get(String key, Transcoder<T> tc); Object get(String key); <T> BulkFuture<Map<String, T>> asyncGetBulk(Iterator<String> keys, Iterator<Transcoder<T>> tcs); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Iterator<Transcoder<T>> tcs); <T> BulkFuture<Map<String, T>> asyncGetBulk(Iterator<String> keys, Transcoder<T> tc); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); BulkFuture<Map<String, Object>> asyncGetBulk(Iterator<String> keys); BulkFuture<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> BulkFuture<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); BulkFuture<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Iterator<String> keys, Transcoder<T> tc); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc); Map<String, Object> getBulk(Iterator<String> keys); Map<String, Object> getBulk(Collection<String> keys); <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys); Map<String, Object> getBulk(String... keys); <T> Future<Boolean> touch(final String key, final int exp, final Transcoder<T> tc); <T> Future<Boolean> touch(final String key, final int exp); Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, long by); long incr(String key, int by); long decr(String key, long by); long decr(String key, int by); long incr(String key, long by, long def, int exp); long incr(String key, int by, long def, int exp); long decr(String key, long by, long def, int exp); long decr(String key, int by, long def, int exp); Future<Long> asyncIncr(String key, long by); Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, long by); Future<Long> asyncDecr(String key, int by); long incr(String key, long by, long def); long incr(String key, int by, long def); long decr(String key, long by, long def); long decr(String key, int by, long def); Future<Boolean> delete(String key); Future<Boolean> delete(String key, long cas); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs);  Set<String> listSaslMechanisms(); }
private static FileItemFactory createFactoryForDiskBasedFileItems(File temporaryDirectory) {
public void testCheckoutResponder() throws Exception { assertResponderTypeMatchesInput(CHECKOUT.getQuery(), CheckoutResponder.class); }
private boolean isDigit(String candidate, int offset) { return Character.isDigit(candidate.charAt(offset)); } private boolean isLetter(String candidate, int offset) { return Character.isLetter(candidate.charAt(offset)); }
public void assertSuitePasses_appliesSuiteFilterIfDefined() throws Exception { String suiteName = "FitNesse.SuiteAcceptanceTests.SuiteSlimTests"; helper.assertSuitePasses(suiteName, "testSuite"); assertEquals(new HashSet<String>(Arrays.asList(expectedTestsWithSuiteFilter)), new HashSet<String>(visitedPages));
void addComplete(int rc, LedgerHandle lh, long entryId, Object ctx); } public interface CloseCallback {  void closeComplete(int rc, LedgerHandle lh, Object ctx); } public interface CreateCallback {  void createComplete(int rc, LedgerHandle lh, Object ctx); } public interface OpenCallback {  public void openComplete(int rc, LedgerHandle lh, Object ctx); } public interface ReadCallback {  void readComplete(int rc, LedgerHandle lh, LedgerSequence seq, Object ctx); } }
public void ignoreMostMarkupInLiteralTable() { ParserTestHelper.assertTranslatesTo("!|''<a''|\n", tableWithCell("''&lt;a''")); ParserTestHelper.assertTranslatesTo("!|a@b.com|\n", tableWithCell("a@b.com")); }
public void setConnectionTokenFillTime(int val); public int getConnectionTokenFillCount(); public void setConnectionTokenFillCount(int val); public int getConnectionFreezeTime(); public void setConnectionFreezeTime(int val); public double getConnectionDropIncrease(); public void setConnectionDropIncrease(double val); public double getConnectionDropDecrease(); public void setConnectionDropDecrease(double val); public double getConnectionDecreaseRatio(); public void setConnectionDecreaseRatio(double val);  public void resetStatistics();  public void resetLatency();  public void resetMaxLatency();  public void resetFsyncThresholdExceedCount();  public long getNumAliveConnections();  public long getDataDirSize();  public long getLogDirSize();  public String getSecureClientPort();  public String getSecureClientAddress();  public long getTxnLogElapsedSyncTime();  public int getJuteMaxBufferSize();  public int getLastClientResponseSize();  public int getMinClientResponseSize();  public int getMaxClientResponseSize(); }
private static void createZNode(ZooKeeper zk, String path, String data) throws KeeperException, InterruptedException { try{ zk.create(path, data.getBytes(),
public void setup() throws NoSuchMethodException { this.mockery = new Mockery(); this.result = new RequestResult(); this.parameters =mockery.mock(MethodParameters.class); }
public void simpleTextFormatForPassingTest() throws Exception { request.addInput("format", "text"); doSimpleRun(passFixtureTable()); assertEquals("text/text", response.getContentType()); assertTrue(results.indexOf("\n. ") != -1); assertTrue(results.indexOf("R:1 W:0 I:0 E:0 TestPage\t(TestPage)") != -1); assertTrue(results.indexOf("1 Tests,\t0 Failures") != -1); }
public void translatesPaths() throws Exception { ParserTest.assertTranslatesTo("!path stuff", "<span class=\"meta\">classpath: stuff</span>"); ParserTest.assertTranslatesTo("!path stuff\n", "<span class=\"meta\">classpath: stuff</span>" + ParserTest.newLineRendered);
private long Maj( long x, long y, long z) { return ((x & y) ^ (x & z) ^ (y & z)); }
public boolean closeSession(long sessionId, ServerCnxn.DisconnectReason reason) { ServerCnxn cnxn = sessionMap.remove(sessionId); if (cnxn != null) { try { cnxn.close(reason); } catch (Exception e) { LOG.warn("exception during session close", e); } return true; } return false; }
public void convertView(PwEntry pw, int pos) { populateView(this, pw, pos); }
private void assertAllPacketsZero(ServerStats serverStats) { Assert.assertEquals(0L, serverStats.getPacketsSent()); Assert.assertEquals(0L, serverStats.getPacketsReceived()); }
private void waitForServiceThreadToStart() { while(running == false) Thread.yield(); }
public boolean getOOBInline() throws SocketException { return getSocketAllowUnknownMode().getOOBInline(); }
public void withoutViolations() { CustomerForValidation customer0 = new CustomerForValidation(10, "Vraptor"); assertThat(beanValidator.validate(customer0), hasSize(0)); }
public String toString() { String prefix = ""; if(mode == ABSOLUTE) prefix = "."; else if(mode == SUB_PAGE) prefix = ">"; else if(mode == BACKWARD_SEARCH) prefix = "<"; return "(" + prefix + StringUtil.join(names, ".") + ")"; }
public void asyncAddEntry(final byte[] data, final AddCallback cb, final Object ctx) throws InterruptedException { bk.mainWorkerPool.submitOrdered(ledgerId, new SafeRunnable() { @Override public void safeRun() { if (metadata.isClosed()) { LOG.warn("Attempt to add to closed ledger: " + ledgerId); cb.addComplete(BKException.Code.LedgerClosedException, LedgerHandle.this, -1, ctx); return; } long entryId = ++lastAddPushed; PendingAddOp op = new PendingAddOp(LedgerHandle.this, cb, ctx, entryId); pendingAddOps.add(op); ChannelBuffer toSend = macManager.computeDigestAndPackageForSending( entryId, lastAddConfirmed, data); op.initiate(toSend); } }); opCounterSem.acquire(); }
Collection<SocketAddress> getAvailableServers(); Collection<SocketAddress> getUnavailableServers(); void setTranscoder(Transcoder<Object> tc); Transcoder<Object> getTranscoder(); Future<Boolean> append(long cas, String key, Object val); <T> Future<Boolean> append(long cas, String key, T val, Transcoder<T> tc); Future<Boolean> prepend(long cas, String key, Object val); <T> Future<Boolean> prepend(long cas, String key, T val, Transcoder<T> tc); <T> Future<CASResponse> asyncCAS(String key, long casId, T value, Transcoder<T> tc); Future<CASResponse> asyncCAS(String key, long casId, Object value); <T> CASResponse cas(String key, long casId, T value, Transcoder<T> tc) throws OperationTimeoutException; CASResponse cas(String key, long casId, Object value) throws OperationTimeoutException; <T> Future<Boolean> add(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> add(String key, int exp, Object o); <T> Future<Boolean> set(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> set(String key, int exp, Object o); <T> Future<Boolean> replace(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> replace(String key, int exp, Object o); <T> Future<T> asyncGet(String key, Transcoder<T> tc); Future<Object> asyncGet(String key); <T> Future<CASValue<T>> asyncGets(String key, Transcoder<T> tc); Future<CASValue<Object>> asyncGets(String key); <T> CASValue<T> gets(String key, Transcoder<T> tc) throws OperationTimeoutException; CASValue<Object> gets(String key) throws OperationTimeoutException; <T> T get(String key, Transcoder<T> tc) throws OperationTimeoutException; Object get(String key) throws OperationTimeoutException; <T> Future<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); Future<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> Future<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); Future<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc) throws OperationTimeoutException; Map<String, Object> getBulk(Collection<String> keys) throws OperationTimeoutException; <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys) throws OperationTimeoutException; Map<String, Object> getBulk(String... keys) throws OperationTimeoutException; Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); long incr(String key, int by) throws OperationTimeoutException; long decr(String key, int by) throws OperationTimeoutException; Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, int by); long incr(String key, int by, long def) throws OperationTimeoutException; long decr(String key, int by, long def) throws OperationTimeoutException; Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); }
public void withoutViolations() { CustomerForValidation customer0 = new CustomerForValidation(10, "Vraptor"); Assert.assertTrue(beanValidator.validate(customer0).isEmpty()); }
void processMessage(ByteBuf buf) { assert channel.eventLoop().inEventLoop(); if (LOG.isDebugEnabled()) { LOG.debug("0x{} queuedBuffer: {}", Long.toHexString(sessionId), queuedBuffer); } if (LOG.isTraceEnabled()) { LOG.trace("0x{} buf {}", Long.toHexString(sessionId), ByteBufUtil.hexDump(buf)); } if (throttled.get()) { LOG.debug("Received message while throttled");
public void removeWatches( String path, Watcher watcher, WatcherType watcherType, boolean local, VoidCallback cb, Object ctx) { validateWatcher(watcher); removeWatches(ZooDefs.OpCode.checkWatches, path, watcher, watcherType, local, cb, ctx); }
public void testSystemStopped(TestSystem testSystem, ExecutionLog executionLog, Throwable cause); }
public void announceNumberTestsToRun(int testsToRun);
public String executionStatusHtml() throws Exception { String linkHref = getErrorLogPageName(); return executionStatusHtml(linkHref, ""); }
public void elapsedTimeShouldReferenceClockTimeWhenNotStopped() throws Exception { TimeMeasurement measurement = new TimeMeasurement(mockedClock); when(mockedClock.currentClockTimeInMillis()).thenReturn(-3L, -1L); measurement.start(); assertThat(measurement.elapsed(), is(2L)); }
public void clearSystemProperties(X509Util x509Util) { System.clearProperty(x509Util.getSslKeystoreLocationProperty()); System.clearProperty(x509Util.getSslKeystorePasswdProperty()); System.clearProperty(x509Util.getSslKeystorePasswdPathProperty()); System.clearProperty(x509Util.getSslKeystoreTypeProperty()); System.clearProperty(x509Util.getSslTruststoreLocationProperty()); System.clearProperty(x509Util.getSslTruststorePasswdProperty()); System.clearProperty(x509Util.getSslTruststorePasswdPathProperty()); System.clearProperty(x509Util.getSslTruststoreTypeProperty()); System.clearProperty(x509Util.getSslHostnameVerificationEnabledProperty()); }
Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs);  Set<String> listSaslMechanisms(); }
protected void tearDown() throws Exception { ServerStats.unregister(); LOG.info("FINISHED " + getName()); }
public void output() throws IOException { los.writeUInt(PwDbHeader.PWM_DBSIG_1); los.writeUInt(PwDbHeaderV4.DBSIG_2); los.writeUInt(PwDbHeaderV4.FILE_VERSION_32);
private MethodReplacingSearchObserver simpleMethodReplacer() { return new MethodReplacingSearchObserver(".*", "|method with no param|"); }
public void start() { LOG.info("binding to port {}", localAddress); parentChannel = bootstrap.bind(localAddress).syncUninterruptibly().channel();
protected void onResume() { super.onResume();
private void ensureXmlResultFileDoesNotExist(TestSummary counts) { XmlFormatter.setTestTime("12/5/2008 01:19:00"); String resultsFileName = String.format("%s/TestPage/20081205011900_%d_%d_%d_%d.xml", context.getTestHistoryDirectory(), counts.right, counts.wrong, counts.ignores, counts.exceptions); xmlResultsFile = new File(resultsFileName); if (xmlResultsFile.exists()) FileUtil.deleteFile(xmlResultsFile);
public boolean equals(Object o) { if (! (o instanceof PageHistoryReference)) return false; PageHistoryReference r = (PageHistoryReference) o; return StringUtils.equals(pageName, r.pageName) && time == r.time &&
protected final PatternBasedType method(String pattern) { return new PatternBasedType(pattern); }
void gotData(String key, int flags, long cas, byte[] data); } int getExpiration(); }
public void complainsIfNoConverterFound() { converters.to(DefaultConvertersTest.class, container); }
<T> T withA(Class<T> type); void start(); void stop(); Request forRequest(ServletRequest request); }
private ZooKeeper createClient(String hp) throws IOException, InterruptedException { CountdownWatcher watcher = new CountdownWatcher(); ZooKeeper zk = new ZooKeeper(hp, 30000, watcher); if(!watcher.clientConnected.await(CONNECTION_TIMEOUT, TimeUnit.MILLISECONDS)) { fail("Unable to connect to server"); } return zk; }
private static int findBranchPoint(List<String> list1, List<String> list2) { int i; for(i = 0; i < list1.size(); i++) { if(!list1.get(i).equals(list2.get(i))) break; } return Math.max(0, i - 1); }
public void acceptOutput(String output) throws Exception { testSystemListener.acceptOutput(output); }
public void shouldThrowExceptionWhenUnableToParse() { mockery.checking(new Expectations() {{ exactly(2).of(request).getAttribute("javax.servlet.jsp.jstl.fmt.locale.request"); will(returnValue("pt_br")); }}); converter.convert("a,10/06/2008/a/b/c", Calendar.class, errors, bundle); }
public void withFieldsAndFiles() throws Exception { Part f0 = new VraptorPart("myField0", "the value"); Part f1 = new VraptorPart("myField1", "other value"); Part f2 = new VraptorPart("myFile0", "text/plain", "file1.txt", "vraptor3".getBytes()); Part f3 = new VraptorPart("myFile1", "text/plain", "file2.txt", "vraptor3".getBytes()); when(request.getContentType()).thenReturn("multipart/form-data"); when(request.getMethod()).thenReturn("POST"); when(request.getParts()).thenReturn(Arrays.asList(f0, f1, f2, f3)); interceptor.intercept(stack, method, instance); verify(parameters, atLeast(3)).setParameter(anyString(), anyString()); verify(parameters).setParameter("myField0", "the value"); verify(parameters).setParameter("myField1", "other value"); verify(parameters).setParameter("myFile0", "myFile0"); verify(parameters).setParameter("myFile1", "myFile1"); verify(request).setAttribute(eq("myFile0"), any(UploadedFile.class)); verify(request).setAttribute(eq("myFile1"), any(UploadedFile.class)); }
public void consume(ByteString topic, ByteString subscriberId, MessageSeqId messageSeqId) throws ClientNotSubscribedException { if (logger.isDebugEnabled()) logger.debug("Calling consume for topic: " + topic.toStringUtf8() + ", subscriberId: " + subscriberId.toStringUtf8() + ", messageSeqId: " + messageSeqId); TopicSubscriber topicSubscriber = new TopicSubscriber(topic, subscriberId);
private HtmlPage makeHtml(String name, WikiPage page, FitNesseContext context) { PageData pageData = page.getDataVersion(version); HtmlPage html = context.pageFactory.newPage(); html.setTitle("Version " + version + ": " + name); html.setPageTitle(new PageTitle("Version " + version, PathParser.parse(resource)));
protected void doClose() { }  protected Object retryOperation(ZooKeeperOperation operation) throws KeeperException, InterruptedException { KeeperException exception = null; for (int i = 0; i < retryCount; i++) { try { return operation.execute(); } catch (KeeperException.SessionExpiredException e) { LOG.warn("Session expired for: " + zookeeper + " so reconnecting due to: " + e, e); throw e; } catch (KeeperException.ConnectionLossException e) { if (exception == null) { exception = e; } LOG.debug("Attempt {} failed with connection loss so attempting to reconnect", i, e); retryDelay(i); } } throw exception; }  protected void ensurePathExists(String path) { ensureExists(path, null, acl, CreateMode.PERSISTENT); }  protected void ensureExists( final String path, final byte[] data, final List<ACL> acl, final CreateMode flags) { try { retryOperation(() -> { Stat stat = zookeeper.exists(path, false); if (stat != null) { return true; } zookeeper.create(path, data, acl, flags); return true; }); } catch (KeeperException | InterruptedException e) { LOG.warn("Caught: " + e, e); } }  protected boolean isClosed() { return closed.get(); }  protected void retryDelay(int attemptCount) { if (attemptCount > 0) { try { Thread.sleep(attemptCount * retryDelay); } catch (InterruptedException e) { LOG.debug("Failed to sleep", e); } } } }
public void testGetStreamMode() { assertEquals(StreamMode.CHECKED, SnapStream.getStreamMode("snapshot.180000e3a2"), "expected to return un-compressed stream"); assertEquals(StreamMode.SNAPPY, SnapStream.getStreamMode("snapshot.180000e3a2.snappy"), "expected to return snappy stream"); assertEquals(StreamMode.GZIP, SnapStream.getStreamMode("snapshot.180000e3a2.gz"), "expected to return gzip stream"); }
public static Class<JspView> jsp() { return JspView.class; }
Result include(String key, Object value);  Result include(Object value);  <T extends View> T use(Class<T> view);  Result on(Class<? extends Exception> exception);  boolean used();  Map<String, Object> included();  void forwardTo(String uri);  void redirectTo(String uri);  <T> T forwardTo(Class<T> controller);  <T> T redirectTo(Class<T> controller);  <T> T of(Class<T> controller);  <T> T redirectTo(T controller);  <T> T forwardTo(T controller);  <T> T of(T controller);  void nothing();  void notFound();  void permanentlyRedirectTo(String uri);  <T> T permanentlyRedirectTo(Class<T> controller);  <T> T permanentlyRedirectTo(T controller); }
public void processResult(int rc, String path, Object ctx) { synchronized (ctx) { ((AtomicInteger) ctx).set(4);
public void setParentForVariables(WikiPage parent); public WikiPage addChildPage(String name) throws Exception; public boolean hasChildPage(String name) throws Exception; public WikiPage getChildPage(String name) throws Exception; public void removeChildPage(String name) throws Exception; public List<WikiPage> getChildren() throws Exception; public String getName() throws Exception; public PageData getData() throws Exception; public PageData getDataVersion(String versionName) throws Exception; public VersionInfo commit(PageData data) throws Exception; public PageCrawler getPageCrawler();
public void registerExtraParametersFromAcessedUrlWithGreedyAndDottedParameters() throws SecurityException, NoSuchMethodException { DefaultParametersControl control = new DefaultParametersControl("/clients/{path.to.file*}", converters, evaluator); control.fillIntoRequest("/clients/my/path/to/file", request); verify(request).setParameter("path.to.file", new String[] {"my/path/to/file"}); }
HashAlgorithm getHashAlg();  long getMaxReconnectDelay();  AuthDescriptor getAuthDescriptor();  int getTimeoutExceptionThreshold();  MetricType enableMetrics();  MetricCollector getMetricCollector();  long getAuthWaitTime(); }
public Maybe<Symbol> parse(Symbol current, Parser parser) { SymbolType type = current.getType(); int startOffset = current.getStartOffset(); String literal = parser.parseLiteral(closeType()); if (parser.atEnd()) return Symbol.nothing; int endOffset = parser.getOffset(); return new Maybe<Symbol>(new Symbol(type, literal, startOffset, endOffset)); }
public void testUncaughtExceptionInNettyThread() throws Exception { SynchronousQueue<Throwable> queue = new SynchronousQueue<Throwable>(); RecordingUncaughtExceptionHandler uncaughtExceptionHandler = new RecordingUncaughtExceptionHandler(queue); final int port = 9876; PubSubServer server = startServer(uncaughtExceptionHandler, port, new TopicManagerInstantiator() { @Override public TopicManager instantiateTopicManager() throws IOException { return new AbstractTopicManager(new ServerConfiguration(), Executors.newSingleThreadScheduledExecutor()) { @Override protected void realGetOwner(ByteString topic, boolean shouldClaim, Callback<HedwigSocketAddress> cb, Object ctx) { throw new RuntimeException("this exception should be uncaught"); } @Override protected void postReleaseCleanup(ByteString topic, Callback<Void> cb, Object ctx) { } }; } }); runPublishRequest(port); assertEquals(RuntimeException.class, queue.take().getClass()); server.shutdown(); }
public Object parse(String s) { return ("null".equals(s))? null : new Long(Long.parseLong(s)); }
public void canProvideVRaptor2SpecificRequestScopedComponents() { checkAvailabilityFor(false, ExecuteAndViewInterceptor.class, HibernateValidatorPluginInterceptor.class, ValidatorInterceptor.class, ViewInterceptor.class, ComponentInfoProvider.class,
public void lineUpTheTables() { for (int currentMatch = 0; currentMatch < matchedTables.size(); currentMatch++) lineUpMatch(currentMatch); lineUpLastRow();
public void testCreateEphemeral(boolean localSessionEnabled) throws Exception { if (localSessionEnabled) { qu.enableLocalSession(true); } qu.startAll(); QuorumPeer leader = qu.getLeaderQuorumPeer(); ZooKeeper zk = ClientBase.createZKClient(qu.getConnectString(leader)); CreateRequest createRequest = new CreateRequest("/impossible", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL.toFlag()); ByteArrayOutputStream baos = new ByteArrayOutputStream(); BinaryOutputArchive boa = BinaryOutputArchive.getArchive(baos); createRequest.serialize(boa, "request"); ByteBuffer bb = ByteBuffer.wrap(baos.toByteArray());
public static String tableWithCells(String[] cellContent) { StringBuilder cells = new StringBuilder(); for (String cell : cellContent) { if (cells.length() > 0) cells.append("</td>").append(HtmlElement.endl).append("\t\t<td>"); cells.append(cell); } return tableWithCellAndRow(cells.toString(), "<tr>"); }
public void exceptionOccurred(Throwable e) { exceptions.add(e); }
public void pageHistoryLinkIsIncluded() throws Exception { responder.turnOffChunking(); doSimpleRun(passFixtureTable()); assertSubString("<a href=\"TestPage?pageHistory\"", results); assertSubString("Page History", results); }
public static String unescape(String s) { int i = -1, j; while((i = s.indexOf('&', i + 1)) >= 0) { if((j = s.indexOf(';', i + 1)) > 0) { String from = s.substring(i + 1, j).toLowerCase(); String to = null; if((to = replacement(from)) != null) { s = s.substring(0, i) + to + s.substring(j + 1); } } } return s; }
public static Importer createImporter(InputStream is, File streamDir, boolean debug) throws InvalidDBSignatureException, IOException { int sig1 = LEDataInputStream.readInt(is); int sig2 = LEDataInputStream.readInt(is); if ( PwDbHeaderV3.matchesHeader(sig1, sig2) ) { if (debug) { return new ImporterV3Debug(); } return new ImporterV3(); } else if ( PwDbHeaderV4.matchesHeader(sig1, sig2) ) { return new ImporterV4(streamDir); } throw new InvalidDBSignatureException();
public void canUseBangToCallFunction() throws Exception { makeDecisionTableAndBuildInstructions( "|DT:fixture|argument|\n" + "|var|func!|\n" + "|3|5|\n" + "|7|9|\n"); List<Object> expectedInstructions = list( list("decisionTable_id_0", "make", "decisionTable_id", "fixture", "argument"), list("decisionTable_id_1", "call", "decisionTable_id", "table", list(list("var", "func!"), list("3", "5"), list("7", "9"))), list("decisionTable_id_2", "call", "decisionTable_id", "reset"), list("decisionTable_id_3", "call", "decisionTable_id", "setVar", "3"), list("decisionTable_id_4", "call", "decisionTable_id", "execute"), list("decisionTable_id_5", "call", "decisionTable_id", "func"), list("decisionTable_id_6", "call", "decisionTable_id", "reset"), list("decisionTable_id_7", "call", "decisionTable_id", "setVar", "7"), list("decisionTable_id_8", "call", "decisionTable_id", "execute"), list("decisionTable_id_9", "call", "decisionTable_id", "func") ); assertEquals(expectedInstructions.toString(), instructions.toString()); }
private void writeObject(String name, String keyName, String keyValue, String valueName, String valueValue) throws IllegalArgumentException, IllegalStateException, IOException { xml.startTag(null, name); xml.startTag(null, keyName); xml.text(safeXmlString(keyValue)); xml.endTag(null, keyName); xml.startTag(null, valueName); xml.text(safeXmlString(valueValue)); xml.endTag(null, valueName); xml.endTag(null, name); }
public void config() { this.mockery = new Mockery(); this.method = mockery.mock(ResourceMethod.class); this.request = mockery.mock(HttpServletRequest.class); this.resource = mockery.mock(ResourceClass.class); }
public void setup() { this.mockery = new Mockery(); this.request = mockery.mock(HttpServletRequest.class); this.container = mockery.mock(Container.class); }
public void testGetPageTypesFromInput() { assertPageTypesMatch(TEST); assertPageTypesMatch(TEST, STATIC); assertPageTypesMatch(TEST, SUITE, STATIC);
@Test public void scansContents() { ParserTestHelper.assertScansTokenType("!contents", "Contents", true); ParserTestHelper.assertScansTokenType(" !contents", "Contents", false); ParserTestHelper.assertScansTokenType("!note !contents", "Contents", true); ParserTestHelper.assertScansTokenType("| !contents|\n", "Contents", true); }
public void start(Descriptor descriptor) { String testRunner = descriptor.getTestRunner(); String command = buildCommand(descriptor.getCommandPattern(), testRunner, classPath); Map<String, String> environmentVariables = createClasspathEnvironment(classPath); CommandRunningFitClient.CommandRunningStrategy runningStrategy = fastTest ? new CommandRunningFitClient.InProcessCommandRunner(testRunner) : new CommandRunningFitClient.OutOfProcessCommandRunner(command, environmentVariables); this.client = new CommandRunningFitClient(this, context.port, context.socketDealer, runningStrategy); setExecutionLog(new ExecutionLog(page, client.commandRunner)); client.start(); }
public void withoutViolations() { CustomerJSR303 customer0 = new CustomerJSR303(10, "Vraptor"); Assert.assertTrue(jsr303Validator.validate(customer0).isEmpty()); }
public void visitAttribute(final Attribute attr) { attr.next = attrs; attrs = attr; }
public void setUp() throws Exception { qb.setUp(true); cht.hostPort = qb.hostPort; cht.setUpAll(); }
OperationFactory getOperationFactory();  long getOperationTimeout();  boolean isDaemon();  boolean useNagleAlgorithm();  Collection<ConnectionObserver> getInitialObservers();  FailureMode getFailureMode();  Transcoder<Object> getDefaultTranscoder();  boolean shouldOptimize();  int getReadBufSize();  HashAlgorithm getHashAlg();  long getMaxReconnectDelay();  AuthDescriptor getAuthDescriptor();  int getTimeoutExceptionThreshold();  MetricType enableMetrics();  MetricCollector getMetricCollector();  long getAuthWaitTime(); }
protected Boolean doInBackground() throws Exception { tree.setModel(new DefaultTreeModel(new ZooInspectorTreeNode( "/", null))); return true; }
public int read(ByteBuffer dst, long position) throws IOException {
private boolean dontCreateNonExistentPage(Request request) { String dontCreate = request.getInput("dontCreatePage"); return dontCreate != null && (dontCreate.isEmpty() || Boolean.parseBoolean(dontCreate)); }
private void receiveMessage(ByteBuf message) { assert channel.eventLoop().inEventLoop(); try { while(message.isReadable() && !throttled.get()) {
public void testAsyncDecrementNonExistent() throws Exception { String k="async-decr-non-existent"; Future<Long> f = client.asyncDecr(k, 1); assertEquals(-1, (long)f.get()); }
private List<String> getReferencedPages() throws IOException { String rerunPageContent = FileUtil.getFileContent(targetFile); assertTrue(rerunPageContent.startsWith("---\nHelp: ")); WikiPage root = InMemoryPage.makeRoot("RooT"); WikiPage page = WikiPageUtil.addPage(root, PathParser.parse("PageName"), rerunPageContent); return WikiPageUtil.getXrefPages(page); }
protected String contentFrom(FitNesseContext context, Request request, WikiPage requestedPage) { return prepareResponseDocument(context).html(request); }
public void produce(DataConsumer receiver) throws IOException { } }
private void extendExistingRows(Table table, List<List<Object>> tableResults) { for (int row = 1; row < table.getRowCount(); row++) extendRow(table, row, tableResults.get(row - 1));
public int compare(File o1, File o2) { long z1 = getZxidFromName(o1.getName(), prefix); long z2 = getZxidFromName(o2.getName(), prefix); int result = z1 < z2 ? -1 : (z1 > z2 ? 1 : 0); return ascending ? result : -result; }
public TokenMatch makeMatch(ScanString input) { if (input.startsLine() && input.startsWith("!")) { int blank = input.find(new char[] {' '}, 1); if (blank > 1) { String content = input.substring(1, blank); if (renderers.containsKey(content)) { return new TokenMatch(new LineToken(content), content.length() + 2); } } } return TokenMatch.noMatch; }
public String toHtml(Translator translator, Symbol symbol) { String body = translator.translate(symbol.childAt(0)); Maybe<String> result = new FormattedExpression(body).evaluate(); if (result.isNothing()) return translator.formatMessage(result.because()); return result.getValue().toString(); }
public void setup() { this.mockery =new Mockery(); this.request = mockery.mock(HttpServletRequest.class); this.session = mockery.mock(HttpSession.class); this.context= mockery.mock(ServletContext.class); final RequestInfo webRequest = new RequestInfo(context, request, null); this.converter = new LocaleBasedCalendarConverter(webRequest); this.errors = new ArrayList<ValidationMessage>(); this.bundle = ResourceBundle.getBundle("messages"); }
public boolean hasChildPage(String pageName) throws Exception { return children.containsKey(pageName); }
public void withFieldsOnlyWithInvalidCharset() throws Exception { Part field0 = new VraptorPart("myField0", "the value"); Part field1 = new VraptorPart("myField1", "other value"); when(request.getCharacterEncoding()).thenReturn("www"); when(request.getContentType()).thenReturn("multipart/form-data"); when(request.getMethod()).thenReturn("POST"); when(request.getParts()).thenReturn(Arrays.asList(field0, field1)); interceptor.intercept(stack, method, instance); verify(parameters).setParameter("myField0", "the value"); verify(parameters).setParameter("myField1", "other value"); }
public void makeDeb() throws PackagingException { if (control == null || !control.isDirectory()) { throw new PackagingException( "\"" + control + "\" is not a valid 'control' directory)"); } if (changesIn != null) { if (!changesIn.isFile() || !changesIn.canRead()) { throw new PackagingException( "The 'changesIn' setting needs to point to a readable file. " + changesIn + " was not found/readable."); } if (changesOut == null) { throw new PackagingException( "A 'changesIn' without a 'changesOut' does not make much sense."); } if (!isPossibleOutput(changesOut)) { throw new PackagingException( "Cannot write the output for 'changesOut' to " + changesOut); } if (changesSave != null && !isPossibleOutput(changesSave)) { throw new PackagingException( "Cannot write the output for 'changesSave' to " + changesSave); } } else { if (changesOut != null || changesSave != null) { throw new PackagingException( "The 'changesOut' or 'changesSave' settings may only be used when there is a 'changesIn' specified."); } } if (!"gzip".equals(compression) && !"bzip2".equals(compression) && !"none".equals(compression)) { throw new PackagingException("The compression method '" + compression + "' is not supported"); } if (deb == null) { throw new PackagingException( "You need to specify where the deb file is supposed to be created."); } final File[] controlFiles = control.listFiles(); final DataProducer[] data = new DataProducer[dataProducers.size()]; dataProducers.toArray(data); final Processor processor = new Processor(console, variableResolver); final PackageDescriptor packageDescriptor; try { console.println("Creating debian package: " + deb); packageDescriptor = processor.createDeb(controlFiles, data, deb, compression); } catch (Exception e) { throw new PackagingException("Failed to create debian package " + deb, e); } final TextfileChangesProvider changesProvider; try { if (changesOut == null) { return; } console.println("Creating changes file: " + changesOut);
public void testComplete(TestPage testPage, TestSummary testSummary) throws IOException { } @Override public void testSystemStopped(TestSystem testSystem, Throwable cause) { } @Override public void testAssertionVerified(Assertion assertion, TestResult testResult) { } @Override public void testExceptionOccurred(Assertion assertion, ExceptionResult exceptionResult) { } } }
public void carriageReturnsShouldNotMatterIfPresentOnPage() throws Exception { WikiPage page = crawler.addPage(rootPage, PathParser.parse("TestPage"), "''italics''\r\n\r'''bold'''\r\n\r"); PageData data = page.getData(); String html = data.getHtml(); assertEquals("<i>italics</i>" + ParserTest.newLineRendered
public String pathFor(ResourceMethod method, String result) { return "fixed"; }
public void testOrderWithDifferentPrefixIncludingSessionId() throws Exception { String[] names = { "x-242681582799028564-0000000002", "x-170623981976748329-0000000003", "x-98566387950223723-0000000001" }; String[] expected = { "x-98566387950223723-0000000001", "x-242681582799028564-0000000002", "x-170623981976748329-0000000003" }; assertOrderedNodeNames(names, expected); }
public void testValidatePath_0x7e() {
public void newTestStarted(WikiPage newTest, TimeMeasurement timeMeasurement) throws Exception { String relativeName = getRelativeName(newTest); PageCrawler pageCrawler = getPage().getPageCrawler(); WikiPagePath fullPath = pageCrawler.getFullPath(newTest); String fullPathName = PathParser.render(fullPath); announceStartNewTest(relativeName, fullPathName); }
private Stat createWithStatVerifyResult(String newName) throws KeeperException, InterruptedException { assertNull(zk.exists(newName, false), "Node existed before created"); Stat stat = new Stat(); zk.create(newName, newName.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.CONTAINER, stat); validateCreateStat(stat, newName); Stat referenceStat = zk.exists(newName, false); assertNotNull(referenceStat, "Node was not created as expected"); assertEquals(referenceStat, stat); return stat; }
public void setConnectionFreezeTime(int val); public double getConnectionDropIncrease(); public void setConnectionDropIncrease(double val); public double getConnectionDropDecrease(); public void setConnectionDropDecrease(double val); public double getConnectionDecreaseRatio(); public void setConnectionDecreaseRatio(double val); public int getRequestThrottleLimit(); public void setRequestThrottleLimit(int requests); public int getRequestThrottleStallTime(); public void setRequestThrottleStallTime(int time); public boolean getRequestThrottleDropStale(); public void setRequestThrottleDropStale(boolean drop); public boolean getRequestStaleLatencyCheck(); public void setRequestStaleLatencyCheck(boolean check); public boolean getRequestStaleConnectionCheck(); public void setRequestStaleConnectionCheck(boolean check);  public void resetStatistics();  public void resetLatency();  public void resetMaxLatency();  public void resetFsyncThresholdExceedCount();  public long getNumAliveConnections();  public long getDataDirSize();  public long getLogDirSize();  public String getSecureClientPort();  public String getSecureClientAddress();  public long getTxnLogElapsedSyncTime();  public int getJuteMaxBufferSize();  public int getLastClientResponseSize();  public int getMinClientResponseSize();  public int getMaxClientResponseSize(); public long getFlushDelay(); public void setFlushDelay(long delay); public long getMaxWriteQueuePollTime(); public void setMaxWriteQueuePollTime(long delay); public int getMaxBatchSize(); public void setMaxBatchSize(int size); }
public long incr(String key, int by, long def) { return mutateWithDefault(Mutator.incr, key, by, def, 0); }
public void testComplete(TestSummary testSummary) throws IOException { for (TestSystemListener listener : listeners) listener.testComplete(testSummary);
String toString(); interface CellContentSubstitution { String substitute(int col, int row, String content) throws SyntaxError; } }
public <T> T onErrorRedirectTo(Class<T> controller) { return onErrorUse(logic()).redirectTo(controller); }
public String getUserpass(String headerValue) throws Exception { String encodedUserpass = headerValue.substring(6); return Base64.decode(encodedUserpass); }
public boolean matchesFor(SymbolType symbolType) { return symbolType == SymbolType.PlainTextCellSeparator; }
public void removeListConverter() { ConverterRegistry.addConverter(List.class, standardConverter); }
public static Collection<Object[]> data() { return Arrays.<Object[]>asList( new Object[] { "8", "threadid=1", 11221, 13913 },
double getConnectionDropDecrease(); void setConnectionDropDecrease(double val); double getConnectionDecreaseRatio(); void setConnectionDecreaseRatio(double val); int getCommitProcMaxReadBatchSize(); void setCommitProcMaxReadBatchSize(int size); int getCommitProcMaxCommitBatchSize(); void setCommitProcMaxCommitBatchSize(int size); int getRequestThrottleLimit(); void setRequestThrottleLimit(int requests); int getRequestThrottleStallTime(); void setRequestThrottleStallTime(int time); boolean getRequestThrottleDropStale(); void setRequestThrottleDropStale(boolean drop); boolean getRequestStaleLatencyCheck(); void setRequestStaleLatencyCheck(boolean check); boolean getRequestStaleConnectionCheck(); void setRequestStaleConnectionCheck(boolean check);  void resetStatistics();  void resetLatency();  void resetMaxLatency();  void resetFsyncThresholdExceedCount();  long getNumAliveConnections();  long getDataDirSize();  long getLogDirSize();  String getSecureClientPort();  String getSecureClientAddress();  long getTxnLogElapsedSyncTime();  int getJuteMaxBufferSize();  int getLastClientResponseSize();  int getMinClientResponseSize();  int getMaxClientResponseSize(); long getFlushDelay(); void setFlushDelay(long delay); long getMaxWriteQueuePollTime(); void setMaxWriteQueuePollTime(long delay); int getMaxBatchSize(); void setMaxBatchSize(int size); }
public void testJMXBeanAfterRoleChange() throws Exception { qu = new QuorumUtil(1);
public void destroy() { mockery.assertIsSatisfied(); RequestContextHolder.resetRequestAttributes(); }
public void setExecutionLogAndTrackingId(String stopResponderId, CompositeExecutionLog log) throws Exception { } public void testComplete(WikiPage test, TestSummary testSummary) throws Exception { timeMeasurement.stop(); recordTestResult(new WikiPagePath(test).toString(), testSummary, timeMeasurement.elapsed()); } public void testOutputChunk(String output) throws Exception { } public void testSystemStarted(TestSystem testSystem, String testSystemName, String testRunner) throws Exception { } }
private void parse(ClassWriter cw, Class<?> type, StringBuilder valueLists, String newTypeName, String fieldName) { String definition = CONVERTER.extractTypeDefinition(type); String genericDefinition = null; parse(cw, valueLists, newTypeName, definition, genericDefinition, fieldName, loadFor(type), returnFor(type)); if (valueLists.length() != 0) { valueLists.append(','); } if (type.isPrimitive()) { valueLists.append(wrapperCodeFor(type, fieldName + "_"));
private static String getACLs(Request request) throws IOException { SetACLRequest setACLRequest = new SetACLRequest(); deserialize(request, setACLRequest); return ZKUtil.aclToString(setACLRequest.getAcl()); }
private void clearServersForChannel(Channel c) { HashMap<String, ServerControl.TestServer> map = serverMap.get(c); serverMap.remove(map); for (ServerControl.TestServer t : map.values()) { t.kill(); } map.clear(); }
public void testRunnerDefault() throws Exception { String pageText = "!define TEST_SYSTEM {slim}\n"; WikiPage page = makeTestPage(pageText); Descriptor defaultDescriptor2 = ClientBuilder.getDescriptor(page, false); assertEquals("fitnesse.slim.SlimService", defaultDescriptor2.getTestRunner()); Descriptor defaultDescriptor3 = ClientBuilder.getDescriptor(page, true); assertEquals("fitnesse.slim.SlimService", defaultDescriptor3.getTestRunner()); String specifiedPageText = "!define REMOTE_DEBUG_RUNNER {Different runner}"; WikiPage specifiedPage = makeTestPage(specifiedPageText); Descriptor specifiedDescriptor = ClientBuilder.getDescriptor(specifiedPage, true); assertEquals("Different runner", specifiedDescriptor.getTestRunner()); }
public void canEvaluateReturnValuesAndColorizeTableForMultipleCallsToSameFunction() throws Exception { makeDynamicDecisionTableAndBuildInstructions(dynamicDecisionTableWithSameFunctionMultipleTimes); int n = 0; Map<String, Object> pseudoResults = SlimCommandRunningClient.resultToMap( asList( asList(id(n++), "OK"), asList(id(n++), VOID_TAG), asList(id(n++), VOID_TAG),
public void shoudRegisterConvertersInConverters() { Converters converters = container.instanceFor(Converters.class); Converter<?> converter = converters.to(Foo.class, container); assertThat(converter, is(instanceOf(DummyConverter.class))); }
private List<String> manyClientOps(final ZooKeeper zk, final CountDownLatch doPurge, int thCount, final String prefix) { Thread[] ths = new Thread[thCount]; final List<String> znodes = Collections .synchronizedList(new ArrayList<String>()); final CountDownLatch finished = new CountDownLatch(thCount); for (int indx = 0; indx < thCount; indx++) { final String myprefix = prefix + "-" + indx; Thread th = new Thread() { public void run() { for (int i = 0; i < 1000; i++) { try { String mynode = myprefix + "-" + i; znodes.add(mynode); zk.create(mynode, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); } catch (Exception e) { LOG.error("Unexpected exception occured!", e); } if (i == 200) { doPurge.countDown(); } } finished.countDown(); }; }; ths[indx] = th; } for (Thread thread : ths) { thread.start(); } try { Assert.assertTrue("ZkClient ops is not finished!", finished.await(OP_TIMEOUT_IN_MILLIS, TimeUnit.MILLISECONDS)); } catch (InterruptedException ie) { LOG.error("Unexpected exception occured!", ie); Assert.fail("Unexpected exception occured!"); } return znodes; }
public void setUp() throws Exception { mockery = new VRaptorMockery(); provider = mockery.mock(ParameterNameProvider.class); deserializer = new XStreamXMLDeserializer(provider); DefaultResourceClass resourceClass = new DefaultResourceClass(DogController.class); woof = new DefaultResourceMethod(resourceClass, DogController.class.getDeclaredMethod("woof")); bark = new DefaultResourceMethod(resourceClass, DogController.class.getDeclaredMethod("bark", Dog.class)); jump = new DefaultResourceMethod(resourceClass, DogController.class.getDeclaredMethod("jump", Dog.class, Integer.class)); dropDead = new DefaultResourceMethod(resourceClass, DogController.class.getDeclaredMethod("dropDead", Integer.class, Dog.class)); }
public boolean addAll(Collection<? extends E> arg0) { throw new UnsupportedOperationException(); }
private long mutate(MutatorOperation.Mutator m, String key, int by) { final AtomicLong rv=new AtomicLong(); final CountDownLatch latch=new CountDownLatch(1); addOp(key, new MutatorOperation(m, key, by, new OperationCallback() { public void receivedStatus(String val) { rv.set(new Long(val==null?"-1":val)); } public void complete() { latch.countDown(); }})); try { latch.await(); } catch (InterruptedException e) { throw new RuntimeException("Interrupted", e); } getLogger().debug("Mutation returned %s", rv); return rv.get(); }
String apply(String[] params) throws IOException { String result = null; if (isDefault) { if (defaultRealm.equals(params[0])) { result = params[1]; } } else if (params.length - 1 == numOfComponents) { String base = replaceParameters(format, params); if (match == null || match.matcher(base).matches()) { if (fromPattern == null) { result = base; } else { result = replaceSubstitution(base, fromPattern, toPattern, repeat); } } } if (result != null && nonSimplePattern.matcher(result).find()) { throw new NoMatchingRule("Non-simple name " + result + " after auth_to_local rule " + this); } return result; }
public void normalSuiteRunProducesTestResultFile() throws Exception { context.shouldCollectHistory = true; TestSummary counts = new TestSummary(2,0,0,0); XmlFormatter.setTestTime("12/5/2008 01:19:00"); String resultsFileName = String.format("%s/SuitePage/20081205011900_%d_%d_%d_%d.xml", context.getTestHistoryDirectory(), counts.getRight(), counts.getWrong(), counts.getIgnores(), counts.getExceptions()); File xmlResultsFile = new File(resultsFileName); if (xmlResultsFile.exists()) xmlResultsFile.delete(); addTestToSuite("SlimTest", simpleSlimDecisionTable); String results = runSuite(); assertTrue(resultsFileName, xmlResultsFile.exists()); FileInputStream xmlResultsStream = new FileInputStream(xmlResultsFile); Document xmlDoc = XmlUtil.newDocument(xmlResultsStream); xmlResultsStream.close(); xmlResultsFile.delete(); }
public void tearDown() throws Exception { } public void testTranslation1() throws Exception { String wikiText = "!c !1 This is a WidgetRoot\n" + "\n" + "''' ''Some Bold and Italic text'' '''\n"; String html = "<div class=\"centered\"><h1>This is a <a href=\"WidgetRoot\">WidgetRoot</a></h1></div>" + "<br>" + "<b> <i>Some Bold and Italic text</i> </b><br>"; assertEquals(html, translate(wikiText, page)); } public void testHtmlEscape() throws Exception { String wikiText = "<h1>this \"&\" that</h1>"; String html = "&lt;h1&gt;this \"&amp;\" that&lt;/h1&gt;"; assertEquals(html, translate(wikiText, new WikiPageDummy())); } public void testTableHtml() throws Exception { String wikiText = "|this|is|a|table|\n|that|has|four|columns|\n"; String html = "<table border=\"1\" cellspacing=\"0\">\n<tr><td>this</td>" + HtmlElement.endl + "<td>is</td>" + HtmlElement.endl + "<td>a</td>" + HtmlElement.endl + "<td>table</td>" + HtmlElement.endl + "</tr>\n" + "<tr><td>that</td>" + HtmlElement.endl + "<td>has</td>" + HtmlElement.endl + "<td>four</td>" + HtmlElement.endl + "<td>columns</td>" + HtmlElement.endl + "</tr>\n</table>\n"; assertEquals(html, translate(wikiText, new WikiPageDummy())); } private static String translate(String value, WikiPage source) throws Exception { WidgetRoot page = new WidgetRoot(value, source); return page.render(); } }
public int size() { int size = 0; for (BitHashSet watches : pathWatches.values()) { size += watches.size(); } return size; }
public void shouldReturnNullIfNotFound() throws SecurityException, NoSuchMethodException { final ResourceClass resource = mockery.resource(NonVRaptorComponent.class); this.router.register(resource); assertThat(router.parse("/NonVRaptorComponent/name", HttpMethod.POST, request), is(nullValue())); mockery.assertIsSatisfied(); }
public Tree toTree();
public void testDataDirAndDataLogDir() throws Exception { File dataDir = createEmptyTestDir(); File dataLogDir = createEmptyTestDir();
void addOp(Operation op);  int getSelectionOps();  ByteBuffer getRbuf();  ByteBuffer getWbuf();  SocketAddress getSocketAddress();  boolean isActive();  void reconnecting();  void connected();  int getReconnectCount();  void registerChannel(SocketChannel ch, SelectionKey selectionKey);  void setChannel(SocketChannel to);  SocketChannel getChannel();  void setSk(SelectionKey to);  SelectionKey getSk();  int getBytesRemainingToWrite();  int writeSome() throws IOException; }
public void testPageMatchWithEmptySuites() throws Exception { Map<String, Boolean> requestInputs = new HashMap<String, Boolean>(); searcher = new AttributeWikiPageFinder(this, Arrays.asList(TEST), requestInputs, ""); assertTrue(searcher.pageMatches(page)); setPageProperty(page, "Suites", "SuiteTest"); assertFalse(searcher.pageMatches(page)); }
public void fatal(Object message) { fatal(message, null); }
public void testLinkNotChanged() { final String LINK_WIDGET = "http://PageTwo"; checkChangesOnPageOne(LINK_WIDGET, LINK_WIDGET); }
public void testUploadingTwoFiles() throws Exception { String content = "-----------------------------7d32df3a80058\r\n" + "Content-Disposition: form-data; name=\"file\"; filename=\"C:\\test.txt\"\r\n" + "Content-Type: text/plain\r\n" + "\r\n" + "test\r\n" + "-----------------------------7d32df3a80058\r\n" + "Content-Disposition: form-data; name=\"file2\"; filename=\"C:\\test2.txt\"\r\n" + "Content-Type: text/plain\r\n" + "\r\n" + "test2\r\n" + "-----------------------------7d32df3a80058--\r\n"; appendToMessage("GET /request-uri HTTP/1.1\r\n"); appendToMessage("Content-Length: " + content.length() + "\r\n"); appendToMessage("Content-Type: multipart/form-data; boundary=---------------------------7d32df3a80058\r\n"); appendToMessage("\r\n"); appendToMessage(content); parseMessage(); testUploadedFile("file", "C:\\test.txt", "text/plain", "test"); testUploadedFile("file2", "C:\\test2.txt", "text/plain", "test2"); }
public void testError() throws FitParseException { fixture.exception(cell, new FitFailureException("")); assertEquals("e",code()); }
protected MultipleTestsRunner newMultipleTestsRunner(List<WikiPage> pages) {
void onEachDir( String dirname, String linkname, String user, long uid, String group, long gid, int mode, long size ) throws IOException; void onEachFile( InputStream input, TarArchiveEntry entry ) throws IOException; void onEachLink( TarArchiveEntry entry ) throws IOException; }
@Test public void topPageSibling() { assertTopPage("<a href=\"TestSibling.html\">TestSibling</a>", "TestSibling"); }
public static boolean isNameParameterized(String firstNameCell) { Pattern regPat = Pattern.compile(underscorePattern); Matcher underscoreMatcher = regPat.matcher(firstNameCell); return underscoreMatcher.find(); }
private void initFromJavaSystemProperties() { setProperty(ZOOKEEPER_REQUEST_TIMEOUT, System.getProperty(ZOOKEEPER_REQUEST_TIMEOUT)); }
public void shouldSortBasedOnPackageNamesLessPriorityToCaelumMoreToRestfulieInitialList3rdPartyLast() { List<Serialization> serializers = new ArrayList<Serialization>(); serializers.add(new XStreamXMLSerialization(null, null, null)); serializers.add(new XStreamJSONSerialization(null, null, null)); serializers.add(new HTMLSerialization(null, null)); serializers.add(new RestfulSerialization(null, null, null, null, null)); serializers.add(new DumbSerialization()); Collections.sort(serializers, new PackageComparator()); Assert.assertEquals("br.com.caelum.vraptor.other.pack4ge", serializers.get(0).getClass().getPackage().getName()); Assert.assertEquals("br.com.caelum.vraptor.restfulie.serialization", serializers.get(1).getClass().getPackage().getName()); }
private long delete(String path) throws InterruptedException, KeeperException { client.delete(path, -1); int lastSlash = path.lastIndexOf('/'); String parent = (lastSlash == 0) ? "/" : path.substring(0, lastSlash);
void checking(Validations rules); Validator onError(); <T> T goTo(Class<T> type); void add(Message message); void validate(); }
public String toHtml(Translator translator, Symbol symbol) { HtmlTag result = new HtmlTag("span", "variable defined: " + translator.translate(symbol.childAt(0)) + "=" + translator.translate(symbol.childAt(1))); result.addAttribute("class", "meta"); return result.html(); }
public void setUp() throws Exception { root = InMemoryPage.makeRoot("root"); pageBuilder = root.getPageCrawler(); context = FitNesseUtil.makeTestContext(root); }
public void testHtmlFormatter() throws Exception { checkFormatterCreated("html", HtmlResultFormatter.class); }
public void shouldBeAbleToConvertNumbers(){ assertThat((Short) converter.convert("5", short.class, errors, bundle), is(equalTo((short) 5))); }
ClientCnxn createConnection( String chrootPath, HostProvider hostProvider, int sessionTimeout, ZKClientConfig clientConfig, Watcher defaultWatcher, ClientCnxnSocket clientCnxnSocket, boolean canBeReadOnly ) throws IOException { Assert.assertTrue(clientCnxnSocket instanceof FragileClientCnxnSocketNIO); socket = (FragileClientCnxnSocketNIO) clientCnxnSocket; ClientCnxnSocketFragilityTest.this.cnxn = new CustomClientCnxn( chrootPath, hostProvider, sessionTimeout, clientConfig, defaultWatcher, clientCnxnSocket, canBeReadOnly); return ClientCnxnSocketFragilityTest.this.cnxn; }
public static int writeCString(String str, OutputStream os) throws IOException { if ( str == null ) {
private ResourceMethod parcialParse(String uri, HttpMethod method, MutableRequest request) { for (Route rule : routes) { ResourceMethod value = rule.matches(uri, method, request); if (value != null) { return value; } } return null; }
public void setUp() throws Exception { root = InMemoryPage.makeRoot("RooT"); PageBuilder pageBuilder = new PageBuilder(); page = pageBuilder.addPage(root, PathParser.parse("PageOne"), "some content"); PageData data = page.getData(); WikiPageProperties properties = data.getProperties(); properties.set(PageData.PropertySUITES,"Page One tags"); page.commit(data); FitNesseUtil.makeTestContext(root); }
private long readLongFromFile(String name) throws IOException { File file = new File(logFactory.getSnapDir(), name); BufferedReader br = new BufferedReader(new FileReader(file)); String line = ""; try { line = br.readLine();
public CountDownLatch broadcastOperation(final BroadcastOpFactory of, final Collection<MemcachedNode> nodes) { final CountDownLatch latch = new CountDownLatch(nodes.size()); for (MemcachedNode node : nodes) { getLogger().debug("broadcast Operation: node = " + node); Operation op = of.newOp(node, latch); op.initialize(); node.addOp(op); op.setHandlingNode(node); addedQueue.offer(node); metrics.markMeter(OVERALL_REQUEST_METRIC); } Selector s = selector.wakeup(); assert s == selector : "Wakeup returned the wrong selector."; return latch; }
private IncludeWidget createIncludeWidget(WidgetRoot widgetRoot, String includedPageName) throws Exception { return new IncludeWidget(widgetRoot, "!include " + includedPageName); }
public void shutdown() throws InterruptedException { this.interrupt(); this.join(); syncThread.running = false; syncThread.join(); for(LedgerDescriptor d: ledgers.values()) { d.close();
public void move() { } @Path("/clients") public void list() { } @Path("/clients/remove") @Delete public void remove() { } @Path("/clients/head") @Head public void head() { } public void add() { } @Path("/protectMe") protected void protectMe() { } @Path("/staticMe") public static void staticMe() { } public void toInherit() { } } @Test public void shouldFindAPublicNonStaticNonAnnotatedMethodWithTheSameNameAsTheGivenId() throws SecurityException, NoSuchMethodException { ResourceMethod method = lookuper.methodFor("/Clients/add", "POST"); assertThat(method, is(VRaptorMatchers.resourceMethod(Clients.class.getMethod("add")))); mockery.assertIsSatisfied(); } @Test public void shouldIgnoreAResourceWithTheWrongWebMethod() throws SecurityException { ResourceMethod method = lookuper.methodFor("/clients/remove", "POST"); assertThat(method, is(Matchers.nullValue())); mockery.assertIsSatisfied(); } @Test public void shouldAcceptAResultWithASpecificWebMethod() throws SecurityException, NoSuchMethodException { ResourceMethod method = lookuper.methodFor("/clients/head", "HEAD"); assertThat(method, is(VRaptorMatchers.resourceMethod(Clients.class.getMethod("head")))); mockery.assertIsSatisfied(); } static class NiceClients extends Clients { } public void findsInheritedMethodsWithDefaultNames() throws SecurityException, NoSuchMethodException { this.resource = mockery.resource(NiceClients.class); this.lookuper = new DefaultResourceAndMethodLookup(resource); ResourceMethod method = lookuper.methodFor("/NiceClients/toInherit", "POST"); assertThat(method, is(VRaptorMatchers.resourceMethod(Clients.class.getMethod("toInherit")))); mockery.assertIsSatisfied(); } }
boolean isTimedOut();  boolean isTimedOut(long ttlMillis);  boolean isTimedOutUnsent();  long getWriteCompleteTimestamp();  byte[] getErrorMsg(); }
public void compareShouldGetReportFileHtmlAndSetResultContentWithPassIfTheFilesWereTheSame() throws Exception { HistoryComparer comparer = new HistoryComparer(); FileUtil.createFile("TestFolder/FirstFile", firstContent); FileUtil.createFile("TestFolder/SecondFile", firstContent); boolean worked = comparer.compare("TestFolder/FirstFile", "TestFolder/SecondFile"); assertTrue(worked); String expectedResult = "pass"; assertEquals(expectedResult, HistoryComparer.resultContent[0]); }
protected void handleException(String thName, Throwable e) { LOG.error("Severe unrecoverable error, from thread : {}", thName, e); System.exit(DEFAULT_EXIT_CODE); }
public void sendBye() throws IOException { writeString("bye"); slimRunner.join(); }
public void testOptionParser_whenOptionWithoutValue_expectOneKeyAndNullValue() {
public void println( final String s ) { getLog().info(s); }
void setSk(SelectionKey to);  SelectionKey getSk();  int getBytesRemainingToWrite();  int writeSome() throws IOException;  void fixupOps();  void authComplete();  void setupForAuth();  void setContinuousTimeout(boolean timedOut); int getContinuousTimeout(); }
int getMaxClientCnxnsPerHost();  void setMaxClientCnxnsPerHost(int max);  int getMinSessionTimeout();  void setMinSessionTimeout(int min);  int getMaxSessionTimeout();  void setMaxSessionTimeout(int max); boolean getResponseCachingEnabled(); void setResponseCachingEnabled(boolean isEnabled);  int getConnectionMaxTokens(); void setConnectionMaxTokens(int val); int getConnectionTokenFillTime(); void setConnectionTokenFillTime(int val); int getConnectionTokenFillCount(); void setConnectionTokenFillCount(int val); int getConnectionFreezeTime(); void setConnectionFreezeTime(int val); double getConnectionDropIncrease(); void setConnectionDropIncrease(double val); double getConnectionDropDecrease(); void setConnectionDropDecrease(double val); double getConnectionDecreaseRatio(); void setConnectionDecreaseRatio(double val); int getCommitProcMaxReadBatchSize(); void setCommitProcMaxReadBatchSize(int size); int getCommitProcMaxCommitBatchSize(); void setCommitProcMaxCommitBatchSize(int size); int getRequestThrottleLimit(); void setRequestThrottleLimit(int requests); int getRequestThrottleStallTime(); void setRequestThrottleStallTime(int time); boolean getRequestThrottleDropStale(); void setRequestThrottleDropStale(boolean drop); boolean getRequestStaleLatencyCheck(); void setRequestStaleLatencyCheck(boolean check); boolean getRequestStaleConnectionCheck(); void setRequestStaleConnectionCheck(boolean check); int getLargeRequestMaxBytes(); void setLargeRequestMaxBytes(int bytes); int getLargeRequestThreshold(); void setLargeRequestThreshold(int threshold);  void resetStatistics();  void resetLatency();  void resetMaxLatency();  void resetFsyncThresholdExceedCount();  long getNumAliveConnections();  long getDataDirSize();  long getLogDirSize();  String getSecureClientPort();  String getSecureClientAddress();  long getTxnLogElapsedSyncTime();  int getJuteMaxBufferSize();  int getLastClientResponseSize();  int getMinClientResponseSize();  int getMaxClientResponseSize(); long getFlushDelay(); void setFlushDelay(long delay); long getMaxWriteQueuePollTime(); void setMaxWriteQueuePollTime(long delay); int getMaxBatchSize(); void setMaxBatchSize(int size); }
public void shouldTranslateAsteriskAsEmpty() { String uri = new DefaultParametersControl("/clients/.*", converters).fillUri(new String[] {"client"}, client(3L)); assertThat(uri, is(equalTo("/clients/"))); }
public void setUp() throws Exception { context = FitNesseUtil.makeTestContext(); root = context.getRootPage(); responder = new SavePropertiesResponder(); }
public void usesTheFirstRegisteredRuleMatchingThePattern() throws SecurityException, NoSuchMethodException { final Route route = mockery.mock(Route.class); final Route second = mockery.mock(Route.class, "second"); mockery.checking(new Expectations() {{ one(route).matches("/clients/add", HttpMethod.POST, request); will(returnValue(method)); one(route).getResource(); will(returnValue(null)); one(second).getResource(); will(returnValue(null)); allowing(route).getPriority(); allowing(second).getPriority(); }}); router.add(route); router.add(second); ResourceMethod found = router.parse("/clients/add", HttpMethod.POST, request); assertThat(found, is(equalTo(method))); mockery.assertIsSatisfied(); }
@Test public void testToMap() { assertEquals(m, r.toMap()); }
public int getMaxSessionTimeout();  public void setMaxSessionTimeout(int max);  public void resetStatistics();  public void resetLatency();  public void resetMaxLatency();  public long getNumAliveConnections();  public long getDataDirSize();  public long getLogDirSize();  public String getSecureClientPort();  public String getSecureClientAddress();  public long getTxnLogElapsedSyncTime();  public int getJuteMaxBufferSize(); }
public void addChildTable(SlimTable table) { table.id = id+"."+children.size(); table.tableName = table.tableName+"."+children.size(); table.parent = this; children.add(table); }
private boolean isDigitInput(ScanString input, int offset) { for (char i = '1'; i <= '9'; i++) { if (input.matches(new String(new char[] {i}), offset)) return true; } return false; }
public String string() throws Exception { if (type.equals("contents")) { return FitnesseFixtureContext.page.getHtml();
public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) { String newDefaultFileName; if (isChecked) { newDefaultFileName = mFileName; } else { newDefaultFileName = ""; } SharedPreferences.Editor editor = prefs.edit(); editor.putString(KEY_DEFAULT_FILENAME, newDefaultFileName); editor.commit(); BackupManagerCompat backupManager = new BackupManagerCompat(PasswordActivity.this); backupManager.dataChanged();
public synchronized List<ACL> convertLong(Long longVal) { if (longVal == null || longVal == -1L) return null; List<ACL> acls = longKeyMap.get(longVal); if (acls == null) { LOG.error("ERROR: ACL not available for long " + longVal); throw new RuntimeException("Failed to fetch acls for " + longVal); } return acls; }
private void insertTearDownForThisGroup(String setUpAndTearDownGroupKey) { String tearDownPath = setUpAndTearDownGroupKey.split(",")[1]; WikiPage tearDownPage = root.getPageCrawler().getPage(root, PathParser.parse(tearDownPath)); if (tearDownPage != null) pageList.add(new TestPage(tearDownPage));
private boolean isDepthExceeded(int currentDepth)
public void asyncReadEntries(LedgerHandle lh, long firstEntry, long lastEntry, ReadCallback cb, Object ctx) throws BKException, InterruptedException {
private void waitForXmlResultsFileToBeCreated() throws InterruptedException { for (int i = 0; i < 10; i++) { if (xmlResultsFile.exists()){ Thread.sleep(100);
public void withPath(String pathToFile) { } } @Test public void fillURLWithGreedyParameters() throws SecurityException, NoSuchMethodException { DefaultParametersControl control = new DefaultParametersControl("/clients/{pathToFile*}", converters); ResourceMethod method = DefaultResourceMethod.instanceFor(PathToFile.class, PathToFile.class.getDeclaredMethods()[0]); Object object = new AsmBasedTypeCreator(new ParanamerNameProvider()).instanceWithParameters(method, "my/path/to/file"); String filled = control.fillUri(object); assertThat(filled, is("/clients/my/path/to/file")); } @Test public void fillURLWithoutGreedyParameters() throws SecurityException, NoSuchMethodException { DefaultParametersControl control = new DefaultParametersControl("/clients/{pathToFile}", converters); ResourceMethod method = DefaultResourceMethod.instanceFor(PathToFile.class, PathToFile.class.getDeclaredMethods()[0]); Object object = new AsmBasedTypeCreator(new ParanamerNameProvider()).instanceWithParameters(method, "my/path/to/file"); String filled = control.fillUri(object); assertThat(filled, is("/clients/my/path/to/file")); } @Test public void whenNoParameterPatternsAreGivenShouldMatchAnything() throws Exception { ParametersControl control = new DefaultParametersControl("/any/{aParameter}/what", Collections.<String,String>emptyMap(), converters); assertTrue(control.matches("/any/ICanPutAnythingInHere/what")); } @Test public void whenParameterPatternsAreGivenShouldMatchAccordingToGivenPatterns() throws Exception { ParametersControl control = new DefaultParametersControl("/any/{aParameter}/what", new ImmutableMap.Builder<String, String>().put("aParameter", "aaa\\d{3}bbb").build(), converters); assertFalse(control.matches("/any/ICantPutAnythingInHere/what")); assertFalse(control.matches("/any/aaa12bbb/what")); assertTrue(control.matches("/any/aaa123bbb/what")); } @Test public void shouldFillRequestWhenAPatternIsSpecified() throws Exception { DefaultParametersControl control = new DefaultParametersControl("/project/{project.id}/build/", new ImmutableMap.Builder<String, String>().put("project.id", "\\d+").build(), converters); String uri = "/project/15/build/"; assertThat(control.matches(uri), is(true)); control.fillIntoRequest(uri, request); verify(request).setParameter("project.id", "15"); assertThat(control.apply(new String[] {"15"}),is(uri)); } }
public void testGetBulkWithCallback() throws Exception { final int items = 1000; List<String> keysList = new ArrayList<String>(items); for (int i = 0; i < items; i++) { assertTrue(client.set("getBulkWithCallback" + i, 0, "content").get()); keysList.add("getBulkWithCallback" + i); } BulkFuture<Map<String, Object>> asyncGetBulk = client.asyncGetBulk(keysList); final CountDownLatch latch = new CountDownLatch(1); asyncGetBulk.addListener(new BulkGetCompletionListener() { @Override public void onComplete(BulkGetFuture<?> f) throws Exception { assertEquals(items, f.get().size()); assertTrue(f.getStatus().isSuccess()); assertTrue(f.isDone()); assertFalse(f.isCancelled()); latch.countDown(); } }); assertTrue(latch.await(2, TimeUnit.SECONDS)); }
private static void setupJaasConfigEntries( String hostServerPrincipal, String hostLearnerPrincipal, String hostNamedLearnerPrincipal) { String keytabFilePath = FilenameUtils.normalize(KerberosTestUtils.getKeytabFile(), true);
public void initialize() {
private void testWidgetClassAndText(WikiWidget widget, Class<?> expectedClass, String expectedText) { assertEquals(expectedClass, widget.getClass()); if(widget instanceof TextWidget) assertEquals(expectedText, ((TextWidget) widget).getText());
public void commandRun() { if (isZKServerRunning()) { pw.print("null");
public void testSimpleOrderedList() throws Exception { ListWidget list = new ListWidget(widgetRoot, " 1Item1"); assertTrue("should be ordered", list.isOrdered()); assertEquals(0, list.getLevel()); assertEquals(1, list.numberOfChildren()); }
public void removeLearnerHandler(LearnerHandler learnerHandler) { activeObservers.remove(learnerHandler); }
public void startVector(List<?> v, String tag) throws IOException { printCommaUnlessFirst(); stream.print("v{"); isFirst = true; }
public void addArgs(String... args) { if(args != null) { this.args.addAll(Arrays.asList(args));
public synchronized void dumpWatchesSummary(PrintWriter writer) { writer.print(dataWatches.toString()); }
public void testCommandPatternJava() throws Exception { String pageText = "!define TEST_SYSTEM {slim}\n"; WikiPage page = makeTestPage(pageText); Descriptor defaultDescriptor = TestSystem.getDescriptor(page, false); String sep = System.getProperty("path.separator"); assertEquals("java -cp fitnesse.jar" + sep + "%p %m", defaultDescriptor.getCommandPattern()); Descriptor debugDescriptor = TestSystem.getDescriptor(page, true); assertEquals( "java -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000 -cp %p %m", debugDescriptor.getCommandPattern()); String specifiedPageText = "!define COMMAND_PATTERN {java -specialParam -cp %p %m}\n" + "!define REMOTE_DEBUG_COMMAND {java -remoteDebug -cp %p %m}"; WikiPage specifiedPage = makeTestPage(specifiedPageText); Descriptor defaultDescriptor2 = TestSystem.getDescriptor(specifiedPage, false); assertEquals("java -specialParam -cp %p %m", defaultDescriptor2.getCommandPattern()); Descriptor debugDescriptor2 = TestSystem.getDescriptor(specifiedPage, true); assertEquals("java -remoteDebug -cp %p %m", debugDescriptor2.getCommandPattern()); }
void add(Interceptor interceptor); <T extends Interceptor> void add(Class<T> interceptor); void next(ResourceMethod method, Object resourceInstance) throws InterceptionException; void addAsNext(Interceptor interceptor); void addAsNext(Class<? extends Interceptor> interceptor); }
protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState);
public void info( String message ) { if (verbose) { task.log(message);
void testExceptionOccurred(Assertion assertion, ExceptionResult exceptionResult); }
public void testGetTargetClassFromRowFixture() throws Exception { Class<?> targetClass = templateCreator.getTargetClassFromRowFixture(PrimeNumberRowFixture.class); assertNotNull(targetClass); assertEquals("fitnesse.fixtures.PrimeData", targetClass.getName()); }
public void testImportingFromNonRootPageUpdatesPageContent() throws Exception { PageData data = pageTwo.getData(); data.setAttribute("WikiImportSource", baseUrl + "PageOne"); data.setContent("nonsense"); pageTwo.commit(data); Response response = makeSampleResponse("blah"); new MockResponseSender(response); data = pageTwo.getData(); assertEquals("page one", data.getContent()); assertFalse(data.hasAttribute("WikiImportRoot")); }
public void notLessThanComparison() throws Exception { assertExpectationMessage(" !< 5.9 ", "8", "pass(8!< 5.9)"); assertExpectationMessage(" !< 5.9 ", "5.9", "pass(5.9!< 5.9)"); assertExpectationMessage(" !< 5.9 ", "3.6", "fail(3.6!< 5.9)"); }
public void testUnicode() { check("\u216C","u216C"); check("\u216D\uFFFE","u216DuFFFE"); check("\uFFFF","uFFFF"); check("\u0041b","Ab"); }
public String toString() { return "[PatternBasedType" + originalPattern + " ]"; }
public VersionInfo makeVersion(FileSystemPage page, PageData data) { createDirectoryIfNewPage(page); saveContent(page, data.getContent()); saveAttributes(page, data.getProperties()); return null; }
public void shouldThreatViewlessAsNonDisplayView() throws NoSuchMethodException { ResourceMethod method = mockery.methodFor(DefaultComponents.class, "nothing"); final HttpServletRequest request = mockery.mock(HttpServletRequest.class); mockery.checking(new Expectations() { { allowing(request).getRequestURI(); will(returnValue("somethig.whatever.logic")); allowing(request).getParameter("view"); will(returnValue(null)); } }); DefaultComponentInfoProvider info = new DefaultComponentInfoProvider(request); assertThat(info.shouldShowView(method), is(equalTo(false))); mockery.assertIsSatisfied(); }
public void init(FilterConfig cfg) throws ServletException { servletContext = cfg.getServletContext(); BasicConfiguration config = new BasicConfiguration(servletContext); init(config.getProvider(), new CachedStaticContentHandler(new DefaultStaticContentHandler(servletContext))); logger.info("VRaptor 3 successfuly initialized"); }
public static void main(String[] args) throws IOException, InterruptedException { ZooKeeperMain main = new ZooKeeperMain(args); main.run(); }
public void testWordsNotFoundInPreprocessedText() { WhereUsedPageFinder whereUsed = new WhereUsedPageFinder(pageThree, hits); WikiPageUtil.addPage(root, PathParser.parse("NewPage"), "{{{ PageThree }}}"); whereUsed.search(root); hits.assertPagesFound(); }
public void toString_should_return_a_formated_string_when_value_is_a_empty_array() { Integer[] value = {}; String current = converter.toString(value); assertEquals("[]", current); }
public void testCantMovePageBelowChild() throws Exception { SimpleResponse response = (SimpleResponse) movePage("PageOne", "PageOne.PageA", true); assertSubString("Cannot move", response.getContent()); assertTrue(crawler.pageExists(root, PathParser.parse("PageOne.PageA")));
private JUnitHelper createJUnitHelper(final RunNotifier notifier) { JUnitHelper jUnitHelper = new JUnitHelper(this.fitNesseDir, this.outputDir, new JUnitRunNotifierResultsListener(notifier,suiteClass)); jUnitHelper.setDebugMode(debugMode); jUnitHelper.setPort(port); return jUnitHelper; }
public void handleLine(String line) { System.out.println("Woo! A line!"); }
public synchronized boolean isTimedOut(long ttlMillis) { long elapsed = System.nanoTime(); long ttlNanos = ttlMillis * 1000 * 1000; if (elapsed - creationTime > ttlNanos) { assert (state != OperationState.READING || state != OperationState.COMPLETE); timedOutUnsent = true; timedout = true; callback.complete(); } else {
public void execute() throws InterceptionException { LOG.debug("executing stack DefaultRequestExecution"); interceptorStack.add(MultipartInterceptor.class); interceptorStack.add(JerseyResourceLookupInterceptor.class); interceptorStack.add(FlashInterceptor.class); interceptorStack.add(InterceptorListPriorToExecutionExtractor.class); interceptorStack.add(InstantiateInterceptor.class); interceptorStack.add(ParametersInstantiatorInterceptor.class); interceptorStack.add(DeserializingInterceptor.class); interceptorStack.add(ExceptionHandlerInterceptor.class); interceptorStack.add(ExecuteMethodInterceptor.class); interceptorStack.add(OutjectResult.class); interceptorStack.add(DownloadInterceptor.class); interceptorStack.add(ForwardToDefaultViewInterceptor.class); interceptorStack.next(null, null); }
public void useSymbol() throws Exception { buildInstructionsFor("|function|$V|\n"); List<CallInstruction> expectedInstructions = asList( new CallInstruction("htmlScriptTable_id_0", "htmlScriptTableActor", "function", new Object[]{"$V"}) ); assertEquals(expectedInstructions, instructions()); }
public boolean waitForQueues(long timeout, TimeUnit unit) { CountDownLatch blatch = broadcastOp(new OperationFactory(){ public Operation newOp(final MemcachedNode n, final CountDownLatch latch) { return new VersionOperation( new OperationCallback() {
public boolean visit(Symbol node) { if (node.isType(Literal.symbolType)) { node.setContent(literalDelimiter + node.getContent() + literalDelimiter); } return true; }
private String compatibleNameFor(Class<?> type) { String[] names = BeanFactoryUtils.beanNamesForTypeIncludingAncestors(this, type); if (names.length == 0) { throw new NoSuchBeanDefinitionException(type, "no bean for this type registered");
protected void registerComponents(ComponentRegistry container) { singleInterfaceRegister(StupidTranslator.class, container); singleInterfaceRegister(DefaultRouter.class, container); singleInterfaceRegister(DefaultResourceNotFoundHandler.class, container); singleInterfaceRegister(DefaultDirScanner.class, container); singleInterfaceRegister(WebInfClassesScanner.class, container); singleInterfaceRegister(DefaultInterceptorRegistry.class, container); singleInterfaceRegister(DefaultMethodLookupBuilder.class, container); singleInterfaceRegister(DefaultPathResolver.class, container); singleInterfaceRegister(ParanamerNameProvider.class, container); singleInterfaceRegister(DefaultConverters.class, container); singleInterfaceRegister(DefaultMethodInfo.class, container); singleInterfaceRegister(DefaultRequestParameters.class, container); singleInterfaceRegister(DefaultInterceptorStack.class, container); singleInterfaceRegister(DefaultRequestExecution.class, container); singleInterfaceRegister(DefaultResult.class, container); singleInterfaceRegister(OgnlParametersProvider.class, container); singleInterfaceRegister(DefaultMethodInfo.class, container); singleInterfaceRegister(DefaultValidator.class, container); singleInterfaceRegister(JstlLocalization.class, container); container.register(ForwardToDefaultViewInterceptor.class, ForwardToDefaultViewInterceptor.class); container.register(LogicResult.class, DefaultLogicResult.class); container.register(RequestResult.class, RequestResult.class); container.register(PageResult.class, DefaultPageResult.class); container.register(TypeCreator.class, AsmBasedTypeCreator.class); container.register(EmptyElementsRemoval.class, EmptyElementsRemoval.class); container.register(ParametersInstantiatorInterceptor.class, ParametersInstantiatorInterceptor.class); container.register(InterceptorListPriorToExecutionExtractor.class, InterceptorListPriorToExecutionExtractor.class); container.register(URLParameterExtractorInterceptor.class, URLParameterExtractorInterceptor.class); container.register(ResourceLookupInterceptor.class, ResourceLookupInterceptor.class); container.register(InstantiateInterceptor.class, InstantiateInterceptor.class); container.register(ExecuteMethodInterceptor.class, ExecuteMethodInterceptor.class); }
void appendCellToRow(int row, String contents) throws Exception; String error(String s); String pass(String s); String fail(String s); String ignore(String s); String getUnescapedCellContents(int col, int row); void appendCellToRow(int row, Table table); void setTestStatusOnRow(int row, boolean testStatus); void setName(String tableName); }
public void setUp() throws Exception { } public void tearDown() throws Exception { } public void testBasics() throws Exception { CommandRunner runner = new CommandRunner("java -cp ./classes fitnesse.testutil.Echo", "echo this!", null); runner.run(); assertHasRegexp("echo this!", runner.getOutput()); assertEquals("", runner.getError()); assertEquals(false, runner.hasExceptions()); assertEquals(0, runner.getExitCode()); } public void testClassNotFound() throws Exception { CommandRunner runner = new CommandRunner("java BadClass", "", null); runner.run(); assertHasRegexp("Error", runner.getError()); assertEquals("", runner.getOutput()); assertTrue(0 != runner.getExitCode()); } }
public void testEmptyTestPage() throws Exception { PageData data = root.getData(); data.setContent(classpathWidgets()); root.commit(data); testPage = WikiPageUtil.addPage(root, PathParser.parse("EmptyTestPage"), ""); request.setResource(testPage.getName()); response = responder.makeResponse(context, request); sender = new MockResponseSender(); sender.doSending(response); sender.sentData(); String errorLogContent = getExecutionLog(); assertNotSubString("Exception", errorLogContent); }
public void WhenHasNoTableThenIsNotTest() throws Exception { assertFalse(makePage("somewhere", "myfile.html", "stuff").getData().hasAttribute(PageType.TEST.toString())); }
String getFullPath(); String getContent(); boolean targetExists(String wikiWordPath); String makeFullPathOfTarget(String wikiWordPath); String findParentPath(String targetName); Maybe<SourcePage> findIncludedPage(String pageName); Collection<SourcePage> getChildren(); boolean hasProperty(String propertyKey); String getProperty(String propertyKey); List<Symbol> findHeaderLines(); }
private void lookForOpenIntentsFilePicker() { if (Interaction.isIntentAvailable(mActivity, Intents.OPEN_INTENTS_FILE_BROWSE)) { Intent i = new Intent(Intents.OPEN_INTENTS_FILE_BROWSE);
public Object insideRequest(Container container) { container.instanceFor(EncodingHandler.class).setEncoding(baseRequest, baseResponse); container.instanceFor(RequestExecution.class).execute(); return null; }
public void existsForWillReturnTrueIfTypeIsAlreadyCached() throws Exception { mockery.checking(new Expectations(){{ one(container).instanceFor(converter.getClass()); will(returnValue(converter)); allowing(delegate).existsFor(CachedConvertersTest.class, container); will(returnValue(true)); }}); assertTrue(converters.existsFor(CachedConvertersTest.class, container)); }
public static void copyStat(Stat from, Stat to) { to.setAversion(from.getAversion()); to.setCtime(from.getCtime()); to.setCversion(from.getCversion()); to.setCzxid(from.getCzxid()); to.setMtime(from.getMtime()); to.setMzxid(from.getMzxid()); to.setPzxid(from.getPzxid()); to.setVersion(from.getVersion()); to.setEphemeralOwner(from.getEphemeralOwner()); to.setDataLength(from.getDataLength()); to.setNumChildren(from.getNumChildren()); }
private long timedTransaction() throws Exception { long startTime = System.currentTimeMillis(); zkClient.exists(AnyPath, false); return System.currentTimeMillis() - startTime; }
WatchesReport getWatches();  WatchesPathReport getWatchesByPath();  void dumpWatches(PrintWriter pwriter, boolean byPath); }
public static <T extends Node> T deepClone(T node) { return (T) deepClone(new NodeList(node), null).elementAt(0); }
public void DirectoryWithoutHtmlFilesIsFileSystemPage() throws Exception { fileSystem.makeFile("./somepath/WikiPage/myfile.txt", "stuff"); fileSystem.makeFile("./somepath/OtherPage/myfile.html", "stuff"); WikiPage page = pageRepository.makeChildPage("WikiPage", rootPage); assertEquals(FileSystemPage.class, page.getClass()); }
public void onAuthenticationError(int errorCode, @NonNull CharSequence errString) { super.onAuthenticationError(errorCode, errString); if (!canceledBiometricAuth(errorCode)) { Toast.makeText(context, R.string.biometric_auth_error, Toast.LENGTH_LONG).show(); } GroupActivity.Launch(getActivity()); }
public void writeSummary_WritesSummaryOfTestExecutions() throws Exception{ jf.testComplete(buildNestedTestPage(), new TestSummary(5,6,7,8)); WikiPageDummy root = new WikiPageDummy("root", null, null); WikiPageDummy secondPage=new WikiPageDummy("SecondPage", null, root); jf.testComplete(new WikiTestPage(secondPage), new TestSummary(11,12,13,14)); jf.writeSummary("SummaryPageName"); String expectedOutput = new StringBuffer() .append(JavaFormatter.TestResultsSummaryTable.SUMMARY_HEADER) .append(new JavaFormatter.TestResultsSummaryTableRow(nestedPageName, new TestSummary(5,6,7,8)).toString()) .append(new JavaFormatter.TestResultsSummaryTableRow("SecondPage", new TestSummary(11,12,13,14)).toString()) .append(JavaFormatter.TestResultsSummaryTable.SUMMARY_FOOTER) .toString(); verify(mockResultsRepository).open("SummaryPageName"); verify(mockResultsRepository, times(1)).write(expectedOutput); }
public void pageDirectoryWithOneResultShouldShowOneHistoryRecord() throws Exception { File pageDirectory = addPageDirectory("SomePage"); addTestResult(pageDirectory, "20090418123103_1_2_3_4"); history.readHistoryDirectory(resultsDirectory); PageHistory pageHistory = history.getPageHistory("SomePage"); assertEquals(1, pageHistory.getFailures()); assertEquals(0, pageHistory.getPasses()); Date date = dateFormat.parse("20090418123103"); assertEquals(date, pageHistory.getMinDate()); assertEquals(date, pageHistory.getMaxDate()); assertEquals(1, pageHistory.size()); PageHistory.TestResultRecord testSummary = pageHistory.get(date); assertEquals(date, testSummary.getDate()); assertEquals(new TestSummary(1, 2, 3, 4), testSummary); }
public void shouldSerializeAllBasicFields() { String expectedResult = "<order>\n <price>15.0</price>\n <comments>pack it nicely, please</comments>\n</order>"; Order order = new Order(new Client("guilherme silveira"), 15.0, "pack it nicely, please"); serialization.from(order).serialize(); assertThat(result(), is(equalTo(expectedResult))); }
public void testLoadPEMKeyStore( X509KeyType caKeyType, X509KeyType certKeyType, String keyPassword, Integer paramIndex) throws Exception { init(caKeyType, certKeyType, keyPassword, paramIndex);
public void onLeaderElectionStarted(QuorumPeer qp) { ZooTrace.logTraceMessage(LOG, ZooTrace.JMX_TRACE_MASK, "Running leader election protocol..."); leBean=new LeaderElectionBean(); MBeanRegistry.getInstance().register(leBean, localPeerBean); }
public static String gray(String string) { return " <span class=\"fit_grey\">" + string + "</span>"; }
private void checkRequestLine(Matcher match) throws HttpException { if (!match.find()) throw new HttpException( "The request string is malformed and can not be parsed"); if (!allowedMethods.contains(match.group(1))) throw new HttpException("The " + match.group(1)
public void add(Client c) throws ServletException, IOException { clients.add(c); result.include("client", c); result.use(PageResult.jsp()).forward("ok"); }
public static String encodeLines (byte[] in, int iOff, int iLen, int lineLen, String lineSeparator) { int blockLen = (lineLen*3) / 4; if (blockLen <= 0) throw new IllegalArgumentException(); int lines = (iLen+blockLen-1) / blockLen; int bufLen = ((iLen+2)/3)*4 + lines*lineSeparator.length(); StringBuilder buf = new StringBuilder(bufLen); int ip = 0; while (ip < iLen) { int l = Math.min(iLen-ip, blockLen); buf.append (encode(in, iOff+ip, l)); buf.append (lineSeparator); ip += l; } return buf.toString(); }
public boolean isInterRegionSSLEnabled() { return conf.getBoolean(INTER_REGION_SSL_ENABLED, true); }
protected void removeOtherwiseMatchedResults(Iterable<MatchedResult> potentialMatchesByScore, MatchedResult bestResult) { Iterator<MatchedResult> iterator = potentialMatchesByScore.iterator(); while (iterator.hasNext()) { MatchedResult otherResult = iterator.next();
public void shouldNormalURIAsNotAjax() { final HttpServletRequest request = mockery.mock(HttpServletRequest.class); mockery.checking(new Expectations() { { one(request).getRequestURI(); will(returnValue("somethig.non-ajax.logic")); one(request).getParameter("view"); will(returnValue("xml")); } }); assertThat(info.isAjax(request), is(equalTo(false))); mockery.assertIsSatisfied(); }
public void ifListenerIsSet_TestCompleteFiresTestComplete() throws Exception{ jf.setListener(listener); WikiPage page=buildNestedTestPage(); TimeMeasurement timeMeasurement = new TimeMeasurement().start(); jf.testComplete(page, new TestSummary(1,2,3,4), timeMeasurement.stop()); verify(listener).testComplete(page, new TestSummary(1,2,3,4), timeMeasurement); }
public void announceNumberTestsToRun(int testsToRun) {} @Override public void testSystemStarted(TestSystem testSystem) {} @Override public void newTestStarted(WikiTestPage test, TimeMeasurement timeMeasurement) throws IOException {} @Override public void testOutputChunk(String output) throws IOException {} @Override public void testAssertionVerified(Assertion assertion, TestResult testResult) {} @Override public void testExceptionOccurred(Assertion assertion, ExceptionResult exceptionResult) {} @Override public void testComplete(WikiTestPage test, TestSummary testSummary, TimeMeasurement timeMeasurement) throws IOException {} @Override public void errorOccured() {} }
public static String dumpAsString( Object obj) { return dumpAsString(obj, false); }
void registerCustomInjectionProcessor() { RootBeanDefinition definition = new RootBeanDefinition(InjectionBeanPostProcessor.class); definition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); definition.getPropertyValues().addPropertyValue("order", Ordered.LOWEST_PRECEDENCE); ((BeanDefinitionRegistry) beanFactory).registerBeanDefinition(AnnotationConfigUtils.AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME, definition); }
public void canTranslate() { FixedMethodStrategy strategy = new FixedMethodStrategy("abc", MyControl.class, method("list"), methods(HttpMethod.POST), control, 0); mockery.checking(new Expectations() { { one(control).matches("/clients/add"); will(returnValue(true)); one(control).fillIntoRequest("/clients/add", request); } }); ResourceMethod match = strategy.matches("/clients/add", HttpMethod.POST, request); assertThat(match, is(VRaptorMatchers.resourceMethod(method("list")))); }
public void writeLong(long l, String tag) throws IOException { out.writeLong(l); }
public void testPageMatchesQueryWithExcludedSetUps() throws Exception { Map<String, Boolean> attributes = new HashMap<String, Boolean>(); attributes.put("SetUp", false); List<PageType> pageTypes = Arrays.asList(TEST, NORMAL, SUITE); searcher = generateSearcherByPageTypesAndSearchAttributes(pageTypes, attributes); setPageProperty(page, TEST.toString(), "true"); assertTrue(searcher.pageMatches(page)); page = crawler.addPage(root, PathParser.parse("SetUp")); assertFalse(searcher.pageMatches(page)); page = crawler.addPage(root, PathParser.parse("TearDown")); assertTrue(searcher.pageMatches(page)); page = crawler.addPage(root, PathParser.parse("SuiteSetUp")); assertFalse(searcher.pageMatches(page)); page = crawler.addPage(root, PathParser.parse("SuiteTearDown")); assertTrue(searcher.pageMatches(page)); }
abstract public void onClick(); abstract public void onCreateMenu(ContextMenu menu, ContextMenuInfo menuInfo); abstract public boolean onContextItemSelected(MenuItem item); }
WikiPagePath getFullPath(WikiPage page); WikiPage addPage(WikiPage context, WikiPagePath path, String content); WikiPage addPage(WikiPage context, WikiPagePath path); String getRelativeName(WikiPage base, WikiPage page); boolean isRoot(WikiPage page); WikiPage getRoot(WikiPage page); void traverse(WikiPage root, TraversalListener<? super WikiPage> pageCrawlerTest); WikiPage getSiblingPage(WikiPage page, WikiPagePath pathRelativeToSibling); WikiPage findAncestorWithName(WikiPage page, String name); }
public void checking(Validations validations) { addAll(validations.getErrors(localization.getBundle())); }
public void deserializeSnapshot(InputArchive ia) throws IOException { clear(); SerializeUtils.deserializeSnapshot(getDataTree(), ia, getSessionWithTimeOuts()); initialized = true; }
private String makeEndTag() { return hasChildren() ? "</" + tagName() + ">" : ""; }
public Object clone() { PwDate copy = new PwDate(); if ( cDateBuilt ) { byte[] newC = new byte[DATE_SIZE]; System.arraycopy(cDate, 0, newC, 0, DATE_SIZE); copy.cDate = newC; copy.cDateBuilt = true; } if ( jDateBuilt ) { copy.jDate = (Date) jDate.clone(); copy.jDateBuilt = true; } return copy; }
public static boolean approximatelyEqual(String standard, String candidate) { try { double candidateValue = Double.parseDouble(candidate);
private String processHTMLWidgets(String content, WikiPage context) { return new Translator().translate(content); }
private <T> T useDefaultConstructor(Class<T> clazz) { try { return clazz.newInstance();
public void allTestingComplete() throws Exception { if (isSuite) writeSummary(mainPageName); if (listener != null) listener.allTestingComplete();
public void testLoadPKCS12KeyStoreAutodetectStoreFileType() throws Exception {
<T> Future<Boolean> add(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> add(String key, int exp, Object o); <T> Future<Boolean> set(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> set(String key, int exp, Object o); <T> Future<Boolean> replace(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> replace(String key, int exp, Object o); <T> Future<T> asyncGet(String key, Transcoder<T> tc); Future<Object> asyncGet(String key); Future<CASValue<Object>> asyncGetAndTouch(final String key, final int exp); <T> Future<CASValue<T>> asyncGetAndTouch(final String key, final int exp, final Transcoder<T> tc); CASValue<Object> getAndTouch(String key, int exp); <T> CASValue<T> getAndTouch(String key, int exp, Transcoder<T> tc); <T> Future<CASValue<T>> asyncGets(String key, Transcoder<T> tc); Future<CASValue<Object>> asyncGets(String key); <T> CASValue<T> gets(String key, Transcoder<T> tc); CASValue<Object> gets(String key); <T> T get(String key, Transcoder<T> tc); Object get(String key); <T> BulkFuture<Map<String, T>> asyncGetBulk(Iterator<String> keys, Iterator<Transcoder<T>> tcs); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Iterator<Transcoder<T>> tcs); <T> BulkFuture<Map<String, T>> asyncGetBulk(Iterator<String> keys, Transcoder<T> tc); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); BulkFuture<Map<String, Object>> asyncGetBulk(Iterator<String> keys); BulkFuture<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> BulkFuture<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); BulkFuture<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Iterator<String> keys, Transcoder<T> tc); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc); Map<String, Object> getBulk(Iterator<String> keys); Map<String, Object> getBulk(Collection<String> keys); <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys); Map<String, Object> getBulk(String... keys); <T> Future<Boolean> touch(final String key, final int exp, final Transcoder<T> tc); <T> Future<Boolean> touch(final String key, final int exp); Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, long by); long incr(String key, int by); long decr(String key, long by); long decr(String key, int by); long incr(String key, long by, long def, int exp); long incr(String key, int by, long def, int exp); long decr(String key, long by, long def, int exp); long decr(String key, int by, long def, int exp); Future<Long> asyncIncr(String key, long by); Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, long by); Future<Long> asyncDecr(String key, int by); long incr(String key, long by, long def); long incr(String key, int by, long def); long decr(String key, long by, long def); long decr(String key, int by, long def); Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs);  Set<String> listSaslMechanisms(); }
public String toString() { StringBuffer sb = new StringBuffer(); sb.append("FollowerHandler ").append(sock); sb.append(" tickOfLastAck:").append(tickOfLastAck()); sb.append(" synced?:").append(synced()); sb.append(" queuedPacketLength:").append(queuedPackets.size()); return sb.toString(); }
public void testToString() throws ConfigException { String config = "127.0.0.1:1234:1236:participant;0.0.0.0:1237"; String expected = "127.0.0.1:1234:1236:participant;0.0.0.0:1237"; QuorumServer qs = new QuorumServer(0, config); Assert.assertEquals("Use IP address", expected, qs.toString()); config = "127.0.0.1:1234:1236;0.0.0.0:1237"; expected = "127.0.0.1:1234:1236:participant;0.0.0.0:1237"; qs = new QuorumServer(0, config); Assert.assertEquals("Type unspecified", expected, qs.toString()); config = "127.0.0.1:1234:1236:observer;0.0.0.0:1237"; expected = "127.0.0.1:1234:1236:observer;0.0.0.0:1237"; qs = new QuorumServer(0, config); Assert.assertEquals("Observer type", expected, qs.toString()); config = "127.0.0.1:1234:1236:participant;1237"; expected = "127.0.0.1:1234:1236:participant;0.0.0.0:1237"; qs = new QuorumServer(0, config); Assert.assertEquals("Client address unspecified", expected, qs.toString()); config = "127.0.0.1:1234:1236:participant;1.2.3.4:1237"; expected = "127.0.0.1:1234:1236:participant;1.2.3.4:1237"; qs = new QuorumServer(0, config); Assert.assertEquals("Client address specified", expected, qs.toString()); config = "example.com:1234:1236:participant;1237"; expected = "example.com:1234:1236:participant;0.0.0.0:1237"; qs = new QuorumServer(0, config); Assert.assertEquals("Use hostname", expected, qs.toString()); }
public void run(){ try{ takeResult[0] = queueHandles[0].take();
public void testLastModificationTime() throws Exception { SimpleDateFormat format = WikiPageProperty.getTimeFormat(); WikiPageProperties props = new WikiPageProperties(); assertEquals(format.format(Clock.currentDate()), format.format(props.getLastModificationTime())); Date date = format.parse("20040101000001"); props.setLastModificationTime(date); assertEquals("20040101000001", props.get(PageData.PropertyLAST_MODIFIED)); assertEquals(date, props.getLastModificationTime()); }
private Request createRequest(Record record, int opCode, boolean admin) throws IOException { return createRequest(record, opCode, 1L, admin); }
public void shouldNotInvokeInterceptorsMethodIfInterceptorDoesntAcceptsResource() throws InterceptionException, IOException { final Interceptor interceptor = mockery.mock(Interceptor.class); final InterceptorStack stack = mockery.mock(InterceptorStack.class); final ResourceMethod method = mockery.mock(ResourceMethod.class); final Object instance = new Object(); Container container = mockery.container(Interceptor.class, interceptor); mockery.checking(new Expectations() { { one(interceptor).accepts(method); will(returnValue(false)); never(interceptor).intercept(stack, method, instance); one(stack).next(method, instance); } }); ToInstantiateInterceptorHandler handler = new ToInstantiateInterceptorHandler(container, Interceptor.class); handler.execute(stack, method, instance); mockery.assertIsSatisfied(); }
public InputStream getInputStream() throws IOException { return commandRunner.getInputStream(); }
public void testTopToString() { assertEquals("top",topTree.toString()); }
public void testFromFilenameThrowsOnBadFileExtension() { KeyStoreFileType.fromFilename("prod.key"); }
void testOutputChunk(String output) throws IOException; void testStarted(TestPage testPage) throws IOException; void testComplete(TestPage testPage, TestSummary testSummary) throws IOException; void testSystemStopped(TestSystem testSystem, ExecutionLog executionLog, Throwable cause ); void testAssertionVerified(Assertion assertion, TestResult testResult); void testExceptionOccurred(Assertion assertion, ExceptionResult exceptionResult); }
public void setUp() throws InterruptedException, IOException { createSlimService(); slimClient = new SlimCommandRunningClient(new MockCommandRunner(), "localhost", 8099); statements = new ArrayList<Instruction>(); slimClient.connect(); }
public void canParseISO8601DateFormat() {
public int getMaxSessionTimeout();  public void setMaxSessionTimeout(int max);  public void resetStatistics();  public void resetLatency();  public void resetMaxLatency(); }
public void canShowChildCount() throws Exception { WikiPage frontPage = WikiPageUtil.addPage(root, frontPagePath, ""); WikiPageUtil.addPage(frontPage, pageOnePath, ""); WikiPageUtil.addPage(frontPage, pageTwoPath, ""); request.setResource(""); request.addInput("ShowChildCount",""); SimpleResponse response = (SimpleResponse) responder.makeResponse(FitNesseUtil.makeTestContext(root), request); assertHasRegexp("FrontPage 2", response.getContent()); }
protected void finishWritingOutput() throws IOException { writeData(testSummary()); writeData("<br/><div class=\"footer\">\n"); writeData(getPage().getData().getFooterPageHtml()); writeData("</div>\n"); if (htmlPage != null) writeData(htmlPage.postDivision);
Collection<Operation> destroyInputQueue();  void setupResend();  void fillWriteBuffer(boolean optimizeGets);  void transitionWriteItem();  Operation getCurrentReadOp();  Operation removeCurrentReadOp();  Operation getCurrentWriteOp();  Operation removeCurrentWriteOp();  boolean hasReadOp();  boolean hasWriteOp();  void addOp(Operation op);  void insertOp(Operation o);  int getSelectionOps();  ByteBuffer getRbuf();  ByteBuffer getWbuf();  SocketAddress getSocketAddress();  boolean isActive();  void reconnecting();  void connected();  int getReconnectCount();  void registerChannel(SocketChannel ch, SelectionKey selectionKey);  void setChannel(SocketChannel to);  SocketChannel getChannel();  void setSk(SelectionKey to);  SelectionKey getSk();  int getBytesRemainingToWrite();  int writeSome() throws IOException;  void fixupOps();  void authComplete();  void setupForAuth();  void setContinuousTimeout(boolean timedOut); int getContinuousTimeout(); }
public void testSymbolicLinksLoading() throws Exception { ByteArrayOutputStream output = saveSomeSymbolicLinks(); ByteArrayInputStream input = new ByteArrayInputStream(output.toByteArray()); WikiPageProperties newProperties = new WikiPageProperties(input); assertTrue(newProperties.hasSymbolicLink("LinkOne")); assertEquals(PathParser.parse("PatH.OnE"), newProperties.getSymbolicLink("LinkOne")); assertTrue(newProperties.hasSymbolicLink("LinkTwo")); assertEquals(PathParser.parse("PatH.TwO"), newProperties.getSymbolicLink("LinkTwo")); }
public void intercept(InterceptorStack stack, ResourceMethod method, Object resourceInstance) throws InterceptionException { } public boolean accepts(ResourceMethod method) { return true; } } @SuppressWarnings("unchecked") @Test public void shouldReturnAnInterceptorWhichAcceptsTheGivenResource() throws InterceptionException, IOException { mockery.checking(new Expectations() { { one(container).instanceFor(CustomInterceptor.class); will(returnValue(interceptor)); one(interceptor).accepts(method); will(returnValue(true)); } }); registry.register(CustomInterceptor.class); List<Interceptor> types = registry.interceptorsFor(method, container); assertThat(types, hasItems(interceptor)); mockery.assertIsSatisfied(); } @SuppressWarnings("unchecked") @Test public void shouldNotReturnAnInterceptorWhichDoesNotAcceptTheGivenResource() { mockery.checking(new Expectations() { { one(container).instanceFor(CustomInterceptor.class); will(returnValue(interceptor)); one(interceptor).accepts(method); will(returnValue(false)); } }); registry.register(CustomInterceptor.class); List<Interceptor> types = registry.interceptorsFor(method, container); assertThat(types, hasSize(0)); mockery.assertIsSatisfied(); } @Test public void shouldReturnNoInterceptorIfThereIsNoneRegistered() { List<Interceptor> types = registry.interceptorsFor(method, container); assertThat(types, hasSize(0)); mockery.assertIsSatisfied(); } }
private Request newRequest(Record rec, int type, int sessionId, int xid) throws IOException { ByteArrayOutputStream boas = new ByteArrayOutputStream(); BinaryOutputArchive boa = BinaryOutputArchive.getArchive(boas); rec.serialize(boa, "request"); ByteBuffer bb = ByteBuffer.wrap(boas.toByteArray()); return new Request(null, sessionId, xid, type, RequestRecord.fromBytes(bb), new ArrayList<Id>()); }
public void testDelTree() throws Exception { FileSystemPage fsRoot = (FileSystemPage)FileSystemPage.makeRoot(".", "RooT"); WikiPage levelOne = crawler.addPage(fsRoot, PathParser.parse("LevelOne")); crawler.addPage(levelOne, PathParser.parse("LevelTwo")); File childOne = new File("RooT/LevelOne"); File childTwo = new File("RooT/LevelOne/LevelTwo"); assertTrue(childOne.exists()); FileUtil.deleteFileSystemDirectory(childOne); assertFalse(childTwo.exists()); assertFalse(childOne.exists()); }
public void testSession() throws IOException, InterruptedException, KeeperException { DisconnectableZooKeeper zk = createClient(); zk.create("/e", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL); LOG.info("zk with session id 0x" + Long.toHexString(zk.getSessionId()) + " was destroyed!");
private void sampleFormatter() throws Exception { formatter = new CachingResultFormatter(); result1 = new PageResult("ResultOne", new TestSummary(1, 2, 3, 4), "result one content"); result2 = new PageResult("ResultTwo", new TestSummary(4, 3, 2, 1), "result two content"); TestSummary finalSummary = new TestSummary(5, 5, 5, 5); formatter.acceptResult(result1); formatter.acceptResult(result2); formatter.acceptFinalCount(finalSummary); }
WikiPagePath getFullPathOfChild(WikiPagePath childPath); WikiPagePath getFullPath(); String getRelativeName(WikiPage page); WikiPage getRoot(); void traverse(TraversalListener<? super WikiPage> callback); WikiPage getSiblingPage(WikiPagePath pathRelativeToSibling); WikiPage findAncestorWithName(String name); WikiPage getClosestInheritedPage(WikiPage context, String pageName);
public void acceptSocketFrom(SocketDoner donor) throws IOException, InterruptedException { this.donor = donor; acceptSocket(donor.donateSocket()); }
int update(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) { mBuffered = (mBuffered + inputLen) % AES_BLOCK_SIZE; return nativeUpdate(mCtxPtr, input, inputOffset, inputLen, output, outputOffset, engineGetOutputSize(inputLen)); }
public VersionInfo commit(PageData data) throws Exception { VersionInfo versionInfo = super.commit(data); setCachedData(makePageData()); return versionInfo; }
synchronized public void waitForConnected(long timeout) throws InterruptedException, TimeoutException { long expire = Time.currentElapsedTime() + timeout; long left = timeout; while(!connected && left > 0) { wait(left); left = expire - Time.currentElapsedTime(); } if (!connected) { throw new TimeoutException("Failed to connect to ZooKeeper server.");
Set<Artifact> findLibraryAndDependencies() throws Exception; Set<Artifact> findCompilerAndDependencies() throws Exception; }
public void setUp() throws Exception { Context ctx = InstrumentationRegistry.getInstrumentation().getTargetContext(); mPM = TestData.GetTest1(ctx); }
public Iterator<Integer> iterator() {
public boolean equals(Object id) { if ( ! (id instanceof PwGroupIdV4) ) { return false; } PwGroupIdV4 v4 = (PwGroupIdV4) id; return uuid.equals(v4.uuid); }
synchronized public void process(WatcherEvent event) { ReplyHeader h = new ReplyHeader(-1, -1L, 0); ZooTrace.logTraceMessage(LOG, ZooTrace.EVENT_DELIVERY_TRACE_MASK, "Deliver event " + event + " to " + this.sessionId + " through " + this); sendResponse(h, event, "notification"); }
public static void addTitles(HtmlPage page, String title) { page.setTitle(title); HtmlTag span = new HtmlTag("span"); span.addAttribute("class", "page_title"); span.add(title); page.header.use(span); }
private String replaceIfVariable(String arg) { if (isVariableReference(arg)) return replaceVariable(arg); return arg; }
public DeleteOperation delete(String key, DeleteOperation.Callback operationCallback) { return new DeleteOperationImpl(key, operationCallback); }
private boolean launchUrl(int resId) { try { Util.gotoUrl(this, resId); } catch (ActivityNotFoundException e) { Toast.makeText(this, R.string.error_failed_to_launch_link, Toast.LENGTH_LONG).show(); return false; } return true; }
public void testDeleteRecursiveInSyncMode() throws Exception { int batchSize = 0; testDeleteRecursiveInSyncAsyncMode(batchSize); }
public synchronized void reset() { numberOfElements.set(0); }
private String notMatchingSearchText() { return "this search text does not match any page"; }
public void shouldSerializeCollectionWithPrefixTag() { String expectedResult = "<order>\n <price>15.0</price>\n <comments>pack it nicely, please</comments>\n</order>"; expectedResult += expectedResult; expectedResult = "<orders>" + expectedResult + "</orders>"; Order order = new Order(new Client("guilherme silveira"), 15.0, "pack it nicely, please");
public final void testCloningGetSequence() { setupNodes(5); assertTrue(locator.getReadonlyCopy().getSequence("hi").next() instanceof MemcachedNodeROImpl);
public void rejectPasses() throws Exception { assertScriptResults("|reject|func|3|\n", list(
public Future<Boolean> append(long cas, String key, Object val) { return append(cas, key, val, transcoder); }
public void withViolations() { CustomerJSR303 customer0 = new CustomerJSR303(null, null); Assert.assertFalse(jsr303Validator.validate(customer0).isEmpty()); }
public InfoTypeAndValue[] toInfoTypeAndValueArray() { InfoTypeAndValue[] result = new InfoTypeAndValue[content.size()]; for (int i = 0; i != result.length; i++) { result[i] = InfoTypeAndValue.getInstance(content.getObjectAt(i)); } return result; }
private static boolean processCmd(String[] args, ZooKeeper zooKeeper) throws KeeperException, IOException, InterruptedException { Stat stat = new Stat(); if (args.length < 2) { return false; } if (args.length < 3) { usage(); return false; } String cmd = args[1]; boolean watch = args.length > 3; String path = args[2]; List<ACL> acl = Ids.OPEN_ACL_UNSAFE; System.out.println("Processing " + cmd); try { if (cmd.equals("create") && args.length >= 4) {
public void destroy() { } public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest req = (HttpServletRequest) request; HttpServletResponse res = (HttpServletResponse) response; String path = req.getContextPath(); String uri = req.getRequestURI().replaceFirst(path, ""); response.setLocale(uri.startsWith("/en")? Locale.ENGLISH : PT_BR); request.setAttribute("contextPath", uri.startsWith("/en")? path + "/en" : path); chain.doFilter(request, response); } public void init(FilterConfig fConfig) throws ServletException { } }
public void addRefOnError() throws IOException { sendTestComplete(ExecutionResult.ERROR, "ErrorPage"); formatter.close(); assertEquals(1, formatter.getErrorCount()); List<String> xrefs = getReferencedPages(); assertEquals(".Suite.ErrorPage", xrefs.get(0)); }
synchronized boolean connectOne(long sid, MultipleAddresses electionAddr) { if (senderWorkerMap.get(sid) != null) { LOG.debug("There is a connection already for server {}", sid); if (self.isMultiAddressEnabled() && electionAddr.size() > 1 && self.isMultiAddressReachabilityCheckEnabled()) {
RecoveryData verifyDigestAndReturnLastConfirmed(ChannelBuffer dataReceived) throws BKDigestMatchException { verifyDigest(dataReceived); dataReceived.readerIndex(8); long entryId = dataReceived.readLong(); long lastAddConfirmed = dataReceived.readLong(); return new RecoveryData(lastAddConfirmed, entryId);
public void testArgsWithNewCipher() throws Exception { boolean valid = password.args(new String[]{"-c", "fitnesse.authentication.TransparentCipher", "shredder"}); assertTrue(valid); assertEquals(TransparentCipher.class, password.getCipher().getClass());
public boolean isMoreRecentThan(StateSummary ss) { return (currentEpoch > ss.currentEpoch) || (currentEpoch == ss.currentEpoch && lastZxid > ss.lastZxid); }
public String toString() { List<String> criterias = new LinkedList<>(); if (matchTags.isFiltering()) { if(matchTags.andStrategy){ criterias.add("matches all of '" + matchTags.tagString + "'"); } else { criterias.add("matches '" + matchTags.tagString + "'"); } } if (notMatchTags.isFiltering()) { criterias.add("doesn't match '" + notMatchTags.tagString + "'"); } if (startWithTest != null) { criterias.add("starts with test '" + startWithTest + "'"); } return StringUtils.join(criterias, " & "); }
public void compress(Writer out, int linebreakpos) throws IOException { Pattern p; Matcher m; String css; StringBuffer sb; int startIndex, endIndex;
public void testHeaders() throws Exception { assertTrue(response.isReadyToSend()); String text = buffer.toString(); assertHasRegexp("Transfer-Encoding: chunked", text); assertTrue(text.startsWith("HTTP/1.1 200 OK\r\n")); assertHasRegexp("Content-Type: text/html", text); }
public void testDeleteCancellation() throws Exception { tryCancellation(client.delete("x")); }
public void gotData(String key, int flags, byte[] data) { ((GetOperation.Callback)originalCallback).gotData(key, flags, data); }
public boolean accepts(ResourceMethod method) { return ServletFileUpload.isMultipartContent(new ServletRequestContext(request)); }
public void setUp() throws Exception { super.setUp(); zooKeeper = createClient(); zooKeeper.create( TEST_ROOT_NODE + Thread.currentThread().getId(),
public Object call() throws Exception { return inner.call(instanceName, methodName, arguments); }
public int read(byte[] b) throws IOException { return read(b, 0, b.length); }
public void testWideDeserialize() throws KeeperException, InterruptedException, IOException { deserializeTree(2, 50000, 20); }
public void ensurePasses() throws Exception { assertScriptResults("|ensure|func|3|\n", ListUtility.<List<?>>list(
public final void writeComplete() { transitionState(State.READING); }
public void setup() { String testDataPath = System.getProperty("test.data.dir", "build/test/data"); System.setProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY, "org.apache.zookeeper.server.NettyServerCnxnFactory"); System.setProperty(ZooKeeper.ZOOKEEPER_CLIENT_CNXN_SOCKET, "org.apache.zookeeper.ClientCnxnSocketNetty"); System.setProperty(ZooKeeper.SECURE_CLIENT, "true"); System.setProperty(X509Util.SSL_KEYSTORE_LOCATION, testDataPath + "/ssl/testKeyStore.jks"); System.setProperty(X509Util.SSL_KEYSTORE_PASSWD, "testpass"); System.setProperty(X509Util.SSL_TRUSTSTORE_LOCATION, testDataPath + "/ssl/testTrustStore.jks"); System.setProperty(X509Util.SSL_TRUSTSTORE_PASSWD, "testpass"); System.setProperty("zookeeper.authProvider.x509", "org.apache.zookeeper.server.auth.X509AuthenticationProvider"); }
public void testVerify() throws Exception { final CertificateFactory cf = CertificateFactory.getInstance("X.509"); InputStream in; X509Certificate x509; in = new ByteArrayInputStream(CertificatesToPlayWith.X509_FOO); x509 = (X509Certificate) cf.generateCertificate(in); impl.verify("foo.com", x509); exceptionPlease(impl, "a.foo.com", x509); exceptionPlease(impl, "bar.com", x509); in = new ByteArrayInputStream(CertificatesToPlayWith.X509_HANAKO); x509 = (X509Certificate) cf.generateCertificate(in); impl.verify("\u82b1\u5b50.co.jp", x509); exceptionPlease(impl, "a.\u82b1\u5b50.co.jp", x509); in = new ByteArrayInputStream(CertificatesToPlayWith.X509_FOO_BAR); x509 = (X509Certificate) cf.generateCertificate(in); exceptionPlease(impl, "foo.com", x509); exceptionPlease(impl, "a.foo.com", x509); impl.verify("bar.com", x509); exceptionPlease(impl, "a.bar.com", x509); in = new ByteArrayInputStream(CertificatesToPlayWith.X509_FOO_BAR_HANAKO); x509 = (X509Certificate) cf.generateCertificate(in); exceptionPlease(impl, "foo.com", x509); exceptionPlease(impl, "a.foo.com", x509); impl.verify("bar.com", x509); exceptionPlease(impl, "a.bar.com", x509);
public void queryTableWithoutTableFunctionIgnoresMissingMethodException() throws Exception { getResultsForPageContents( "!|query:fitnesse.slim.test.DummyQueryTableWithNoTableMethod|\n" + "|x|\n" + "|1|\n" ); assertEquals(0, responder.getTestSummary().exceptions); }
protected void addValueContent(HtmlTag valueCell, Object entryValue) { if (entryValue != null) { Converter converter = ConverterRegistry.getConverterForClassOrStringConverter(entryValue.getClass());
public void testExceptionOccurred(Assertion assertion, ExceptionResult exceptionResult) { Instruction instruction = assertion.getInstruction(); Expectation expectation = assertion.getExpectation(); TestExecutionReport.InstructionResult instructionResult = new TestExecutionReport.InstructionResult(); currentResult.addInstruction(instructionResult); String id = instruction.getId(); instructionResult.instruction = instruction.toString(); try { TestExecutionReport.Expectation expectationResult = new TestExecutionReport.Expectation();
public ClassPath withLocationForClass(String testRunner) { String location = findLocationForClass(testRunner); if (location != null) { List<String> newElements = new ArrayList<>(); newElements.add(location); newElements.addAll(elements); return new ClassPath(newElements, separator); } return this; }
public String toString() { elapsed = (System.currentTimeMillis() - start); if (elapsed > 600000) {
public String toString() { return "LearnerHandlerBean{remoteIP=" + remoteAddr + ",ServerId=" + learnerHandler.getSid() + "}"; }
public void testDirCheckWithLogFilesInSnapDir() throws IOException { assertThrows(FileTxnSnapLog.SnapDirContentCheckException.class, () -> { twoDirSetupWithCorrectFiles();
public T execute(VRaptorRequest request, int counter) { Container secondContainer = provider.provide(request); if (componentToRegister != null && !isAppScoped(secondContainer, componentToRegister)) { secondContainer.register(componentToRegister); } ResourceMethod secondMethod = mockery.mock(ResourceMethod.class, "rm" + counter); secondContainer.instanceFor(RequestInfo.class).setResourceMethod(secondMethod); return secondContainer.instanceFor(component); }
public void addColumnToRow(int rowIndex, String contents) { Row row = rows.get(rowIndex); row.appendCell(Utils.escapeHTML(contents)); }
public void canBuildInstructionsForTableWithVariables() throws Exception { makeDecisionTableAndBuildInstructions( "|DT:fixture|\n" + "|var|func?|\n" + "|3|$V=|\n" + "|$V|9|\n" ); List<Object> expectedInstructions = list( list("decisionTable_id_0", "make", "decisionTable_id", "fixture"), list("decisionTable_id_1", "call", "decisionTable_id", "reset"), list("decisionTable_id_2", "call", "decisionTable_id", "setVar", "3"), list("decisionTable_id_3", "call", "decisionTable_id", "execute"), list("decisionTable_id_4", "callAndAssign", "V", "decisionTable_id", "func"), list("decisionTable_id_5", "call", "decisionTable_id", "reset"), list("decisionTable_id_6", "call", "decisionTable_id", "setVar", "$V"), list("decisionTable_id_7", "call", "decisionTable_id", "execute"), list("decisionTable_id_8", "call", "decisionTable_id", "func") ); assertEquals(expectedInstructions.toString(), instructions.toString()); }
public void publish() throws Exception { log.add("testSystem1", new ExecutionLog(testPage, runner, context.pageFactory)); log.add("testSystem2", new ExecutionLog(testPage, runner, context.pageFactory)); log.publish(); WikiPage errorLogPage = root.getChildPage(ErrorLogName); assertNotNull(errorLogPage); WikiPage testErrorLog = errorLogPage.getChildPage("TestPage"); assertNotNull(testErrorLog); String content = testErrorLog.getData().getContent(); assertSubString("!3 !-testSystem1", content); assertSubString("!3 !-testSystem2", content); assertSubString("'''Command: '''", content); assertSubString("!-some command-!", content); assertSubString("'''Exit code: '''", content); assertSubString("123", content); assertSubString("'''Date: '''", content); assertSubString("'''Time elapsed: '''", content); }
public void intercept(InterceptorStack stack, ResourceMethod method, Object resourceInstance) throws InterceptionException { } } public static class SecondInterceptor implements Interceptor { public boolean accepts(ResourceMethod method) { return false; } public void intercept(InterceptorStack stack, ResourceMethod method, Object resourceInstance) throws InterceptionException { } } @Test public void shouldAcceptAlways() { assertTrue(new InterceptorListPriorToExecutionExtractor(null).accepts(null)); } @Test public void shouldAddTheListOfInterceptorsAsFollowingInterceptors() throws InterceptionException, IOException { when(registry.all()).thenReturn(Arrays.asList(FirstInterceptor.class, SecondInterceptor.class)); extractor.intercept(this.stack, method, null); InOrder order = inOrder(stack); order.verify(stack).addAsNext(SecondInterceptor.class); order.verify(stack).addAsNext(FirstInterceptor.class); verify(stack).next(method, null); } }
public void processResults(InputStream input) throws Exception { StreamReader reader = new StreamReader(input); boolean readingResults = true; while(readingResults) { int bytesToRead = FitProtocol.readSize(reader); if(bytesToRead != 0) { String resultString = reader.read(bytesToRead); PageResult result = PageResult.parse(resultString); formatter.acceptResult(result); } else readingResults = false; } formatter.acceptFinalCount(FitProtocol.readCounts(reader)); }
public <T> T instanceFor(Class<T> type) { return injector.getInstance(type); }
public void withValidation() { } }; final ResourceMethod method = mockery.methodFor(MyComponent.class, "withValidation"); mockery.checking(new Expectations() { { one(provider).getParametersFor(method); will(returnValue(new Object[0])); one(stack).next(method, resourceInstance); one(errors).size(); will(returnValue(0)); } }); validator.intercept(stack, method, resourceInstance); mockery.assertIsSatisfied(); } }
public void testSymbolicLinkListing() throws Exception { WikiPage page = root.addChildPage("SomePage"); page.addChildPage("SomeChild"); WikiPage pageOne = root.addChildPage("PageOne");
public void visitLabel(final Label label) { instructions.add(getLabelNode(label)); }
public Socket createSocket(final String hostName, final int port) throws IOException { LOG.log(Level.FINER, "Creating SSL client: " + hostName + ":" + port); SSLSocketFactory ssf = sslParameters.createSSLSocketFactory(); SSLSocket socket = (SSLSocket) ssf.createSocket(hostName, port); LOG.log(Level.FINER, "Starting SSL Handshake.");
public void shouldConvertIgnoringCase() { assertThat((Boolean) converter.convert("truE", boolean.class, bundle), is(equalTo(true))); assertThat((Boolean) converter.convert("FALSE", boolean.class, bundle), is(equalTo(false))); assertThat((Boolean) converter.convert("On", boolean.class, bundle), is(equalTo(true))); assertThat((Boolean) converter.convert("oFf", boolean.class, bundle), is(equalTo(false))); }
public void shouldAcceptCaseInsensitiveGetRequestUsingThe_methodParameter() { final ResourceMethod expected = mockery.mock(ResourceMethod.class); mockery.checking(new Expectations(){{ one(request).getAttribute(DefaultResourceTranslator.INCLUDE_REQUEST_URI); will(returnValue(null)); one(request).getRequestURI(); will(returnValue("/url")); one(request).getParameter("_method"); will(returnValue("gEt")); one(registry).parse("/url", HttpMethod.GET, webRequest); will(returnValue(expected)); }}); ResourceMethod resource = translator.translate(webRequest); assertThat(resource, is(equalTo(expected))); mockery.assertIsSatisfied(); }
protected void decodePayload(byte[] pl) { getCallback().receivedStatus(new OperationStatus(true, String.valueOf(decodeLong(pl, 0)), StatusCode.SUCCESS));
protected HtmlPage prepareResponseDocument(FitNesseContext context) { HtmlPage responseDocument = context.pageFactory.newPage(); responseDocument.addTitles("Default Responder"); responseDocument.setMainTemplate("defaultPage.vm"); return responseDocument; }
public Double fromString(String arg) { return !StringUtils.isBlank(arg) ? Double.valueOf(arg) : null; }
public void add(User user) { if (user == null) { return; } result.include("user", user); validateAdd(user); this.factory.getUserDao().add(user); result.use(Results.logic()).redirectTo(UserController.class).userAdded(user); }
public void checkout(String... filePaths) throws RevisionControlException; public void delete(String... filePaths) throws RevisionControlException; public void revert(String... filePaths) throws RevisionControlException; public State checkState(String... filePaths) throws RevisionControlException; public void update(String... filePaths) throws RevisionControlException; public void move(File src, File dest) throws RevisionControlException; public PageData getRevisionData(FileSystemPage page, String label) throws Exception; public Collection<VersionInfo> history(FileSystemPage page) throws Exception; public VersionInfo makeVersion(FileSystemPage page, PageData data) throws Exception; public void removeVersion(FileSystemPage page, String versionName) throws Exception; public void prune(FileSystemPage page) throws Exception; public boolean isExternalReversionControlEnabled(); }
static String defaultTestRunner(PageData data) throws Exception { String testSystemType = getTestSystemType(getTestSystem(data)); if ("slim".equalsIgnoreCase(testSystemType)) return "fitnesse.slim.SlimService";
public void testChangedByNotSet() throws Exception { final String input = "release distribution=production, date=14:00 13.01.2007, version=12324, urgency=low\n" + " * change1\n" + " * change2\n"; BinaryPackageControlFile packageControlFile = new BinaryPackageControlFile(); packageControlFile.set("Package", "package"); packageControlFile.set("Version", "version"); packageControlFile.set("Date", "Mon, 20 Aug 2007 15:25:57 +0200"); final TextfileChangesProvider provider = new TextfileChangesProvider(new ByteArrayInputStream(input.getBytes("UTF-8")), packageControlFile); final ChangeSet[] changeSets = provider.getChangesSets(); assertNotNull(changeSets); assertEquals(1, changeSets.length); ChangesFile changesFile = new ChangesFile(); changesFile.setChanges(provider.getChangesSets()); changesFile.initialize(packageControlFile); assertNotNull(changesFile); assertEquals(null, changesFile.get("Changed-By")); }
public void portRotates() throws Exception { for (int i = 1; i < 15; i++) { SlimClientBuilder descriptor = new SlimClientBuilder(root.getData(), ClientBuilder.getDescriptor(root, false));
public void testServerHostnameVerificationWithHostnameVerificationDisabled() throws Exception { VerifiableHostnameVerifier hostnameVerifier = new VerifiableHostnameVerifier(); ZKTrustManager zkTrustManager = new ZKTrustManager(mockX509ExtendedTrustManager, false, false, hostnameVerifier); X509Certificate[] certificateChain = createSelfSignedCertifcateChain(IP_ADDRESS, HOSTNAME); zkTrustManager.checkServerTrusted(certificateChain, null, mockSocket); verify(mockSocket, times(0)).getInetAddress(); assertTrue(hostnameVerifier.hosts.isEmpty()); verify(mockX509ExtendedTrustManager, times(1)).checkServerTrusted(certificateChain, null, mockSocket); }
public void canEvaluateReturnValuesAndColorizeTable() throws Exception { DecisionTable dt = makeDecisionTableAndBuildInstructions(simpleDecisionTable); Map<String, Object> pseudoResults = SlimClient.resultToMap( list( list("decisionTable_id_0", "OK"), list("decisionTable_id_1", "set"), list("decisionTable_id_3", "5"), list("decisionTable_id_4", "set"), list("decisionTable_id_6", "5") ) ); dt.evaluateExpectations(pseudoResults); String colorizedTable = dt.getTable().toString(); String expectedColorizedTable = "|!style_pass(DT:fixture)|argument|\n" + "|var|func?|\n" + "|3|!style_pass(5)|\n" + "|7|!style_fail([5] expected [9])|\n"; assertEquals(expectedColorizedTable, colorizedTable); }
public void setUp() throws Exception { MockitoAnnotations.initMocks(this); representation = new DefaultRepresentationResult(formatResolver, result, Arrays.asList(serialization), headerHandler); }
private WikiPage addPage(String pageName, String content) throws Exception { return pageBuilder.addPage(root, PathParser.parse(pageName), content); }
TxnIterator read(long zxid) throws IOException;  long getLastLoggedZxid() throws IOException;  boolean truncate(long zxid) throws IOException;  long getDbId() throws IOException;  void commit() throws IOException;  long getTxnLogSyncElapsedTime();  void close() throws IOException;  public interface TxnIterator {  TxnHeader getHeader();  Record getTxn();  boolean next() throws IOException;  void close() throws IOException;  long getStorageSize() throws IOException; } }
private boolean isInteractive() { return mainFormatter instanceof InteractiveFormatter; }
public boolean isValid(String id) { return addr2Bytes(id) != null; }
public void testThatVariablesWorkInPreformattedText() throws Exception { ParentWidget root = new WidgetRoot("!define X {123}\n{{{abc ${X} xyz}}}", new WikiPageDummy(), WidgetBuilder.htmlWidgetBuilder); String text = root.render(); assertSubString("<pre>abc 123 xyz</pre>", text); }
private void replaceIfUnignoredException(String resultKey, String resultString) { if (resultString.indexOf(SlimServer.EXCEPTION_TAG) == -1) { return; } if (shouldReportException(resultKey, resultString)) replaceException(resultKey, resultString);
public Object get(String instanceName, String variableName) { return new FieldAccessor(instanceName, variableName).get(); }
public void testGetHostAndPortWithoutPort() throws ConfigException { String[] nsa = ConfigUtils.getHostAndPort("127.0.0.1"); assertEquals(nsa[0], "127.0.0.1"); assertEquals(nsa.length, 1); nsa = ConfigUtils.getHostAndPort("[2001:db8:1::242:ac11:2]"); assertEquals(nsa[0], "2001:db8:1::242:ac11:2"); assertEquals(nsa.length, 1); }
public void testTableSorterScript() throws Exception { String content = getResponseContentUsingSearchString("something"); assertSubString("tableSorter = new TableSorter('searchResultsTable', new DateParser(/^(\\w+) (jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec) (\\d+) (\\d+).(\\d+).(\\d+) (\\w+) (\\d+)$/,8,2,3,4,5,6));", content); }
public void methodAcceptsTestSlimFromSymbol() throws Exception { statements.add(list("id1", "callAndAssign", "v", "testSlim", "createTestSlimWithString", "test string")); statements.add(list("id2", "call", "testSlim", "getStringFromOther", "$v")); respondsWith(list( list("id1", (Object) "TestSlim: 0, test string"),
public void teardown() throws Exception { System.clearProperty(ServerCnxnFactory.ZOOKEEPER_SERVER_CNXN_FACTORY); System.clearProperty(ZKClientConfig.ZOOKEEPER_CLIENT_CNXN_SOCKET); System.clearProperty(ZKClientConfig.SECURE_CLIENT); System.clearProperty(clientX509Util.getSslAuthProviderProperty()); System.clearProperty(clientX509Util.getSslKeystoreLocationProperty()); System.clearProperty(clientX509Util.getSslKeystorePasswdProperty()); System.clearProperty(clientX509Util.getSslTruststoreLocationProperty()); System.clearProperty(clientX509Util.getSslTruststorePasswdProperty()); System.clearProperty("javax.net.debug"); System.clearProperty("zookeeper.authProvider.x509"); }
public void shouldThrowIllegalArgumentIfIdIsNotConvertable() throws Exception { when(provider.parameterNamesFor(method.getMethod())).thenReturn(new String[] {"entity"}); when(request.getParameter("entity.id")).thenReturn("123"); when(converters.to(Long.class)).thenReturn(null); fail().when(request).setAttribute(eq("entity"), any()); fail().when(result).notFound(); fail().when(stack).next(method, instance); when(session.getSessionFactory()).thenReturn(sessionFactory); when(sessionFactory.getClassMetadata(any(Class.class))).thenReturn(classMetadata); when(classMetadata.getIdentifierPropertyName()).thenReturn("id"); when(classMetadata.getIdentifierType()).thenReturn(type); when(type.getReturnedClass()).thenReturn(Long.class); interceptor.intercept(stack, method, instance); }
private boolean isObjectArrayReturnType() { Class returnType = getReturnType(); return returnType.isArray() && !returnType.getComponentType().isArray() &&
@Override public boolean isExpired(String key, Dummy value, long lastModified) { return key.length() == 3; }
String getCellResult(int col,int row); void appendChildTable(int row, Table table); void setTestStatusOnRow(int row, ExecutionResult testStatus); void setCell(int col, int row, Result response); void appendToCell(int col, int row, Result response); }
Future<Object> asyncGet(String key); Future<CASValue<Object>> asyncGetAndTouch(final String key, final int exp); <T> Future<CASValue<T>> asyncGetAndTouch(final String key, final int exp, final Transcoder<T> tc); CASValue<Object> getAndTouch(String key, int exp); <T> CASValue<T> getAndTouch(String key, int exp, Transcoder<T> tc); <T> Future<CASValue<T>> asyncGets(String key, Transcoder<T> tc); Future<CASValue<Object>> asyncGets(String key); <T> CASValue<T> gets(String key, Transcoder<T> tc); CASValue<Object> gets(String key); <T> T get(String key, Transcoder<T> tc); Object get(String key); <T> BulkFuture<Map<String, T>> asyncGetBulk(Iterator<String> keys, Iterator<Transcoder<T>> tcs); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Iterator<Transcoder<T>> tcs); <T> BulkFuture<Map<String, T>> asyncGetBulk(Iterator<String> keys, Transcoder<T> tc); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); BulkFuture<Map<String, Object>> asyncGetBulk(Iterator<String> keys); BulkFuture<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> BulkFuture<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); BulkFuture<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Iterator<String> keys, Transcoder<T> tc); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc); Map<String, Object> getBulk(Iterator<String> keys); Map<String, Object> getBulk(Collection<String> keys); <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys); Map<String, Object> getBulk(String... keys); <T> Future<Boolean> touch(final String key, final int exp, final Transcoder<T> tc); <T> Future<Boolean> touch(final String key, final int exp); Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, long by); long incr(String key, int by); long decr(String key, long by); long decr(String key, int by); long incr(String key, long by, long def, int exp); long incr(String key, int by, long def, int exp); long decr(String key, long by, long def, int exp); long decr(String key, int by, long def, int exp); Future<Long> asyncIncr(String key, long by); Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, long by); Future<Long> asyncDecr(String key, int by); long incr(String key, long by, long def); long incr(String key, int by, long def); long decr(String key, long by, long def); long decr(String key, int by, long def); Future<Boolean> delete(String key); Future<Boolean> delete(String key, long cas); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs); CountDownLatch broadcastOp(final BroadcastOpFactory of); CountDownLatch broadcastOp(final BroadcastOpFactory of, Collection<MemcachedNode> nodes);  Set<String> listSaslMechanisms(); }
public void fromString_should_return_null_object_when_value_is_not_defined() { } @Test public void fromString_should_return_default_object_when_value_is_not_defined() { String value = ""; Double current = converter.fromString(value); assertNotNull(current); assertEquals(PrimitiveDoubleConverter.DEFAULT_VALUE, current); } }
private void verifyDefaultLinks(String html, String pageName) { assertSubString("<a href=\"" + pageName + "?edit\" accesskey=\"e\">Edit</a>", html); assertSubString("<a href=\"" + pageName + "?versions\" accesskey=\"v\">Versions</a>", html); assertSubString("<a href=\"" + pageName + "?properties\" accesskey=\"p\">Properties</a>", html); assertSubString("<a href=\"" + pageName + "?refactor&amp;type=rename\">Rename</a>", html); assertSubString("<a href=\"" + pageName + "?whereUsed\" accesskey=\"w\">Where Used</a>", html); assertSubString("<a href=\"/files\" accesskey=\"f\">Files</a>", html); assertSubString("<a href=\"?responder=search\" accesskey=\"s\">Search</a>", html); assertSubString("<a href=\"/FitNesse.UserGuide\" accesskey=\"\">User Guide</a>", html); }
public boolean include(Artifact artifact) {
public Object methodInvoke(Method method, Object instance, Object... convertedArgs) throws InvocationTargetException, IllegalAccessException { Object result = super.methodInvoke(method, instance, convertedArgs); if (result instanceof String) { result = ((String) result).toUpperCase(); } return result; }
NodeLocator createLocator(List<MemcachedNode> nodes);  OperationFactory getOperationFactory();  long getOperationTimeout();  boolean isDaemon();  boolean useNagleAlgorithm();  boolean getKeepAlive();  Collection<ConnectionObserver> getInitialObservers();  FailureMode getFailureMode();  Transcoder<Object> getDefaultTranscoder();  boolean shouldOptimize();  int getReadBufSize();  HashAlgorithm getHashAlg();  long getMaxReconnectDelay();  AuthDescriptor getAuthDescriptor();  int getTimeoutExceptionThreshold();  MetricType enableMetrics();  MetricCollector getMetricCollector();  long getAuthWaitTime(); }
public static Set<ObjectName> ensureAll(String... expectedNames) throws IOException, InterruptedException { Set<ObjectName> beans; Set<ObjectName> found; int nTry = 0; do { if (nTry++ > 0) { Thread.sleep(100); } try { beans = conn().queryNames( new ObjectName(MBeanRegistry.DOMAIN + ":*"), null); } catch (MalformedObjectNameException e) { throw new RuntimeException(e); } found = new HashSet<ObjectName>(); for (String name : expectedNames) { LOG.info("expect:" + name); for (ObjectName bean : beans) { if (bean.toString().contains(name)) { LOG.info("found:" + name + " " + bean); found.add(bean); break; } } beans.removeAll(found); } } while ((expectedNames.length != found.size()) && (nTry < 600)); Assert.assertEquals("expected " + Arrays.toString(expectedNames), expectedNames.length, found.size()); return beans; }
protected String simpleTable(String fixtureName) { return "<table>" + "<tr><td>fit." + fixtureName + "</td></tr>" +
public void shortcutKeyDifferent() throws Exception { aa.setShortcutKey("b"); assertFalse(aa.equals(a)); assertFalse(a.equals(aa)); }
public void setup() { this.mockery = new Mockery(); this.stack = mockery.mock(InterceptorStack.class); this.outjecter = new JsonOutjecter(); this.info = mockery.mock(ComponentInfoProvider.class); this.response = mockery.mock(HttpServletResponse.class); this.interceptor = new AjaxInterceptor(outjecter, response, info); }
private void verifyFuzzyMatch(String cmd, String expected) throws IOException, SSLContextException { String resp = sendRequest(cmd); LOG.info("cmd " + cmd + " expected " + expected + " got " + resp); assertTrue(resp.contains(expected)); }
public void loadConf(URL confURL) throws ConfigurationException { super.loadConf(confURL); refreshDerivedAttributes(); }
public void testPathWithVariable() throws Exception { String text = "!define BASE {/my/base/}\n!path ${BASE}*.jar\n"; ParentWidget root = new WidgetRoot(text, new WikiPageDummy()); String html = root.render(); assertSubString("/my/base/*.jar", html); }
@Test public void translatesLinkWithVariable() { ParserTestHelper.assertTranslatesTo("http://${site}", new TestVariableSource("site", "mysite.org"), "<a href=\"http://mysite.org\">http://mysite.org</a>"); }
String toHtml(); void setCell(int col, int row, String contents); int addRow(List<String> list) throws Exception; void appendCellToRow(int row, String contents) throws Exception; String getUnescapedCellContents(int col, int row); String getCellResult(int col,int row); void appendChildTable(int row, Table table); void setTestStatusOnRow(int row, ExecutionResult testStatus); void setName(String tableName); void setCell(int col, int row, Response response); void appendToCell(int col, int row, Response response); }
protected void setupRequestProcessors() { RequestProcessor finalProcessor = new FinalRequestProcessor(this); RequestProcessor toBeAppliedProcessor = new Leader.ToBeAppliedRequestProcessor( finalProcessor, getLeader().toBeApplied); commitProcessor = new CommitProcessor(toBeAppliedProcessor, Integer.toString(getClientPort()), false); RequestProcessor proposalProcessor = new ProposalRequestProcessor(this, commitProcessor); firstProcessor = new PrepRequestProcessor(this, proposalProcessor); }
public void unableToStartTestSystem(String testSystemName, Throwable cause) { notifyOfTestSystemException(testSystemName, cause); }
public void testWorkerThreads() throws Exception { ArrayList<QuorumPeer> peerList = new ArrayList<>(); try { for (int sid = 0; sid < 3; sid++) {
public String makeFullPathOfTarget(String wikiWordPath) { return targetPath; }
public void setConnectionFreezeTime(int val); public double getConnectionDropIncrease(); public void setConnectionDropIncrease(double val); public double getConnectionDropDecrease(); public void setConnectionDropDecrease(double val); public double getConnectionDecreaseRatio(); public void setConnectionDecreaseRatio(double val); public int getCommitProcMaxReadBatchSize(); public void setCommitProcMaxReadBatchSize(int size); public int getCommitProcMaxCommitBatchSize(); public void setCommitProcMaxCommitBatchSize(int size); public int getRequestThrottleLimit(); public void setRequestThrottleLimit(int requests); public int getRequestThrottleStallTime(); public void setRequestThrottleStallTime(int time); public boolean getRequestThrottleDropStale(); public void setRequestThrottleDropStale(boolean drop); public boolean getRequestStaleLatencyCheck(); public void setRequestStaleLatencyCheck(boolean check); public boolean getRequestStaleConnectionCheck(); public void setRequestStaleConnectionCheck(boolean check);  public void resetStatistics();  public void resetLatency();  public void resetMaxLatency();  public void resetFsyncThresholdExceedCount();  public long getNumAliveConnections();  public long getDataDirSize();  public long getLogDirSize();  public String getSecureClientPort();  public String getSecureClientAddress();  public long getTxnLogElapsedSyncTime();  public int getJuteMaxBufferSize();  public int getLastClientResponseSize();  public int getMinClientResponseSize();  public int getMaxClientResponseSize(); public long getFlushDelay(); public void setFlushDelay(long delay); public long getMaxWriteQueuePollTime(); public void setMaxWriteQueuePollTime(long delay); public int getMaxBatchSize(); public void setMaxBatchSize(int size); }
private void createAndSaveANewPage(String pageName) throws Exception { WikiPage simplePage = WikiPageUtil.addPage(root, PathParser.parse(pageName)); PageData data = simplePage.getData(); SaveRecorder.pageSaved(simplePage, 0); simplePage.commit(data); }
public void tearDown() throws Exception { LOG.info("tearDown starting"); for (int i = 0; i < zkClients.length; i++) { zkClients[i].close(); } qu.shutdownAll(); }
private void errorMessage(int resId) { Toast.makeText(mActivity, resId, Toast.LENGTH_LONG).show(); }
public void testConsCommandSecureOnly() {
public void testGetAbsolutePathForChild() throws Exception { WikiPagePath somePagePath = PathParser.parse("SomePage"); WikiPagePath somePageFullPath = crawler.getFullPathOfChild(root, somePagePath); assertEquals("SomePage", PathParser.render(somePageFullPath)); WikiPagePath pageOnePath = page1Path; WikiPagePath pageOneFullPath = crawler.getFullPathOfChild(root, pageOnePath); assertEquals("PageOne", PathParser.render(pageOneFullPath)); WikiPagePath SomePageChildFullPath = child1.getPageCrawler().getFullPathOfChild(child1, somePagePath); assertEquals("PageOne.ChildOne.SomePage", PathParser.render(SomePageChildFullPath)); WikiPagePath otherPagePath = PathParser.parse("SomePage.OtherPage"); WikiPagePath otherPageFullPath = crawler.getFullPathOfChild(root, otherPagePath); assertEquals("SomePage.OtherPage", PathParser.render(otherPageFullPath)); WikiPagePath somePageAbsolutePath = PathParser.parse(".SomePage"); WikiPagePath somePageAbsoluteFullPath = child1.getPageCrawler().getFullPathOfChild(child1, somePageAbsolutePath); assertEquals("SomePage", PathParser.render(somePageAbsoluteFullPath)); }
public <T extends View> T or(Class<T> view) { return result.use(view); }
public void carriageReturnsShouldNotMatterIfPresentOnPage() throws Exception { WikiPage page = crawler.addPage(rootPage, PathParser.parse("TestPage"), "''italics''\r\n\r'''bold'''\r\n\r"); PageData data = page.getData(); String html = data.getHtml(); assertEquals("<i>italics</i>" + HtmlElement.endl + "<br/>" + HtmlElement.endl
public void testSaslConfig() throws Exception { ZooKeeper zk = createClient(); try { zk.getChildren("/", false);
public String summarize(long startTime) { return "Finished " + label + ": count = " + done.get() + ", tput = " + calcTp(count, startTime) + " ops/s, numFailed = " + numFailed;
public void setup() throws SecurityException, NoSuchMethodException { MockitoAnnotations.initMocks(this); this.extractor = new InterceptorListPriorToExecutionExtractor(registry); }
private boolean tagsMatch(String queryTag, String testTag) { return equalsIgnoreCase(trim(testTag), trim(queryTag)); }
public void whenListContainsOneElementExpectOneListItem() {
public void testInt() throws Exception { assertEquals(923, tc.decode(tc.encode(923))); }
public Object convert(String value) { if(value==null) {
protected void evaluateReturnValues(Map<String, Object> returnValues) throws Exception { } private class ScriptActionExpectation extends Expectation { private ScriptActionExpectation(int instructionNumber, int col, int row) { super(null, instructionNumber, col, row); } protected String createEvaluationMessage(String value, String originalValue) { if (value == null) return failMessage(table.literalize(originalValue), "Returned null value."); else if (value.equals(VoidConverter.VOID_TAG) || value.equals("null")) return table.literalize(originalValue); else if (value.equals(BooleanConverter.FALSE)) return fail(table.literalize(originalValue)); else if (value.equals(BooleanConverter.TRUE)) return pass(table.literalize(originalValue)); else return table.literalize(originalValue); } } private class EnsureActionExpectation extends Expectation { public EnsureActionExpectation(int instructionNumber, int col, int row) { super(null, instructionNumber, col, row); } protected String createEvaluationMessage(String value, String originalValue) { return (value != null && value.equals(BooleanConverter.TRUE)) ? pass(table.literalize(originalValue)) : fail(table.literalize(originalValue)); } } private class RejectActionExpectation extends Expectation { public RejectActionExpectation(int instructionNumber, int col, int row) { super(null, instructionNumber, col, row); } protected String createEvaluationMessage(String value, String originalValue) { if (value == null) return pass(table.literalize(originalValue)); else return value.equals(BooleanConverter.FALSE) ? pass(table.literalize(originalValue)) : fail(table.literalize(originalValue)); } } private class ShowActionExpectation extends Expectation { public ShowActionExpectation(int instructionNumber, int col, int row) { super(null, instructionNumber, col, row); } protected String createEvaluationMessage(String value, String originalValue) { try { table.appendCellToRow(row, String.format("|!style_ignore(%s)", table.literalize(value))); } catch (Throwable e) { return failMessage(table.literalize(value), SlimTestSystem.exceptionToString(e)); } return originalValue; } } private class ArgumentExpectation extends Expectation { private ArgumentExpectation(int instructionNumber, int col, int row) { super(null, instructionNumber, col, row); } protected String createEvaluationMessage(String value, String originalValue) { return table.literalize(replaceSymbolsWithFullExpansion(originalValue)); } } }
public int findWikiWordLength(String text) { String candidate = text + "."; int offset = "<>^.".contains(candidate.substring(0, 1)) ? 1 : 0; while (offset < candidate.length()) { int dot = candidate.indexOf(".", offset); int word = wikiWordLength(candidate.substring(offset, dot)); if (word == 0) return offset > 1 ? offset - 1 : 0; if (offset + word < dot) return offset + word; offset = dot + 1; } return text.length(); }
public static Collection<Object[]> configs() { return Arrays.asList(new Object[][]{{false}, {true}}); }
public void testClientOpWithFailedSASLAuth() throws Exception { ZooKeeper zk = null; CountdownWatcher watcher = new CountdownWatcher(); try { zk = createClient(watcher);
protected byte[] buildResponse(SaslClient sc) throws SaslException { return sc.hasInitialResponse() ? sc.evaluateChallenge(challenge) : EMPTY_BYTES;
public Maybe<String> findVariable(WikiPage page, String name) { if (!cache.containsKey(page)) return Maybe.noString; if (!cache.get(page).containsKey(name)) return Maybe.noString; return cache.get(page).get(name); }
public void intercept(InterceptorStack stack, ResourceMethod method, Object resourceInstance) throws InterceptionException { stack.next(method, resourceInstance); }
public void testQuorumPeerListendOnSpecifiedClientIP() throws IOException { long myId = 1; File dataDir = ClientBase.createTmpDir(); int clientPort = PortAssignment.unique(); Map<Long, QuorumServer> peersView = new HashMap<>(); InetAddress clientIP = InetAddress.getLoopbackAddress(); peersView.put(Long.valueOf(myId), new QuorumServer(myId, new InetSocketAddress(clientIP, PortAssignment.unique()), new InetSocketAddress(clientIP, PortAssignment.unique()), new InetSocketAddress(clientIP, clientPort), LearnerType.PARTICIPANT));  QuorumPeer peer1 = new QuorumPeer(peersView, dataDir, dataDir, clientPort, electionAlg, myId, tickTime, initLimit, syncLimit, connectToLearnerMasterLimit); String hostString1 = peer1.cnxnFactory.getLocalAddress().getHostString(); assertEquals(clientIP.getHostAddress(), hostString1);
public void testCircularBlockingQueue() throws InterruptedException { final CircularBlockingQueue<Integer> testQueue = new CircularBlockingQueue<>(2); testQueue.offer(1); testQueue.offer(2); testQueue.offer(3); Assert.assertEquals(2, testQueue.size()); Assert.assertEquals(2, testQueue.take().intValue()); Assert.assertEquals(3, testQueue.take().intValue()); Assert.assertEquals(1L, testQueue.getDroppedCount()); Assert.assertEquals(0, testQueue.size()); Assert.assertEquals(true, testQueue.isEmpty()); }
public void shouldNotCacheIfLoadedValueIsNull() throws Exception { final List<Integer> calls = new ArrayList<Integer>(); Cache<String, Dummy> cache = new Cache.Builder<String, Dummy>() .withLoader(new Cache.Loader<String, Dummy>() { @Override public Dummy fetch(String key) { calls.add(1); return null; } }) .build(); cache.get("s"); assertEquals(1, calls.size()); cache.get("s"); assertEquals(2, calls.size());
public void read(InputStream input) throws IOException { int b = input.read(); if (b == -1) { changeState(FINAL_STATE);
public void testSaslRequiredInvalidCredentials() throws Exception { Map<String, String> authConfigs = new HashMap<String, String>(); authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT, "QuorumLearnerInvalid"); authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, "true"); authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, "true"); authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, "true"); int serverCount = 2; final int[] clientPorts = startQuorum(serverCount, new StringBuilder(), authConfigs, serverCount); for (int i = 0; i < serverCount; i++) { boolean waitForServerUp = ClientBase.waitForServerUp(
public long approximateDataSize();  public int countEphemerals(); }
public void onClick(DialogInterface dialog, int which) { Context ctx = getContext(); SharedPreferences prefs = PreferenceManager.getDefaultSharedPreferences(ctx); SharedPreferences.Editor edit = prefs.edit(); edit.putBoolean(ctx.getString(showKey), false); edit.commit(); dismiss(); }
protected <T> T registerAndGetFromContainer(final Class<T> componentToBeRetrieved, final Class<?> componentToRegister) { return executeInsideRequest(new WhatToDo<T>() { public T execute(RequestInfo request, final int counter) {
public void setConnectionDropIncrease(double val); public double getConnectionDropDecrease(); public void setConnectionDropDecrease(double val); public double getConnectionDecreaseRatio(); public void setConnectionDecreaseRatio(double val);  public void resetStatistics();  public void resetLatency();  public void resetMaxLatency();  public void resetFsyncThresholdExceedCount();  public long getNumAliveConnections();  public long getDataDirSize();  public long getLogDirSize();  public String getSecureClientPort();  public String getSecureClientAddress();  public long getTxnLogElapsedSyncTime();  public int getJuteMaxBufferSize();  public int getLastClientResponseSize();  public int getMinClientResponseSize();  public int getMaxClientResponseSize(); public long getFlushDelay(); public void setFlushDelay(long delay); public long getMaxWriteQueuePollTime(); public void setMaxWriteQueuePollTime(long delay); public int getMaxBatchSize(); public void setMaxBatchSize(int size); }
public void testDontRenameToExistingPage() throws Exception { WikiPageUtil.addPage(root, pageOnePath, "Page one content"); WikiPageUtil.addPage(root, pageTwoPath, "Page two content"); Response response = doRename(pageOneName, pageTwoName, true); PageCrawler crawler = root.getPageCrawler(); assertTrue(crawler.pageExists(pageOnePath)); assertTrue(crawler.pageExists(pageTwoPath)); assertEquals("Page two content", root.getChildPage(pageTwoName).getData().getContent()); assertSubString("Cannot rename", getResponseContent(response)); }
public final void visitIntInsn(final int opcode, final int operand) { AttributesImpl attrs = new AttributesImpl(); attrs.addAttribute("", "value", "value", "", Integer.toString(operand)); addElement(AbstractVisitor.OPCODES[opcode], attrs); }
public void setUp() throws Exception { root = InMemoryPage.makeRoot("RooT"); crawler = root.getPageCrawler(); searcher = new PageSearcher(); page = crawler.addPage(root, PathParser.parse("TestPage")); }
public void testTwoChunks() throws Exception { buffer = new StringBuilder(); response.add("one"); response.add("two"); String text = buffer.toString(); assertEquals("3\r\none\r\n3\r\ntwo\r\n", text); }
public void addPluginsToClassLoader() throws Exception { if (pluginsDirectory.exists()) for (File plugin : pluginsDirectory.listFiles())
public static void Launch(Activity act) { Intent i = new Intent(act, DatabaseSettingsActivity.class); act.startActivity(i); }
public static void launchFitNesse(Arguments arguments) throws Exception { loadPlugins(); FitNesseContext context = loadContext(arguments); Updater updater = null; if (!arguments.isOmittingUpdates()) updater = new UpdaterImplementation(context); PageVersionPruner.daysTillVersionsExpire = arguments .getDaysTillVersionsExpire(); FitNesse fitnesse = new FitNesse(context, updater); updateAndLaunch(arguments, context, fitnesse); }
public void testClasspathWithVariable() throws Exception { WikiPage root = InMemoryPage.makeRoot("RooT"); WikiPage page = pageBuilder.addPage(root, PathParser.parse("ClassPath"), "!define PATH {/my/path}\n!path ${PATH}.jar"); List<?> paths = page.getData().getClasspaths(); assertEquals("/my/path.jar", paths.get(0).toString()); PageData data = root.getData(); data.setContent("!define PATH {/my/path}\n"); root.commit(data); page = pageBuilder.addPage(root, PathParser.parse("ClassPath2"), "!path ${PATH}.jar"); paths = page.getData().getClasspaths(); assertEquals("/my/path.jar", paths.get(0).toString()); }
private void makeEditForm(HtmlPage html, String resource, boolean firstTimeForNewPage, String defaultNewPageContent) { html.put("resource", resource); html.put(TIME_STAMP, String.valueOf(SaveRecorder.timeStamp())); html.put(TICKET_ID, String.valueOf(SaveRecorder.newTicket())); if (request.hasInput("redirectToReferer") && request.hasHeader("Referer")) { String redirectUrl = request.getHeader("Referer").toString(); int questionMarkIndex = redirectUrl.indexOf("?"); if (questionMarkIndex > 0) redirectUrl = redirectUrl.substring(0, questionMarkIndex); redirectUrl += "?" + request.getInput("redirectAction").toString(); html.put("redirect", redirectUrl); } html.put(HELP_TEXT, pageData.getAttribute(PageData.PropertyHELP)); html.put(TEMPLATE_MAP, TemplateUtil.getTemplateMap(page)); html.put("suites", pageData.getAttribute(PageData.PropertySUITES)); html.put(CONTENT_INPUT_NAME, HtmlUtil.escapeHTML(firstTimeForNewPage ? defaultNewPageContent : content)); }
public TagGroup makeTailHtml(WikiImporter importer) throws Exception { TagGroup tail = new TagGroup(); tail.add("<a name=\"end\"><hr></a>"); tail.add(HtmlUtil.makeBold("Import complete. ")); addUnmodifiedCount(importer, tail); tail.add(HtmlUtil.BR); addImportedPageCount(importer, tail); addOrphanedPageSection(importer, tail); addAutoUpdateMessage(importer, tail); return tail; }
public boolean isMatchingTest(WikiPage testPage) throws Exception { PageData data = testPage.getData(); boolean pruned = data.hasAttribute(PageData.PropertyPRUNE); boolean isTest = data.hasAttribute("Test"); return !pruned && isTest &&
public void shutdown() { try { if (s != null && !s.isClosed()) { s.close(); } } catch (IOException e) { LOG.error("FIXMSG",e); } leader.removeFollowerHandler(this); }
public void woof() { } public void bark(Dog dog) { } public void jump(Dog dog, Integer times) { } public void dropDead(Integer times, Dog dog) { } } @Test(expected=IllegalArgumentException.class) public void shouldNotAcceptMethodsWithoutArguments() throws Exception { deserializer.deserialize(new ByteArrayInputStream(new byte[0]), woof); } @Test public void shouldBeAbleToDeserializeADog() throws Exception { InputStream stream = new ByteArrayInputStream("<dog><name>Brutus</name><age>7</age></dog>".getBytes()); when(provider.parameterNamesFor(bark.getMethod())).thenReturn(new String[] {"dog"}); Object[] deserialized = deserializer.deserialize(stream, bark); assertThat(deserialized.length, is(1)); assertThat(deserialized[0], is(instanceOf(Dog.class))); Dog dog = (Dog) deserialized[0]; assertThat(dog.name, is("Brutus")); assertThat(dog.age, is(7)); } @Test public void shouldBeAbleToDeserializeADogWhenMethodHasMoreThanOneArgument() throws Exception { InputStream stream = new ByteArrayInputStream("<dog><name>Brutus</name><age>7</age></dog>".getBytes()); when(provider.parameterNamesFor(jump.getMethod())).thenReturn(new String[] {"dog", "times"}); Object[] deserialized = deserializer.deserialize(stream, jump); assertThat(deserialized.length, is(2)); assertThat(deserialized[0], is(instanceOf(Dog.class))); Dog dog = (Dog) deserialized[0]; assertThat(dog.name, is("Brutus")); assertThat(dog.age, is(7)); } @Test public void shouldBeAbleToDeserializeADogWhenMethodHasMoreThanOneArgumentAndTheXmlIsTheLastOne() throws Exception { InputStream stream = new ByteArrayInputStream("<dog><name>Brutus</name><age>7</age></dog>".getBytes()); when(provider.parameterNamesFor(dropDead.getMethod())).thenReturn(new String[] {"times", "dog"}); Object[] deserialized = deserializer.deserialize(stream, dropDead); assertThat(deserialized.length, is(2)); assertThat(deserialized[1], is(instanceOf(Dog.class))); Dog dog = (Dog) deserialized[1]; assertThat(dog.name, is("Brutus")); assertThat(dog.age, is(7)); } @Test public void shouldBeAbleToDeserializeADogNamedDifferently() throws Exception { InputStream stream = new ByteArrayInputStream("<pet><name>Brutus</name><age>7</age></pet>".getBytes()); when(provider.parameterNamesFor(bark.getMethod())).thenReturn(new String[] {"pet"}); Object[] deserialized = deserializer.deserialize(stream, bark); assertThat(deserialized.length, is(1)); assertThat(deserialized[0], is(instanceOf(Dog.class))); Dog dog = (Dog) deserialized[0]; assertThat(dog.name, is("Brutus")); assertThat(dog.age, is(7)); } }
public void snapshot(BinaryOutputArchive oa) throws IOException, InterruptedException { HashMap<Long, Integer> sessSnap = new HashMap<Long, Integer>( sessionsWithTimeouts); oa.writeInt(sessSnap.size(), "count"); for (Entry<Long, Integer> entry : sessSnap.entrySet()) { oa.writeLong(entry.getKey().longValue(), "id"); oa.writeInt(entry.getValue().intValue(), "timeout"); } dataTree.serialize(oa, "tree"); }
public void write(OutputStream os) throws IOException { os.write("after".getBytes("ASCII")); os.flush(); assertTrue("implementation of AtomicFileOutputStream has changed, update the test", tmp.exists()); throw new IOException(); }
public void initialize() { ByteBuffer b = ByteBuffer.allocate(KeyUtil.getKeyBytes(key).length + OVERHEAD); setArguments(b, "delete", key); b.flip(); setBuffer(b); }
void execute(InterceptorStack stack, ResourceMethod method, Object resourceInstance) throws InterceptionException; }
public String html(int depth) { StringBuffer buffer = new StringBuffer(); for (HtmlElement element : this) { if (element instanceof HtmlTag) buffer.append(((HtmlTag) element).html(depth)); else buffer.append(element.html()); } return buffer.toString(); }
public void testStopAll() throws Exception { SuiteResponder.runningTestingTracker.addStartedProcess("1", stoppableA); SuiteResponder.runningTestingTracker.addStartedProcess("2", stoppableB); StopTestResponder stopResponder = new StopTestResponder(); String response = runResponder(stopResponder); assertTrue(stoppableA.wasStopped()); assertTrue(stoppableB.wasStopped()); assertSubString("all", response); assertSubString("2", response);
public void pageHistoryShouldHaveStatsForOneTestIfOnePageHistoryFileIsPresent() throws Exception { File pageDirectory = addPageDirectory("TestPage"); addTestResult(pageDirectory, "20090418123103_1_2_3_4"); TestHistory history = new TestHistory(resultsDirectory); PageHistory pageHistory = history.getPageHistory("TestPage"); assertEquals(1, pageHistory.size()); assertEquals(7, pageHistory.maxAssertions()); SortedSet<Date> dates = pageHistory.datesInChronologicalOrder(); assertEquals(1, dates.size()); Date date = dateFormat.parse("20090418123103"); assertEquals(date, dates.first()); PageHistory.PassFailBar passFailBar = pageHistory.getPassFailBar(date, 50); assertEquals(1, passFailBar.getPass()); assertEquals(6, passFailBar.getFail()); assertEquals(7, passFailBar.getPassUnits()); assertEquals(43, passFailBar.getFailUnits()); }
public Runnable peek(ByteString topic) { return topic2ops.get(topic).peek(); }
public Iterator<Route> iterator() { return getFullList().iterator(); }
public void testGetVersionOfPageData() throws Exception { WikiPage page = crawler.addPage(root, PathParser.parse("PageOne"), "some content"); VersionInfo commitRecord = page.commit(page.getData()); request.addInput("type", "meat"); request.addInput("version", commitRecord.getName()); request.setResource("PageOne"); Object obj = getObject(root, request); assertEquals(PageData.class, obj.getClass()); PageData data = (PageData) obj; assertEquals("some content", data.getContent()); }
public void testWithInMemory() throws Exception { Object obj = doSetUpWith(root, "bones"); doTestWith(obj);
public static void cleanUpBaseClass() { Security.removeProvider(BouncyCastleProvider.PROVIDER_NAME); cachedTestContexts.clear(); cachedTestContexts = null; try { FileUtils.deleteDirectory(tempDir);
public void acceptSocketFrom(SocketDoner doner) throws Exception; }
public void start() { if (numWorkerThreads > 0) { if (threadsAreAssignable) { for (int i = 1; i <= numWorkerThreads; ++i) { workers.add(Executors.newFixedThreadPool(1, new DaemonThreadFactory(threadNamePrefix, i))); } } else { workers.add(Executors.newFixedThreadPool(numWorkerThreads, new DaemonThreadFactory(threadNamePrefix))); } } stopped = false; }
public void tearDown() throws Exception { FileUtil.deleteFileSystemDirectory("TestDir"); }
String genJavaReadMethod(String fname, String tag) { return " " + fname + "=a_.read" + mMethodSuffix + "(\"" + tag + "\");\n"; }
public void testParentPath() throws Exception { WikiPagePath path2 = new WikiPagePath(); assertEquals(path2, path.parentPath()); path.addNameToEnd("AbC"); assertEquals(path2, path.parentPath()); path.addNameToEnd("XyZ"); path2.addNameToEnd("AbC"); assertEquals(path2, path.parentPath()); }
public void convertedListContainingOtherHtmlIsEscaped() { HtmlTable t = getDummyTable(); t.addRow(Collections.singletonList(listContainingImage)); assertTrue(t.toHtml().contains("&lt;")); assertFalse(t.toHtml().contains(listContainingHashTable)); }
public void shouldBeAbleToConvertByOrdinal() { assertThat((MyCustomEnum) converter.convert("1", MyCustomEnum.class, bundle), is(equalTo(MyCustomEnum.SECOND))); }
public static FitNesseContext makeTestContext(FitNesseContext context, int port) { return new FitNesseContext(context.root, context.rootPath,
public void fillingUriForPrimitiveParameters() throws Exception { builder = newBuilder("/abc/{abc}/def/{def}/ghi/{ghi}"); Method method = MyResource.class.getDeclaredMethods()[0]; builder.is(MyResource.class, method); Route route = builder.build(); String url = route.urlFor(MyResource.class, method, "Anything", 123, new BigDecimal("123.45")); assertThat(url, is("/abc/Anything/def/123/ghi/123.45")); }
public void testRefactorPageResponder() throws Exception { assertResponderTypeMatchesInput("refactor", RefactorPageResponder.class); }
public static void startFitnesse(WikiPage root) throws Exception { context = makeTestContext(root); context.responderFactory = new ResponderFactory(context.rootPagePath); context.port = port; startFitnesseWithContext(context); }
public void setMinSessionTimeout(int min);  public int getMaxSessionTimeout();  public void setMaxSessionTimeout(int max);  public void resetStatistics();  public void resetLatency();  public void resetMaxLatency();  public long getNumAliveConnections();  public long getDataDirSize();  public long getLogDirSize();  public String getSecureClientPort();  public String getSecureClientAddress();  public long getTxnLogElapsedSyncTime(); }
public static int indexOfIgnoreCase(String text, String search) { return indexOfIgnoreCase(text, search, 0); }
String urlFor(Class<?> type, Method m, Object params);  boolean canHandle(Class<?> type, Method method);  int getPriority();  String getOriginalUri(); }
public WikiPage getPageAfterDeadEnd(WikiPage context, WikiPagePath restOfPath, PageCrawler crawler) throws Exception { WikiPage page = super.getPageAfterDeadEnd(context, restOfPath, crawler); if (page == null) page = MockingPageCrawler.createMockPage(restOfPath.last(), context); return page; }
public void cantDeserializeStringThatDoesntEndWithBracket() throws Exception { SlimDeserializer.deserialize("[000000:"); }
public void tearDown() throws IOException { fileTxnSnapLog.close(); }
public void userRegisters(String name){ home.fillRegisterForm() .withLogin(name)
public VersionInfo commit(PageData data) throws Exception { pageData = data; return new VersionInfo("mockVersionName", "mockAuthor", new Date()); }
ResourceMethod parse(String uri, HttpMethod methodName, MutableRequest request); List<Resource> all(); }
private void includeSetupPage() throws Exception { include("SetUp", "-setup"); }
public void close() { FileUtil.close(stdin); FileUtil.close(stdout); FileUtil.close(stderr); }
public void scenarioTableIsRegistered() throws Exception { getResultsForPageContents("|Scenario|myScenario|\n"); assertTrue("scenario should be registered", responder.testSystem.getTestContext() .getScenarios().iterator().next().getScenarioName().equals("myScenario"));
public ExtJSJson from(Object object) { wrapper = new ExtJSWrapper(object); serializer.from(object); return this; }
void add(Client c); void remove(Client client); Client find(Long id); }
public void setupTestDir() throws IOException { testDir = ClientBase.createTmpDir(); dstFile = new File(testDir, "test.txt"); }
public static void main(String[] args) { int lenght = Integer.parseInt(args[1]); StringBuilder sb = new StringBuilder(); while(lenght-- > 0){ sb.append('a'); } Integer selection = Integer.parseInt(args[0]); switch(selection){ case 0:
public void testChangedByFromChangesProvider() throws Exception { TimeZone.setDefault(TimeZone.getTimeZone("America/Chicago")); final String input = "release distribution=production, date=14:00 13.01.2007, version=12324, urgency=low, by=mrasko@test.com\n" + " * change1\n" + " * change2\n"; BinaryPackageControlFile packageControlFile = new BinaryPackageControlFile(); packageControlFile.set("Package", "package"); packageControlFile.set("Version", "version"); packageControlFile.set("Maintainer", "tcurdt@joost.com"); packageControlFile.set("Date", "Mon, 20 Aug 2007 15:25:57 +0200"); final TextfileChangesProvider provider = new TextfileChangesProvider(new ByteArrayInputStream(input.getBytes(UTF_8)), packageControlFile); final ChangeSet[] changeSets = provider.getChangesSets(); assertNotNull(changeSets); assertEquals(1, changeSets.length); assertEquals(1168718400000L, changeSets[0].getDate().getTime()); ChangesFile changesFile = new ChangesFile(); changesFile.setChanges(provider.getChangesSets()); changesFile.initialize(packageControlFile); assertNotNull(changesFile); assertEquals("mrasko@test.com", changesFile.get("Changed-By")); }
public static Set<ObjectName> ensureParent(String... expectedNames) throws IOException, InterruptedException { LOG.info("ensureParent:" + Arrays.toString(expectedNames)); Set<ObjectName> beans; int nTry = 0; Set<ObjectName> found = new HashSet<ObjectName>(); do { if (nTry++ > 0) { Thread.sleep(500); } try { beans = conn().queryNames( new ObjectName(MBeanRegistry.DOMAIN + ":*"), null); } catch (MalformedObjectNameException e) { throw new RuntimeException(e); } found.clear(); for (String name : expectedNames) { LOG.info("expect:" + name); for (ObjectName bean : beans) {
String getTestSystem(); String getTestSystemType();
protected void unregisterMetrics() { MetricsContext rootContext = ServerMetrics.getMetrics().getMetricsProvider().getRootContext(); rootContext.unregisterGauge("avg_latency"); rootContext.unregisterGauge("max_latency"); rootContext.unregisterGauge("min_latency"); rootContext.unregisterGauge("packets_received"); rootContext.unregisterGauge("packets_sent"); rootContext.unregisterGauge("num_alive_connections"); rootContext.unregisterGauge("outstanding_requests"); rootContext.unregisterGauge("uptime"); rootContext.unregisterGauge("znode_count"); rootContext.unregisterGauge("watch_count"); rootContext.unregisterGauge("ephemerals_count"); rootContext.unregisterGauge("approximate_data_size"); rootContext.unregisterGauge("global_sessions"); rootContext.unregisterGauge("local_sessions"); rootContext.unregisterGauge("open_file_descriptor_count"); rootContext.unregisterGauge("max_file_descriptor_count"); rootContext.unregisterGauge("connection_drop_probability"); rootContext.unregisterGauge("last_client_response_size"); rootContext.unregisterGauge("max_client_response_size"); rootContext.unregisterGauge("min_client_response_size");
public Responder authenticate(FitNesseContext context, Request request, Responder privilegedResponder) throws Exception { request.getCredentials(); String username = request.getAuthorizationUsername(); String password = request.getAuthorizationPassword(); if(isAuthenticated(username, password)) return privilegedResponder;
protected void finishedPayload(byte[] pl) throws IOException { if (errorCode == SASL_CONTINUE) { getCallback().receivedStatus(new OperationStatus(true, new String(pl)));
void notFound();  void conflict(); void header(String key, String value); void methodNotAllowed(EnumSet<HttpMethod> allowedMethods);  void notModified();  void movedPermanentlyTo(String url);  <T> T movedPermanentlyTo(Class<T> controller);  void unsupportedMediaType(String errorMessage);  void notAcceptable(); }
private void includeInto(boolean isSuite) throws Exception { this.isSuite = isSuite; if (testPage.isTestPage()) includeSetupTeardownAndLibraryPages();
public Response makeResponse(FitNesseContext context, Request request) throws Exception { SimpleResponse response = new SimpleResponse(401); response.addHeader("WWW-Authenticate", token == null ? NEGOTIATE : NEGOTIATE + " " + token); HtmlPage html = context.htmlPageFactory.newPage(); HtmlUtil.addTitles(html, "Negotiated authentication required"); if (request == null) html.main.add("This request requires authentication"); else html.main.add("Your client failed to complete required authentication"); response.setContent(html.html()); return response; }
private void includeScenarioLibraries() throws Exception { includeScenarioLibrariesIfAppropriate(AllLibrariesFilter.instance);
public void unrecognizedTableType() throws Exception { getResultsForTable("|XX|\n"); String fragment = "\"XX\" is not a valid table type"; assertTestResultsContain(fragment); }
public void initialize() { prepareBuffer(key, EMPTY_BYTES, when); }
public void testClientReconnectWithZKClientConfig() throws Exception { ZooKeeper zk = null; ZooKeeper newZKClient = null; try { zk = createClient();
private void lostConnection(MemcachedNode qa) { queueReconnect(qa); for(ConnectionObserver observer : connObservers) { observer.connectionLost(qa.getSocketAddress());
public List<Instruction> getInstructions() throws SyntaxError { if (table.getRowCount() < 2) throw new SyntaxError("Query tables must have at least two rows."); assignColumns(); Instruction make = constructFixture(getFixtureName()); Instruction ti = callFunction(getTableName(), "table", tableAsList()); Instruction qi = callFunction(getTableName(), "query"); tableInstruction = getInstructionId(ti); queryId = getInstructionId(qi); addExpectation(new QueryTableExpectation()); return list(make, ti, qi); }
public void announceNumberTestsToRun(int testsToRun); public void testSystemStarted(TestSystem testSystem); public void newTestStarted(WikiTestPage test, TimeMeasurement timeMeasurement) throws IOException; public void testOutputChunk(String output) throws IOException; public void testAssertionVerified(Assertion assertion, TestResult testResult); public void testExceptionOccurred(Assertion assertion, ExceptionResult exceptionResult); public void testComplete(WikiTestPage test, TestSummary testSummary, TimeMeasurement timeMeasurement) throws IOException; public void errorOccured(); }
public void testMovePageIntoItselfIsNotAllowed() throws Exception { crawler.addPage(root, PathParser.parse("TestPage")); SimpleResponse response = movePage("TestPage", "TestPage"); assertFalse(crawler.pageExists(root, PathParser.parse("TestPage.TestPage"))); assertEquals(400, response.getStatus()); assertSubString("Cannot move", response.getContent()); }
public void intercept(InterceptorStack stack, ResourceMethod method, Object resourceInstance) throws InterceptionException {
public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; MarkerQuorumPacket that = (MarkerQuorumPacket) o; return time == that.time; }
public void testCnxManagerNPE() throws Exception {
@Test public void translatesEMail() { ParserTestHelper.assertTranslatesTo("bob@bl.org", "<a href=\"mailto:bob@bl.org\">bob@bl.org</a>"); }
public AnnotationVisitor visitAnnotationDefault() {
public void onAuthenticationSucceeded(final FingerprintManagerCompat.AuthenticationResult result) { if (mode == Cipher.ENCRYPT_MODE) {
boolean isCancelled();  boolean hasErrored();  OperationException getException();  OperationCallback getCallback();  void cancel();  OperationState getState();  ByteBuffer getBuffer();  void writing();  void writeComplete();  void initialize();  void readFromBuffer(ByteBuffer data) throws IOException;  void handleRead(ByteBuffer data);  MemcachedNode getHandlingNode();  void setHandlingNode(MemcachedNode to);  void timeOut();  boolean isTimedOut();  boolean isTimedOut(long ttlMillis);  boolean isTimedOutUnsent();  long getWriteCompleteTimestamp();  byte[] getErrorMsg(); }
private boolean contains(Iterable<SymbolType> terminators, SymbolType currentType) { for (SymbolType terminator: terminators) if (currentType == terminator) return true; return false; }
public void add(final String key, final long delta) { try { inner.labels(key).inc(delta);
public void parseBase64Wikiword() { ParserTestHelper.assertParses("!img data:mediatype;base64,somedataQm2Ic50", "SymbolList[Image[Link[SymbolList[Text]]]]"); }
public static FitNesseContext makeTestContext(WikiPage root, String rootPath, String rootDirectoryName, int port, Authenticator authenticator, Properties properties) { FitNesseContext context; try { context = ContextConfigurator.systemDefaults() .withRoot(root) .withRootPath(rootPath) .withRootDirectoryName(rootDirectoryName) .withPort(port) .withAuthenticator(authenticator) .withVersionsController(new ZipFileVersionsController()) .withRecentChanges(new RecentChangesWikiPage()) .updatedWith(properties) .makeFitNesseContext(); } catch (IOException e) { throw new IllegalStateException(e); } catch (PluginException e) { throw new IllegalStateException(e); }
public int doFinal(byte[] out, int outOff) throws IllegalStateException, InvalidCipherTextException;  public byte[] getMac();  public int getUpdateOutputSize(int len);  public int getOutputSize(int len);  public void reset(); }
public void resetMaxLatency();  public long getNumAliveConnections();  public long getDataDirSize();  public long getLogDirSize();  public String getSecureClientPort();  public String getSecureClientAddress(); }
public void tearDown() {
public String render() throws Exception { StringBuffer html = new StringBuffer("<hr"); if(size > 0) html.append(" size=\"").append(size + 1).append("\""); html.append(">"); return html.toString(); }
private boolean hasValidInputs(Request request) { if (request.getInput("days") == null) return false; Integer days = getDaysInput(request); if (days < 0) return false; return true;
void copyInputQueue();  Collection<Operation> destroyInputQueue();  void setupResend();  void fillWriteBuffer(boolean optimizeGets);  void transitionWriteItem();  Operation getCurrentReadOp();  Operation removeCurrentReadOp();  Operation getCurrentWriteOp();  Operation removeCurrentWriteOp();  boolean hasReadOp();  boolean hasWriteOp();  void addOp(Operation op);  void insertOp(Operation o);  int getSelectionOps();  ByteBuffer getRbuf();  ByteBuffer getWbuf();  SocketAddress getSocketAddress();  boolean isActive();  void reconnecting();  void connected();  int getReconnectCount();  void registerChannel(SocketChannel ch, SelectionKey selectionKey);  void setChannel(SocketChannel to);  SocketChannel getChannel();  void setSk(SelectionKey to);  SelectionKey getSk();  int getBytesRemainingToWrite();  int writeSome() throws IOException;  void fixupOps();  void authComplete();  void setupForAuth();  void setContinuousTimeout(boolean timedOut); int getContinuousTimeout(); }
public void testBuildClassPath() throws Exception { MultipleTestsRunner runner = new MultipleTestsRunner(testPages, context, suite, null); String classpath = runner.buildClassPath(); assertSubString("classes", classpath); assertSubString("dummy.jar", classpath); }
public List<String> getClasspaths() throws Exception { Symbol tree = getSyntaxTree(); return new Paths(new HtmlTranslator(new WikiSourcePage(wikiPage), parsingPage)).getPaths(tree);
public <T extends View> T instanceFor(final Class<T> view, final List<Message> errors) { if (view.equals(EmptyResult.class)) { throw new ValidationException(errors); } final T viewInstance = result.use(view); return proxifier.proxify(view, new MethodInvocation<T>() { public Object intercept(T proxy, Method method, Object[] args, SuperMethod superMethod) {
void setTickTime(int tickTime);  int getMaxClientCnxnsPerHost();  void setMaxClientCnxnsPerHost(int max);  int getMinSessionTimeout();  void setMinSessionTimeout(int min);  int getMaxSessionTimeout();  void setMaxSessionTimeout(int max); boolean getResponseCachingEnabled(); void setResponseCachingEnabled(boolean isEnabled);  int getConnectionMaxTokens(); void setConnectionMaxTokens(int val); int getConnectionTokenFillTime(); void setConnectionTokenFillTime(int val); int getConnectionTokenFillCount(); void setConnectionTokenFillCount(int val); int getConnectionFreezeTime(); void setConnectionFreezeTime(int val); double getConnectionDropIncrease(); void setConnectionDropIncrease(double val); double getConnectionDropDecrease(); void setConnectionDropDecrease(double val); double getConnectionDecreaseRatio(); void setConnectionDecreaseRatio(double val); int getCommitProcMaxReadBatchSize(); void setCommitProcMaxReadBatchSize(int size); int getCommitProcMaxCommitBatchSize(); void setCommitProcMaxCommitBatchSize(int size); int getRequestThrottleLimit(); void setRequestThrottleLimit(int requests); int getRequestThrottleStallTime(); void setRequestThrottleStallTime(int time); boolean getRequestThrottleDropStale(); void setRequestThrottleDropStale(boolean drop); int getThrottledOpWaitTime(); void setThrottledOpWaitTime(int val); boolean getRequestStaleLatencyCheck(); void setRequestStaleLatencyCheck(boolean check); boolean getRequestStaleConnectionCheck(); void setRequestStaleConnectionCheck(boolean check); int getLargeRequestMaxBytes(); void setLargeRequestMaxBytes(int bytes); int getLargeRequestThreshold(); void setLargeRequestThreshold(int threshold);  void resetStatistics();  void resetLatency();  void resetMaxLatency();  void resetFsyncThresholdExceedCount();  long getNumAliveConnections();  long getDataDirSize();  long getLogDirSize();  String getSecureClientPort();  String getSecureClientAddress();  long getTxnLogElapsedSyncTime();  int getJuteMaxBufferSize();  int getLastClientResponseSize();  int getMinClientResponseSize();  int getMaxClientResponseSize(); long getFlushDelay(); void setFlushDelay(long delay); long getMaxWriteQueuePollTime(); void setMaxWriteQueuePollTime(long delay); int getMaxBatchSize(); void setMaxBatchSize(int size);  int getMaxCnxns(); }
public void write(String output) {
public boolean getResponseCachingEnabled(); public void setResponseCachingEnabled(boolean isEnabled);  public int getConnectionMaxTokens(); public void setConnectionMaxTokens(int val); public int getConnectionTokenFillTime(); public void setConnectionTokenFillTime(int val); public int getConnectionTokenFillCount(); public void setConnectionTokenFillCount(int val); public int getConnectionFreezeTime(); public void setConnectionFreezeTime(int val); public double getConnectionDropIncrease(); public void setConnectionDropIncrease(double val); public double getConnectionDropDecrease(); public void setConnectionDropDecrease(double val); public double getConnectionDecreaseRatio(); public void setConnectionDecreaseRatio(double val); public int getCommitProcMaxReadBatchSize(); public void setCommitProcMaxReadBatchSize(int size); public int getCommitProcMaxCommitBatchSize(); public void setCommitProcMaxCommitBatchSize(int size); public int getRequestThrottleLimit(); public void setRequestThrottleLimit(int requests); public int getRequestThrottleStallTime(); public void setRequestThrottleStallTime(int time); public boolean getRequestThrottleDropStale(); public void setRequestThrottleDropStale(boolean drop); public boolean getRequestStaleLatencyCheck(); public void setRequestStaleLatencyCheck(boolean check); public boolean getRequestStaleConnectionCheck(); public void setRequestStaleConnectionCheck(boolean check);  public void resetStatistics();  public void resetLatency();  public void resetMaxLatency();  public void resetFsyncThresholdExceedCount();  public long getNumAliveConnections();  public long getDataDirSize();  public long getLogDirSize();  public String getSecureClientPort();  public String getSecureClientAddress();  public long getTxnLogElapsedSyncTime();  public int getJuteMaxBufferSize();  public int getLastClientResponseSize();  public int getMinClientResponseSize();  public int getMaxClientResponseSize(); public long getFlushDelay(); public void setFlushDelay(long delay); public long getMaxWriteQueuePollTime(); public void setMaxWriteQueuePollTime(long delay); public int getMaxBatchSize(); public void setMaxBatchSize(int size); }
public void doesNotRemoveLicenseFromNonJavaFile() throws Exception { File testDir = FileUtil.createDir(dir); File fileWithLicense = new File(testDir, "fileWithLicense"); FileUtil.createFile(fileWithLicense, licenseText + "xxx\n"); LicenseManager.main(new String[]{"-r", dir}); assertEquals(licenseText + "xxx\n", FileUtil.getFileContent(fileWithLicense)); }
Operation getCurrentWriteOp();  Operation removeCurrentWriteOp();  boolean hasReadOp();  boolean hasWriteOp();  void addOp(Operation op);  void insertOp(Operation o);  int getSelectionOps();  ByteBuffer getRbuf();  ByteBuffer getWbuf();  SocketAddress getSocketAddress();  boolean isActive();  void reconnecting();  void connected();  int getReconnectCount();  void registerChannel(SocketChannel ch, SelectionKey selectionKey);  void setChannel(SocketChannel to);  SocketChannel getChannel();  void setSk(SelectionKey to);  SelectionKey getSk();  int getBytesRemainingToWrite();  int writeSome() throws IOException;  void fixupOps();  void authComplete();  void setupForAuth();  void setContinuousTimeout(boolean timedOut); int getContinuousTimeout(); }
public void tearDown() throws Exception { } protected Update makeUpdate() throws Exception { return null; } }
public void acceptResultsLast(TestSummary testSummary) throws Exception { WikiPage testPage = processingQueue.removeFirst(); resultsListener.processTestResults(testPage, testSummary); }
public String translate(Scanner scanner, SymbolType terminator) { return translate(scanner, new SymbolType[] {terminator}); }
private void doTest(String connectionString) throws Exception { RetryOneTime retryPolicy = new RetryOneTime(1); try (CuratorFramework client = CuratorFrameworkFactory.newClient(connectionString, retryPolicy)) { try (CuratorCache cache = CuratorCache.build(client, "/base/path")) {
void encode( DEROutputStream out) throws IOException { out.writeEncoded(isConstructed ? DERTags.CONSTRUCTED : 0, tag, data); }
public List<Assertion> getAssertions() throws SyntaxError { if (table.getRowCount() < 2) throw new SyntaxError("Query tables must have at least two rows."); assignColumns(); Assertion make = constructFixture(getFixtureName()); Assertion ti = makeAssertion(callFunction(getTableName(), "table", tableAsList()), new SilentReturnExpectation(0, 0)); Assertion qi = makeAssertion(callFunction(getTableName(), "query"), new QueryTableExpectation()); tableInstruction = ti.getInstruction().getId(); queryId = qi.getInstruction().getId(); return list(make, ti, qi); }
public void testReadSecret_fileNotExist() { final String pathToFile = "NonExistingFile"; final IllegalStateException exception = assertThrows(IllegalStateException.class, () -> SecretUtils.readSecret(pathToFile)); assertEquals("Exception occurred while reading secret from file " + pathToFile, exception.getMessage()); }
public void testObservable() throws Exception { BucketMonitor bucketMonitor = new BucketMonitor(new URI(STREAMING_URI), BUCKET_NAME, USERNAME, PASSWORD, CONFIG_PARSER); BucketObserverMock observer = new BucketObserverMock(); bucketMonitor.addObserver(observer); bucketMonitor.addObserver(observer); bucketMonitor.startMonitor(); assertTrue("Update for observer was not called.", observer.isUpdateCalled()); bucketMonitor.shutdown(); }
void appendCellToRow(int row, String contents) throws Exception; String error(String s); String pass(String s); String fail(String s); String ignore(String s); String getUnescapedCellContents(int col, int row); String getCellResult(int col,int row); void appendChildTable(int row, Table table); void setTestStatusOnRow(int row, ExecutionResult testStatus); void setName(String tableName); }
protected SlimTestSystem getTestSystem() throws IOException { WikiPage page = getPage(); SlimClientBuilder builder = new SlimClientBuilder(page, getDescriptor()); builder.setFastTest(fastTest); builder.start(); SlimClient slimClient = builder.getSlimClient(); return new HtmlSlimTestSystem(getPage(), slimClient, this); }
public void testMutatorOperationIncrCloning() { int exp = 823862; long def = 28775; int by = 7735; MutatatorOperation op = ofact.mutate(Mutator.incr, TEST_KEY, by, def, exp, genericCallback); MutatatorOperation op2 = cloneOne(MutatatorOperation.class, op); assertKey(op2); assertEquals(exp, op2.getExpiration()); assertEquals(def, op2.getDefault()); assertEquals(by, op2.getBy()); assertSame(Mutator.incr, op2.getType()); assertCallback(op2); }
public static boolean isSuiteMetaPage(String relativeName) { return relativeName != null && (relativeName.equals("SuiteSetUp") || relativeName.endsWith(".SuiteSetUp")
public void canInstantiatingStringsInAListSettingItsInternalValueWithoutInvokingConverters() throws OgnlException { Ognl.setValue("legLength[0]", context, myCat, "small"); List<String> legs = myCat.legLength; assertThat(legs.get(0), is(equalTo("small"))); Ognl.setValue("legLength[1]", context, myCat, "big"); assertThat(legs.get(1), is(equalTo("big"))); }
private Long decodeLong(byte[] in) { long rv = 0L; for (int idx = 1; idx < in.length; idx++) { byte i = in[idx]; rv = (rv << 8) | (i < 0 ? 256 + i : i); } return Long.valueOf(rv); }
public void list() { } @Path("/clients/remove") @Delete public void remove() { } @Path("/clients/head") @Head public void head() { } public void add() { } @Path("/protectMe") protected void protectMe() { } @Path("/staticMe") public static void staticMe() { } public void toInherit() { } } @Test public void shouldFindNonAnnotatedNonStaticPublicMethodWithComponentNameInVariableCamelCaseConventionAsURI() throws Exception { ResourceMethod method = router.parse("/clients/add", HttpMethod.POST, request); assertThat(method, is(VRaptorMatchers.resourceMethod(Clients.class.getMethod("add")))); mockery.assertIsSatisfied(); } @Test public void shouldIgnoreAResourceWithTheWrongWebMethod() throws SecurityException { ResourceMethod method = router.parse("/clients/remove", HttpMethod.POST, request); assertThat(method, is(Matchers.nullValue())); mockery.assertIsSatisfied(); } @Test public void shouldAcceptAResultWithASpecificWebMethod() throws SecurityException, NoSuchMethodException { ResourceMethod method = router.parse("/clients/head", HttpMethod.HEAD, request); assertThat(method, is(VRaptorMatchers.resourceMethod(Clients.class.getMethod("head")))); mockery.assertIsSatisfied(); } static class NiceClients extends Clients { } @Test public void findsInheritedMethodsWithDefaultNames() throws SecurityException, NoSuchMethodException { StereotypedClass childResource = mockery.resource(NiceClients.class); router.register(childResource); ResourceMethod method = router.parse("/niceClients/toInherit", HttpMethod.POST, request); assertThat(method, is(VRaptorMatchers.resourceMethod(Clients.class.getMethod("toInherit")))); mockery.assertIsSatisfied(); } }
public Maybe<Symbol> parse(Parser parser) { Scanner scanner = parser.getScanner(); List<Symbol> tokens = scanner.nextTokens(new SymbolType[] {SymbolType.Whitespace, SymbolType.Text, SymbolType.Whitespace}); if (tokens.size() == 0) return Symbol.nothing; String name = tokens.get(1).getContent(); if (!ScanString.isVariableName(name)) return Symbol.nothing; scanner.moveNext(); SymbolType open = scanner.getCurrent().getType(); SymbolType close = SymbolType.closeType(open); if (close == SymbolType.Empty) return Symbol.nothing; int start = scanner.getOffset(); scanner.markStart(); Symbol value = parser.parseToIgnoreFirst(close); if (scanner.isEnd()) return Symbol.nothing; String valueString = scanner.substring(start, scanner.getOffset() - 1); parser.getPage().putVariable(name, valueString); return new Maybe<Symbol>(new Symbol(SymbolType.Define) .add(name)
public void testWikiWordRegexp() throws Exception { checkWord(true, "WikiWord"); checkWord(true, "WordWordWord"); checkWord(false, "HelloDDouble"); checkWord(true, "RcM"); checkWord(false, "Hello"); checkWord(true, "WikiWordWithManyWords"); checkWord(true, "WidgetRoot.ChildPage"); checkWord(true, "GrandPa.FatheR.SoN"); checkWord(true, ".RootPage.ChildPage"); checkWord(false, "lowerCaseAtStart"); checkWord(true, "^SubPage"); checkWord(true, "^SubPage.SubPage"); checkWord(false, "RcMMdM"); checkWord(false, "WikiPage."); }
public void shouldThrowResourceNotFoundExceptionWhenNoRoutesMatchTheURI() throws Exception { final Route route = mockery.mock(Route.class); mockery.checking(new Expectations() { { allowing(route).canHandle(with(any(String.class))); will(returnValue(false)); ignoring(anything()); } }); router.add(route); try { router.parse("any uri", HttpMethod.DELETE, request);
public AnnotationVisitor visitAnnotationDefault() { return mv.visitAnnotationDefault(); }
public void testNodes20() throws Exception { int testIterations = 20; final CountDownLatch latch = new CountDownLatch(testIterations); final AtomicInteger failureCounter = new AtomicInteger(); for (int i = 0; i < testIterations; i++) { runElectionSupportThread(latch, failureCounter); } Assert.assertEquals(0, failureCounter.get()); if (!latch.await(10, TimeUnit.SECONDS)) { LOGGER.info("Waited for all threads to start, but timed out. We had {} failures.", failureCounter);
private void assertOutputHasRow(String content, String title, String tagName) { assertHasRegexp("<table.*<tr.*<td.*<" + tagName + ">" + title + "</" + tagName + ">", content);
public void delete(String pathToDelete) { for (Iterator<String> iter = files.keySet().iterator(); iter.hasNext(); ) { String f = iter.next();
public void testWithOnlyMinSessionTimeout() throws Exception { ClientBase.setupTestEnv(); final int CLIENT_PORT_QP1 = PortAssignment.unique(); final int CLIENT_PORT_QP2 = PortAssignment.unique(); String quorumCfgSection = "server.1=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique() + "\nserver.2=127.0.0.1:" + PortAssignment.unique() + ":" + PortAssignment.unique(); final int minSessionTimeOut = 15000; final String configs = "minSessionTimeout=" + minSessionTimeOut + "\n"; MainThread q1 = new MainThread(1, CLIENT_PORT_QP1, quorumCfgSection, configs); MainThread q2 = new MainThread(2, CLIENT_PORT_QP2, quorumCfgSection, configs); q1.start(); q2.start(); assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP1, CONNECTION_TIMEOUT), "waiting for server 1 being up"); assertTrue(ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT_QP2, CONNECTION_TIMEOUT), "waiting for server 2 being up"); QuorumPeer quorumPeer = q1.main.quorumPeer; final int maxSessionTimeOut = quorumPeer.tickTime * 20; assertEquals(minSessionTimeOut, quorumPeer.getMinSessionTimeout(), "minimumSessionTimeOut is not considered"); assertEquals(maxSessionTimeOut, quorumPeer.getMaxSessionTimeout(), "maximumSessionTimeOut is wrong"); }
public long getPacketsReceived();  public long getPacketsSent();  public long getFsyncThresholdExceedCount();  public long getOutstandingRequests();  public int getTickTime();  public void setTickTime(int tickTime);  public int getMaxClientCnxnsPerHost();  public void setMaxClientCnxnsPerHost(int max);  public int getMinSessionTimeout();  public void setMinSessionTimeout(int min);  public int getMaxSessionTimeout();  public void setMaxSessionTimeout(int max); public boolean getResponseCachingEnabled(); public void setResponseCachingEnabled(boolean isEnabled);  public int getConnectionMaxTokens(); public void setConnectionMaxTokens(int val); public int getConnectionTokenFillTime(); public void setConnectionTokenFillTime(int val); public int getConnectionTokenFillCount(); public void setConnectionTokenFillCount(int val); public int getConnectionFreezeTime(); public void setConnectionFreezeTime(int val); public double getConnectionDropIncrease(); public void setConnectionDropIncrease(double val); public double getConnectionDropDecrease(); public void setConnectionDropDecrease(double val); public double getConnectionDecreaseRatio(); public void setConnectionDecreaseRatio(double val); public int getCommitProcMaxReadBatchSize(); public void setCommitProcMaxReadBatchSize(int size); public int getCommitProcMaxCommitBatchSize(); public void setCommitProcMaxCommitBatchSize(int size); public int getRequestThrottleLimit(); public void setRequestThrottleLimit(int requests); public int getRequestThrottleStallTime(); public void setRequestThrottleStallTime(int time); public boolean getRequestThrottleDropStale(); public void setRequestThrottleDropStale(boolean drop); public boolean getRequestStaleLatencyCheck(); public void setRequestStaleLatencyCheck(boolean check); public boolean getRequestStaleConnectionCheck(); public void setRequestStaleConnectionCheck(boolean check);  public void resetStatistics();  public void resetLatency();  public void resetMaxLatency();  public void resetFsyncThresholdExceedCount();  public long getNumAliveConnections();  public long getDataDirSize();  public long getLogDirSize();  public String getSecureClientPort();  public String getSecureClientAddress();  public long getTxnLogElapsedSyncTime();  public int getJuteMaxBufferSize();  public int getLastClientResponseSize();  public int getMinClientResponseSize();  public int getMaxClientResponseSize(); public long getFlushDelay(); public void setFlushDelay(long delay); public long getMaxWriteQueuePollTime(); public void setMaxWriteQueuePollTime(long delay); public int getMaxBatchSize(); public void setMaxBatchSize(int size); }
private List<SlimAssertion> invokeRow(int row) throws SyntaxError { List<SlimAssertion> assertions = new ArrayList<SlimAssertion>(); checkRow(row); assertions.add(callUnreportedFunction("reset", row)); assertions.addAll(setVariables(row)); assertions.add(callUnreportedFunction("execute", row)); assertions.addAll(callFunctions(row)); return assertions; }
public void setUp() throws Exception { output = new ByteArrayOutputStream(); }
private MultipleTestsRunner createTestRunner(List<WikiPage> pages) { final PagesByTestSystem pagesByTestSystem = new PagesByTestSystem(pages, context.root); MultipleTestsRunner runner = new MultipleTestsRunner(pagesByTestSystem, context.runningTestingTracker, context.testSystemFactory, context.variableSource); runner.setRunInProcess(debugMode); return runner; }
public Set<Long> globalSessions() { return globalSessionTracker.globalSessions(); }
public void testAsWikiText() throws Exception { PreProcessorLiteralWidget widget = new PreProcessorLiteralWidget(root, "!-abc-!"); assertEquals("!-abc-!", widget.asWikiText()); }
private ExceptionResult makeExceptionResult(String resultKey, String resultString) { ExceptionResult exceptionResult = new ExceptionResult(resultKey, resultString); return exceptionResult; }
private void runNewParser(String input) throws Exception { long start = System.currentTimeMillis(); WikiPage page = new TestRoot().makePage("NewTest");
public void decisionTableCanBeConstructorOnly() throws Exception { makeDecisionTableAndBuildInstructions("|fixture|argument|\n"); List<Object> expectedInstructions = list( list("decisionTable_id_0", "make", "decisionTable_id", "fixture", "argument") ); assertEquals(expectedInstructions, instructions); Map<String, Object> pseudoResults = SlimClient.resultToMap( list( list("decisionTable_id_0", "OK") ) ); dt.evaluateExpectations(pseudoResults); String colorizedTable = dt.getTable().toString(); String expectedColorizedTable = "|!style_pass(!<fixture>!)|!<argument>!|\n"; assertEquals(expectedColorizedTable, colorizedTable); }
ByteBuffer getBuffer();  void writeComplete();  void initialize();  void readFromBuffer(ByteBuffer data) throws IOException;  void handleRead(ByteBuffer data);  MemcachedNode getHandlingNode();  void setHandlingNode(MemcachedNode to);  void timeOut();  boolean isTimedOut();  boolean isTimedOut(long ttlMillis);  boolean isTimedOutUnsent(); }
public void testResponse() throws Exception { createRequest(); Responder responder = new SavePropertiesResponder(); Response response = responder.makeResponse(new FitNesseContext(root), request); PageData data = page.getData(); assertEquals("http://www.fitnesse.org", data.getAttribute(WikiPageProperties.VIRTUAL_WIKI_ATTRIBUTE)); assertTrue(data.hasAttribute("Test")); assertTrue(data.hasAttribute("Properties")); assertTrue(data.hasAttribute("Search")); assertFalse(data.hasAttribute("Edit")); assertTrue(data.hasAttribute(WikiPage.SECURE_READ)); assertFalse(data.hasAttribute(WikiPage.SECURE_WRITE)); assertEquals(303, response.getStatus()); assertEquals("PageOne", response.getHeader("Location")); }
public void trulyEqual() throws Exception { assertTrue(approximatelyEqual("3.0", "3.0")); }
public void shouldUseContainerForNewView() { DefaultResult result = new DefaultResult(request, container); final MyView expectedView = new MyView(); when(container.instanceFor(MyView.class)).thenReturn(expectedView); MyView view = result.use(MyView.class); assertThat(view, is(expectedView)); }
public void callsPredestroyExactlyOneTimeForAppScopedComponentFactories() throws Exception { MyFactory component = getFromContainer(MyFactory.class); assertThat(0, is(equalTo(component.calls))); provider.stop(); assertThat(1, is(equalTo(component.calls))); resetProvider(); }
public void addingAValidDvd() throws Exception { Dvd dvd = new Dvd(); dvd.setId(2l); willAddTheDvdRental(dvd); controller.addToMyList(userInfo.getUser(), dvd);
public void verifyMultiFailure_NoSideEffect() throws KeeperException, InterruptedException { List<Op> ops = Arrays.asList( Op.create("/multi", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT), Op.delete("/nonexist1", -1)); zk.multi(ops, this, null); latch_await(); assertTrue(this.opResults.get(0) instanceof OpResult.ErrorResult); assertNull(zk.exists("/multi", false)); }
public PwDatabaseV4 openDatabase(InputStream inStream, String password, String keyfile) throws IOException, InvalidKeyFileException, InvalidPasswordException, InvalidDBSignatureException, InvalidDBVersionException { return openDatabase(inStream, password, keyfile, new UpdateStatus()); }
private static int wikiWordLength(String candidate) { if (candidate.length() < 3) return 0; if (!isUpperCaseLetter(candidate, 0)) return 0; if (!isDigit(candidate, 1) && !isLowerCaseLetter(candidate, 1)) return 0; int lastUpperCaseLetter = 0; int i; for (i = 2; i < candidate.length(); i++) { if (isCharacter(candidate, '_', i)) return 0; if (isUpperCaseLetter(candidate, i)) { if (i == lastUpperCaseLetter + 1) return 0; lastUpperCaseLetter = i; } else if (!isDigit(candidate, i) && !isLetter(candidate, i) ) break; } if (lastUpperCaseLetter > 0 && i > 2) return i; return 0; }
protected void postProcessBeanDefinition(AbstractBeanDefinition beanDefinition, String beanName) { super.postProcessBeanDefinition(beanDefinition, beanName); beanDefinition.setPrimary(true); try { Class<?> componentType = Class.forName(beanDefinition.getBeanClassName());
private HtmlTag makePropertiesForm() throws Exception { HtmlTag form = HtmlUtil.makeFormTag("post", resource); form.add(HtmlUtil.makeInputTag("hidden", "responder", "saveProperties")); HtmlTag trisection = new HtmlTag("div"); trisection.addAttribute("style", "height: 200px"); trisection.add(makeTestActionCheckboxesHtml(pageData)); trisection.add(makeNavigationCheckboxesHtml(pageData)); trisection.add(makeSecurityCheckboxesHtml(pageData)); trisection.add(makeVirtualWikiHtml()); trisection.add(makeSuitesHtml(pageData)); form.add(trisection); HtmlTag saveButton = HtmlUtil.makeInputTag("submit", "Save", "Save Properties"); saveButton.addAttribute("accesskey", "s"); form.add(HtmlUtil.BR); form.add(saveButton); return form; }
public static void assertParses(String input, String expected) { Symbol result = Parser.make(null, input).parse(); assertEquals(expected, serialize(result)); }
String buildLogContent() { StringBuffer buffer = new StringBuffer(); addLiteralEntry(buffer, "Date", makeDateFormat().format(Clock.currentDate())); addEntry(buffer, "Test Page", "." + PathParser.render(crawler.getFullPath(testPage))); addLiteralEntry(buffer, "Command", runner.getCommand()); addLiteralEntry(buffer, "Exit code", String.valueOf(runner.getExitCode())); addLiteralEntry(buffer, "Time elapsed", (double) runner.getExecutionTime() / 1000.0 + " seconds"); if (runner.wroteToOutputStream()) addOutputBlock(buffer); if (runner.wroteToErrorStream()) addErrorBlock(buffer); if (runner.hasExceptions() || exceptions.size() > 0) addExceptionBlock(buffer); return buffer.toString(); }
public void acceptResult(PageResult result) throws IOException { String relativePageName = result.title(); suiteFormatter.announceStartNewTest(relativePageName, rootPath + "." + relativePageName); suiteFormatter.testOutputChunk(result.content()); suiteFormatter.processTestResults(relativePageName, result.testSummary()); }
boolean runInProcess(); boolean isDebug();
public void onTerminate() { if ( db != null ) { db.clear(); } if ( fileDbHelper != null && fileDbHelper.isOpen() ) { fileDbHelper.close(); } super.onTerminate();
public void copyBytesUpTo(String boundary, OutputStream outputStream) throws Exception { prepareForReadUpTo(boundary); performCopy(outputStream); }
public void testGetUserpass() throws Exception { assertEquals("Aladdin:open sesame", request.getUserpass("Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==")); }
public TransitionBuilder transition(String name); <T> T transition(Class<T> type); public StateBuilder state(String name); public List<Relation> getTransitions(); public List<State> getStates();  public void clear(); }
protected static void putParentId(Intent i, String parentKey, PwGroupV3 parent) { i.putExtra(parentKey, parent.groupId); }
public void setup() { this.mockery = new Mockery(); this.request = mockery.mock(MutableRequest.class); this.response = mockery.mock(MutableResponse.class); this.session = mockery.mock(HttpSession.class); this.method = mockery.mock(ResourceMethod.class); this.resource = mockery.mock(ResourceClass.class); this.config = mockery.mock(Config.class); this.resolver = mockery.mock(PathResolver.class); this.dispatcher = mockery.mock(RequestDispatcher.class); this.info = mockery.mock(MethodInfo.class); mockery.checking(new Expectations() { { allowing(request).getParameterMap(); will(returnValue(new HashMap<String, Object>())); allowing(request).getSession(); will(returnValue(session)); allowing(session).getAttribute("org.vraptor.scope.ScopeType_FLASH"); will(returnValue(new HashMap<String, Object>())); allowing(info).getResourceMethod(); will(returnValue(method)); allowing(method).getResource(); will(returnValue(resource)); allowing(info).getResult(); will(returnValue("ok")); } }); FilterChain chain = mockery.mock(FilterChain.class); this.webRequest = new RequestInfo(context, chain, request, response); DefaultPageResult delegate = new DefaultPageResult(request, response, info, resolver, null, null); this.result = new ViewsPropertiesPageResult(this.config, this.resolver, this.info, this.webRequest, info, null, delegate); }
private static String upperFirst(String item) { return item.substring(0, 1).toUpperCase() + item.substring(1); }
public void run() { threadCnt.incrementAndGet(); try {  ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.get(sid); if (bq == null || isSendQueueEmpty(bq)) { ByteBuffer b = lastMessageSent.get(sid); if (b != null) { LOG.debug("Attempting to send lastMessage to sid={}", sid); send(b); } } } catch (IOException e) { LOG.error("Failed to send last message. Shutting down thread.", e); this.finish(); } try { while (running && !shutdown && sock != null) { ByteBuffer b = null; try { ArrayBlockingQueue<ByteBuffer> bq = queueSendMap.get(sid); if (bq != null) { b = pollSendQueue(bq, 1000, TimeUnit.MILLISECONDS); } else { LOG.error("No queue of incoming messages for server {}", sid); break; } if (b != null) { lastMessageSent.put(sid, b); send(b); } } catch (InterruptedException e) { LOG.warn("Interrupted while waiting for message on queue", e); } } } catch (Exception e) { LOG.warn( "Exception when using channel: for id {} my id = {}", sid , QuorumCnxManager.this.mySid, e); } this.finish(); LOG.warn("Send worker leaving thread id {} my id = {}", sid, self.getId()); }
public Thread newThread(Runnable r) { Thread t = new Thread(r, namePrefix + threadNumber.getAndIncrement()); t.setDaemon(daemon); return t; }
public void finishedWithSocket() throws Exception { sender.close(); }
public void testDeleteWithChildren() throws Exception { ZooKeeper zk = createClient(); zk.create("/parent", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); zk.create("/parent/child", new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); try { zk.delete("/parent", -1); fail("Should have received a not equals message"); } catch (KeeperException e) { assertEquals(KeeperException.Code.NotEmpty, e.getCode()); } zk.delete("/parent/child", -1); zk.delete("/parent", -1); zk.close(); }
private void init(int opmode, Key key, IvParameterSpec params) { if ( mIsInited ) {
public void testLoadTrustStore( X509KeyType caKeyType, X509KeyType certKeyType, String keyPassword, Integer paramIndex) throws Exception { init(caKeyType, certKeyType, keyPassword, paramIndex); String path = x509TestContext.getTrustStoreFile(KeyStoreFileType.PKCS12).getAbsolutePath(); KeyStore ts = new PKCS12FileLoader.Builder() .setTrustStorePath(path) .setTrustStorePassword(x509TestContext.getTrustStorePassword()) .build() .loadTrustStore(); assertEquals(1, ts.size()); }
public void testParseWithExtraSpaces() throws Exception { final ZooKeeper zk = createClient(); ZooKeeperMain zkMain = new ZooKeeperMain(zk); String cmdstring = " ls / "; zkMain.cl.parseCommand(cmdstring); assertEquals("Spaces also considered as characters", zkMain.cl.getNumArguments(), 2); assertEquals("ls is not taken as first argument", zkMain.cl.getCmdArgument(0), "ls"); assertEquals("/ is not taken as second argument", zkMain.cl.getCmdArgument(1), "/"); }
public void emptyListReturnsNicely() throws Exception { statements.clear(); ListExecutor.execute(statements); respondsWith(list()); }
@Test public void scansCenters() { ParserTest.assertScans("!c some text\n", "CenterLine=c,Whitespace= ,Text=some,Whitespace= ,Text=text,Newline=\n"); ParserTest.assertScans("!C more text\n", "CenterLine=C,Whitespace= ,Text=more,Whitespace= ,Text=text,Newline=\n"); ParserTest.assertScans("!ctext\n", "CenterLine=c,Text=text,Newline=\n"); ParserTest.assertScans("!c text\n", "CenterLine=c,Whitespace= ,Text=text,Newline=\n"); ParserTest.assertScans(" !c text\n", "Whitespace= ,Text=!c,Whitespace= ,Text=text,Newline=\n"); ParserTest.assertScans("!c text", "CenterLine=c,Whitespace= ,Text=text"); }
public String toString(Object actual) { if (actual == null) return "null"; return actual.toString(); }
protected void setUp() throws Exception { super.setUp(); responder = new AddResponder(); }
public void setUp() throws Exception { testData = new WikiImporterTest(); testData.createRemoteRoot(); testData.createLocalRoot(); FitNesseContext context = FitNesseUtil.makeTestContext(testData.remoteContext.getRootPage(), new OneUserAuthenticator("joe", "blow")); FitNesseUtil.startFitnesseWithContext(context); baseUrl = FitNesseUtil.URL; createResponder(); }
public void loadData(InputArchive ia) throws IOException { sessionsWithTimeouts = new ConcurrentHashMap<Long, Integer>(); dataTree = treeBuilder.build(); int count = ia.readInt("count"); while (count > 0) { long id = ia.readLong("id"); int to = ia.readInt("timeout"); sessionsWithTimeouts.put(id, to); ZooLog.logTextTraceMessage("loadData --- session in archive: " + id + " with timeout: " + to, ZooLog.SESSION_TRACE_MASK); count--; } dataTree.deserialize(ia, "tree"); }
private void applicationScopedComponentsFor(ComponentRegistry container) { container.register(VRaptor2MethodLookupBuilder.class); container.register(VRaptor2PathResolver.class); container.register(VRaptor2Config.class); container.register(VRaptor2Converters.class); container.register(LogicAnnotationWithParanamerParameterNameProvider.class); }
public static void printUsage() { System.err.println("Usage: java fitnesse.authentication.Password [-f <password file>] [-c <password cipher>] <user>"); System.err.println("\t-f <password file> {" + defaultFile + "}"); System.err.println("\t-c <password cipher> {" + defaultCipher + "}"); System.exit(-1); }
public void onComplete(GetFuture<?> f) throws Exception { latch.countDown(); }
public void processResult(int rc, String path, Object ctx); }  @InterfaceAudience.Public interface MultiCallback extends AsyncCallback {  public void processResult(int rc, String path, Object ctx, List<OpResult> opResults); }  interface EphemeralsCallback extends AsyncCallback {  public void processResult(int rc, Object ctx, List<String> paths); } }
public static void main(String[] args) throws Exception { if (parseCommandLine(args)) { new SlimService(port, verbose);
private String rangeMessage(boolean pass) { String[] fragments = expected.replaceAll(" ", "").split("_"); String message = String.format("%s%s%s", fragments[0], actual, fragments[1]); message = replaceSymbolsWithFullExpansion(message); return pass ? returnedValueExpectation.pass(message) : returnedValueExpectation.fail(message);
public boolean grabAndCompareTablesFromHtml() throws ParserException { initializeComparerHelpers(); if (firstScanner.getTableCount() == 0 || secondScanner.getTableCount() == 0) return false; comparer = new TableListComparer(firstScanner,secondScanner); comparer.compareAllTables(); matchedTables = comparer.tableMatches; getTableTextFromScanners(); lineUpTheTables(); makePassFailResultsFromMatches(); return true; }
protected void describeMismatchSafely(Interceptor item, Description mismatchDescription) { } }; } private Matcher<byte[]> arrayStartingWith(final byte[] array) { return new TypeSafeMatcher<byte[]>() { protected void describeMismatchSafely(byte[] item, Description mismatchDescription) { } protected boolean matchesSafely(byte[] item) { if (item.length < array.length) { return false; } for (int i = 0; i < array.length; i++) { if (array[i] != item[i]) { return false; } } return true; } public void describeTo(Description description) { description.appendText("a byte array starting with " + Arrays.toString(array)); } }; } static class FakeResource { public String string() { return null; } public File file() { return null; } public InputStream input() { return null; } public Download download() { return null; } public byte[] asByte() { return null; } } }
private void verifyLiteralsGetRendered(String option, String pageName) throws Exception { crawler.addPage(root, PathParser.parse(pageName), "!-one-!, !-two-!, !-three-!"); ParentWidget widgetRoot = new WidgetRoot(page1); IncludeWidget widget = createIncludeWidget(widgetRoot, option + pageName); final String result = widget.render(); assertSubString("one, two, three", result); assertEquals("one", widgetRoot.getLiteral(0)); assertEquals("two", widgetRoot.getLiteral(1)); assertEquals("three", widgetRoot.getLiteral(2)); }
public void testReadSystemPropertyIfPagePropertyDoesNotExist() { String pageText = "!define TEST_PROPERTY {foo}\n"; System.setProperty("test.property", "bar"); WikiPage page = makeTestPage(pageText); Descriptor descriptor = new WikiPageDescriptor(page.readOnlyData(), false, false, getClassPath(page)); assertEquals("foo", descriptor.getVariable("TEST_PROPERTY")); assertEquals("bar", descriptor.getVariable("test.property")); }
public void tearDown() { System.clearProperty(USE_X_FORWARDED_FOR_KEY); }
public void shouldThrowResourceNotFoundExceptionWhenNoRoutesMatchTheURI() throws Exception { Route route = mock(Route.class); when(route.canHandle(anyString())).thenReturn(false); router.add(route); try { router.parse("any uri", HttpMethod.DELETE, request);
long getServerId(); } long createSession(int sessionTimeout);  boolean trackSession(long id, int to);  boolean commitSession(long id, int to);  boolean touchSession(long sessionId, int sessionTimeout);  void setSessionClosing(long sessionId);  void shutdown();  void removeSession(long sessionId);  boolean isTrackingSession(long sessionId);  public void checkSession(long sessionId, Object owner) throws KeeperException.SessionExpiredException, KeeperException.SessionMovedException, KeeperException.UnknownSessionException;  public void checkGlobalSession(long sessionId, Object owner) throws KeeperException.SessionExpiredException, KeeperException.SessionMovedException; void setOwner(long id, Object owner) throws SessionExpiredException;  void dumpSessions(PrintWriter pwriter);  Map<Long, Set<Long>> getSessionExpiryMap(); }
public void connect(SocketAddress endpoint) throws IOException { getSocketAllowUnknownMode().connect(endpoint); }
public void start(ServletContext context) { } public void stop() { } } @Test public void shouldDeferToContainerIfStaticFile() throws IOException, ServletException { VRaptor raptor = new VRaptor(); final HttpServletRequest request = mockery.mock(HttpServletRequest.class); final HttpServletResponse response = mockery.mock(HttpServletResponse.class); final StaticContentHandler handler = mockery.mock(StaticContentHandler.class); final FilterChain chain = mockery.mock(FilterChain.class); mockery.checking(new Expectations() { { one(handler).requestingStaticFile(request); will(returnValue(true)); one(handler).deferProcessingToContainer(chain, request, response); } }); raptor.init(new DoNothingProvider(), handler); raptor.doFilter(request, response, chain); mockery.assertIsSatisfied(); } }
public void setup() throws Exception { WikiPage root = InMemoryPage.makeRoot("RooT"); context = FitNesseUtil.makeTestContext(root); resultsDirectory = context.getTestHistoryDirectory(); removeResultsDirectory(); resultsDirectory.mkdirs(); history = new TestHistory(); responder = new TestHistoryResponder(); }
public int hashCode() { return counter ^ Arrays.hashCode(seed); }
public void close() throws IOException { closeChunks(); closeTrailer(); sender.close(); }
protected BaseFormatter newHtmlFormatter() { return new SuiteHtmlFormatter(page, isMultipleTestsRun(), response.getWriter()); }
Future<Object> asyncGet(String key); Future<CASValue<Object>> asyncGetAndTouch(final String key, final int exp); <T> Future<CASValue<T>> asyncGetAndTouch(final String key, final int exp, final Transcoder<T> tc); CASValue<Object> getAndTouch(String key, int exp); <T> CASValue<T> getAndTouch(String key, int exp, Transcoder<T> tc); <T> Future<CASValue<T>> asyncGets(String key, Transcoder<T> tc); Future<CASValue<Object>> asyncGets(String key); <T> CASValue<T> gets(String key, Transcoder<T> tc); CASValue<Object> gets(String key); <T> T get(String key, Transcoder<T> tc); Object get(String key); <T> BulkFuture<Map<String, T>> asyncGetBulk(Iterator<String> keys, Iterator<Transcoder<T>> tcs); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Iterator<Transcoder<T>> tcs); <T> BulkFuture<Map<String, T>> asyncGetBulk(Iterator<String> keys, Transcoder<T> tc); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); BulkFuture<Map<String, Object>> asyncGetBulk(Iterator<String> keys); BulkFuture<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> BulkFuture<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); BulkFuture<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Iterator<String> keys, Transcoder<T> tc); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc); Map<String, Object> getBulk(Iterator<String> keys); Map<String, Object> getBulk(Collection<String> keys); <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys); Map<String, Object> getBulk(String... keys); <T> Future<Boolean> touch(final String key, final int exp, final Transcoder<T> tc); <T> Future<Boolean> touch(final String key, final int exp); Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, long by); long incr(String key, int by); long decr(String key, long by); long decr(String key, int by); Future<Long> asyncIncr(String key, long by); Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, long by); Future<Long> asyncDecr(String key, int by); long incr(String key, long by, long def, int exp); long incr(String key, int by, long def, int exp); long decr(String key, long by, long def, int exp); long decr(String key, int by, long def, int exp); Future<Long> asyncIncr(String key, long by, long def, int exp); Future<Long> asyncIncr(String key, int by, long def, int exp); Future<Long> asyncDecr(String key, long by, long def, int exp); Future<Long> asyncDecr(String key, int by, long def, int exp); long incr(String key, long by, long def); long incr(String key, int by, long def); long decr(String key, long by, long def); long decr(String key, int by, long def); Future<Long> asyncIncr(String key, long by, long def); Future<Long> asyncIncr(String key, int by, long def); Future<Long> asyncDecr(String key, long by, long def); Future<Long> asyncDecr(String key, int by, long def); Future<Boolean> delete(String key); Future<Boolean> delete(String key, long cas); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs); CountDownLatch broadcastOp(final BroadcastOpFactory of); CountDownLatch broadcastOp(final BroadcastOpFactory of, Collection<MemcachedNode> nodes);  Set<String> listSaslMechanisms(); }
public AnnotationVisitor visitAnnotation(final String desc, final boolean visible) { AnnotationVisitor av = super.visitAnnotation(desc, visible); if (mv != null) { ((TraceAnnotationVisitor) av).av = mv.visitAnnotation(desc, visible); } return av; }
private String MakeDefinition(String definition) { return "<span class=\"meta\">variable defined: " + definition + "</span>"; }
public void softHalt() { for (SendWorker sw : senderWorkerMap.values()) { LOG.debug("Server {} is soft-halting sender towards: {}", self.getMyId(), sw);
public void visitInnerClassType(final String name) { endArguments(); buf.append('.'); buf.append(name); argumentStack *= 2; }
public void testSocketConnectionTimeoutDuringConnectingToElectionAddress() throws Exception { int leaderId = qu.getLeaderServer();
<T> Future<Boolean> prepend(long cas, String key, T val, Transcoder<T> tc); <T> Future<CASResponse> asyncCAS(String key, long casId, T value, Transcoder<T> tc); Future<CASResponse> asyncCAS(String key, long casId, Object value); <T> CASResponse cas(String key, long casId, T value, Transcoder<T> tc) throws OperationTimeoutException; CASResponse cas(String key, long casId, Object value) throws OperationTimeoutException; <T> Future<Boolean> add(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> add(String key, int exp, Object o); <T> Future<Boolean> set(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> set(String key, int exp, Object o); <T> Future<Boolean> replace(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> replace(String key, int exp, Object o); <T> Future<T> asyncGet(String key, Transcoder<T> tc); Future<Object> asyncGet(String key); <T> Future<CASValue<T>> asyncGets(String key, Transcoder<T> tc); Future<CASValue<Object>> asyncGets(String key); <T> CASValue<T> gets(String key, Transcoder<T> tc) throws OperationTimeoutException; CASValue<Object> gets(String key) throws OperationTimeoutException; <T> T get(String key, Transcoder<T> tc) throws OperationTimeoutException; Object get(String key) throws OperationTimeoutException; <T> Future<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); Future<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> Future<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); Future<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc) throws OperationTimeoutException; Map<String, Object> getBulk(Collection<String> keys) throws OperationTimeoutException; <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys) throws OperationTimeoutException; Map<String, Object> getBulk(String... keys) throws OperationTimeoutException; Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, int by) throws OperationTimeoutException; long decr(String key, int by) throws OperationTimeoutException; Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, int by); long incr(String key, int by, long def) throws OperationTimeoutException; long decr(String key, int by, long def) throws OperationTimeoutException; Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); }
public void imageWidthHandleMistyped() throws Exception { TestRoot root = new TestRoot(); WikiPage testPage = root.makePage("ImagePage", "!img-w name"); ParserTestHelper.assertTranslatesTo(testPage, "!img-w name"); testPage = root.makePage("ImagePage", "!img-wNNN name"); ParserTestHelper.assertTranslatesTo(testPage, "<img src=\"name\" width=\"NNN\"/>"); }
protected Response makeExeptionMessage(String value) { if (value.startsWith(SlimTestSystem.MESSAGE_FAIL)) return fail(value.substring(SlimTestSystem.MESSAGE_FAIL.length()));
boolean append(TxnHeader hdr, Record r) throws IOException;  TxnIterator read(long zxid) throws IOException;  long getLastLoggedZxid() throws IOException;  boolean truncate(long zxid) throws IOException;  long getDbId() throws IOException;  void commit() throws IOException;  public interface TxnIterator {  TxnHeader getHeader();  Record getTxn();  boolean next() throws IOException;  void close() throws IOException; } }
public void canEvaluateReturnValuesAndColorizeTableForMultipleCallsToSameFunction() throws Exception { DecisionTable dt = makeDecisionTableAndBuildInstructions(decisionTableWithSameFunctionMultipleTimes); int n=0; Map<String, Object> pseudoResults = SlimCommandRunningClient.resultToMap( list( list(id(n++), "OK"), list(id(n++), VoidConverter.VOID_TAG), list(id(n++), VoidConverter.VOID_TAG),
public void testInvalidKey3() throws Exception { try { Object val=client.get("Key\n");
protected String getPageFooterInfo(int hits) throws Exception {
public String getLockFileName(WikiPage test) throws Exception {
public boolean matches() throws InterruptedException { if (!latch.await(CONNECTION_TIMEOUT/5, TimeUnit.MILLISECONDS)) { return false; } return path.equals(eventPath) && rc == eventRc; }
public void run() { if ( mSuccess ) { GroupActivity.Launch(PasswordActivity.this);
public List<Class<? extends Interceptor>> all() { return interceptors; }
public void doWork() throws InterruptedException { if (!key.isValid()) { selectorThread.cleanupSelectionKey(key); return; } if (key.isReadable() || key.isWritable()) { cnxn.doIO(key);
public void visitEnum(final String name, final String desc, final String value) { checkEnd(); checkName(name); CheckMethodAdapter.checkDesc(desc, false); if (value == null) { throw new IllegalArgumentException("Invalid enum value"); } if (av != null) { av.visitEnum(name, desc, value);
public void testComplete(TestPage test, TestSummary summary, TimeMeasurement timeMeasurement) throws Exception { testCount++; if (summary.wrong > 0) { failCount++; } if (summary.exceptions > 0) { failCount++;
public void canProvideAllApplicationScopedComponents() { Class<?>[] components = new Class[]{ServletContext.class, UrlToResourceTranslator.class, ResourceRegistry.class, TypeCreator.class, InterceptorRegistry.class, MethodLookupBuilder.class, ParameterNameProvider.class, Converters.class, EmptyElementsRemoval.class}; checkAvailabilityFor(true, components); mockery.assertIsSatisfied(); }
public boolean equals(Object o) { if (!(o instanceof MethodKey)) return false; MethodKey m = (MethodKey) o; if (m.nArgs != nArgs) return false; if (!m.k.equals(k)) return false; return m.method.equals(method); }
public void testValidatePath_0x20() { PathUtils.validatePath("/test\u0020"); }
public void shouldNotAcceptIfMethodHasConstraint() { interceptor = new MethodValidatorInterceptor(null, null, null, null, null, null); assertThat(interceptor.accepts(withoutConstraint), is(false)); }
static void appendAccess(final int access, final StringBuffer sb) { if ((access & Opcodes.ACC_PUBLIC) != 0) { sb.append("public "); } if ((access & Opcodes.ACC_PRIVATE) != 0) { sb.append("private "); } if ((access & Opcodes.ACC_PROTECTED) != 0) { sb.append("protected "); } if ((access & Opcodes.ACC_FINAL) != 0) { sb.append("final "); } if ((access & Opcodes.ACC_STATIC) != 0) { sb.append("static "); } if ((access & Opcodes.ACC_SUPER) != 0) { if ((access & ACCESS_CLASS) == 0) { sb.append("synchronized "); } else { sb.append("super "); } } if ((access & Opcodes.ACC_VOLATILE) != 0) { if ((access & ACCESS_FIELD) == 0) { sb.append("bridge "); } else { sb.append("volatile "); } } if ((access & Opcodes.ACC_TRANSIENT) != 0) { if ((access & ACCESS_FIELD) == 0) { sb.append("varargs "); } else { sb.append("transient "); } } if ((access & Opcodes.ACC_NATIVE) != 0) { sb.append("native "); } if ((access & Opcodes.ACC_STRICT) != 0) { sb.append("strict "); } if ((access & Opcodes.ACC_INTERFACE) != 0) { sb.append("interface "); } if ((access & Opcodes.ACC_ABSTRACT) != 0) { sb.append("abstract "); } if ((access & Opcodes.ACC_SYNTHETIC) != 0) { sb.append("synthetic "); } if ((access & Opcodes.ACC_ANNOTATION) != 0) { sb.append("annotation "); } if ((access & Opcodes.ACC_ENUM) != 0) { sb.append("enum "); } if ((access & Opcodes.ACC_DEPRECATED) != 0) { sb.append("deprecated ");
private SimpleResponse movePage(String pageToMove, String newParent, boolean refactorReferences) throws Exception
public int getPendingRevalidationCount();  public long getElectionTimeTaken(); }
public Collection<VersionInfo> history(final FileSystemPage page) { return new HashSet<VersionInfo>(); }
private void expectsParametersWereSet(final boolean wereSet) { mockery.checking(new Expectations() { {
<T> Map<String, T> getBulk(Transcoder<T> tc, String... keys) throws OperationTimeoutException; Map<String, Object> getBulk(String... keys) throws OperationTimeoutException; Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, int by) throws OperationTimeoutException; long decr(String key, int by) throws OperationTimeoutException; long incr(String key, int by, long def, int exp) throws OperationTimeoutException; long decr(String key, int by, long def, int exp) throws OperationTimeoutException; Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, int by); long incr(String key, int by, long def) throws OperationTimeoutException; long decr(String key, int by, long def) throws OperationTimeoutException; Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs);  void authenticate(String mechs[], CallbackHandler cbh) throws OperationException; }
PageCrawler getPageCrawler(); WikiPage getHeaderPage(); WikiPage getFooterPage();
private void makeResponse() throws Exception { response = (SimpleResponse) responder.makeResponse(context, new MockRequest()); }
@Test public void translatesAnchors() { ParserTest.assertTranslatesTo(".#anchorName", anchorReferenceWithName("anchorName")); ParserTest.assertTranslatesTo(".#anchorName stuff", anchorReferenceWithName("anchorName") + " stuff"); ParserTest.assertTranslatesTo("more.#anchorName stuff", "more" + anchorReferenceWithName("anchorName") + " stuff"); ParserTest.assertTranslatesTo("more\n.#anchorName stuff", "more<br/>" + HtmlElement.endl
private static Field getField(Class<?> clazz, String fieldName) throws NoSuchFieldException { try { return clazz.getDeclaredField(fieldName);
protected SlimTestContextImpl createTestContext(TestPage testPage) { return new SlimTestContextImpl(); }
default void registerTestRunFactories(TestRunFactoryRegistry runFactoryRegistry, FitNesseContext context) throws PluginException { } }
private double term() { double ans = 0; StringBuffer temp = new StringBuffer(); while (!s.isEmpty() && Character.isDigit(s.charAt(0))) { temp.append(Integer.parseInt("" + s.charAt(0))); advance(); } if (!s.isEmpty() && s.charAt(0) == '.') { temp.append('.'); advance(); while (!s.isEmpty() && Character.isDigit(s.charAt(0))) { temp.append(Integer.parseInt("" + s.charAt(0))); advance(); } } if (!s.isEmpty() && (s.charAt(0) == 'e' || s.charAt(0) == 'E')) { temp.append('e'); advance(); temp.append(s.charAt(0)); advance(); while (!s.isEmpty() && Character.isDigit(s.charAt(0))) { temp.append(Integer.parseInt("" + s.charAt(0))); advance(); } } if (temp.length() == 0)
public void validDataDoesntThrowException() { DefaultValidator validator = new DefaultValidator(proxifier, result,logic); final Student guilherme = new Student(); guilherme.id = 15L; validator.checking(new Validations() { {
public boolean pageExists(WikiPagePath path) { return getPage(path) != null; }
Counter getCounter(String name);  boolean registerGauge(String name, Gauge gauge); static enum DetailLevel {  BASIC,  ADVANCED }  Summary getSummary(String name, DetailLevel detailLevel);  SummarySet getSummarySet(String name, DetailLevel detailLevel); }
public DERObject toASN1Object() { ASN1EncodableVector v = new ASN1EncodableVector(); addOptional(v, 0, intendedAlg); addOptional(v, 1, symmAlg); addOptional(v, 2, encSymmKey); addOptional(v, 3, keyAlg); addOptional(v, 4, valueHint); v.add(encValue); return new DERSequence(v); }
private void setSockOpts(Socket sock) throws SocketException { sock.setTcpNoDelay(true); sock.setKeepAlive(tcpKeepAlive); sock.setSoTimeout(self.tickTime * self.syncLimit); }
public void originalContentCanBeRetrievedViaVersionInfo() throws Exception { PageData data = page.getData(); data.setContent("new content"); VersionInfo version = page.commit(data); PageData loadedData = page.getVersion(version.getName()).getData(); assertEquals("original content", loadedData.getContent()); }
public static void Launch(Activity act, PwGroup pw) { if ( !(pw instanceof PwGroupV3) ) { throw new RuntimeException("Not yet implemented."); } Intent i = new Intent(act, EntryEditActivity.class); PwGroupV3 parent = (PwGroupV3) pw; i.putExtra(KEY_PARENT, parent.groupId); act.startActivityForResult(i, 0); }
public void functionCallWithSequentialArgumentProcessingAndMultipleArguments() throws Exception { buildInstructionsFor("|function;|arg0|arg1|arg2|\n"); List<CallInstruction> expectedInstructions = asList( new CallInstruction("htmlScriptTable_id_0", "htmlScriptTableActor", "function", new Object[]{"arg0", "arg1", "arg2"}) ); assertEquals(expectedInstructions, instructions()); }
public void checkHistoryForSimpleSlimTable() throws Exception { ensureXmlResultFileDoesNotExist(new TestSummary(2, 0, 0, 0)); doSimpleRun(simpleSlimDecisionTable()); Document xmlFromFile = getXmlFromFileAndDeleteFile(); xmlChecker.assertXmlHeaderIsCorrect(xmlFromFile); assertHasRegexp("<td><span class=\"pass\">wow</span></td>", Utils.unescapeHTML(results)); }
void setupResend();  void fillWriteBuffer(boolean optimizeGets);  void transitionWriteItem();  Operation getCurrentReadOp();  Operation removeCurrentReadOp();  Operation getCurrentWriteOp();  Operation removeCurrentWriteOp();  boolean hasReadOp();  boolean hasWriteOp();  void addOp(Operation op);  int getSelectionOps();  ByteBuffer getRbuf();  ByteBuffer getWbuf();  SocketAddress getSocketAddress();  boolean isActive();  void reconnecting();  void connected();  int getReconnectCount();  void registerChannel(SocketChannel ch, SelectionKey selectionKey);  void setChannel(SocketChannel to);  SocketChannel getChannel();  void setSk(SelectionKey to);  SelectionKey getSk();  int getBytesRemainingToWrite();  int writeSome() throws IOException;  void fixupOps(); }
public void testByteArray() throws Exception { byte[] a={'a', 'b', 'c'}; try { CachedData cd=getTranscoder().encode(a);
public void intercept(InterceptorStack stack, ResourceMethod method, Object resourceInstance) throws IOException, InterceptionException { if (info.isAjax()) { JsonOutjecter outjecter = (JsonOutjecter) this.outjecter;
public synchronized void timeOut() { assert (state != OperationState.READING || state != OperationState.COMPLETE); timedout = true; callback.complete(); }
public void shouldUseTheDefaultLocale() throws ParseException { when(request.getAttribute(LOCALE_KEY + ".request")).thenReturn(null); when(request.getSession()).thenReturn(session); when(session.getAttribute(LOCALE_KEY + ".session")). thenReturn(null); when(context.getAttribute(LOCALE_KEY + ".application")). thenReturn(null); when(context.getInitParameter(LOCALE_KEY)). thenReturn(null); when(request.getLocale()).thenReturn(null); Date date = new SimpleDateFormat("HH:mm:ss").parse("23:52:00"); String formattedHour = DateFormat.getTimeInstance(DateFormat.SHORT).format(date); assertThat(converter.convert(formattedHour, Time.class, bundle), is(equalTo(date)));
public void list() { result.include("clients", database.all()); }
protected void buildWidgets(String value) throws Exception { String nonLiteralContent = processLiterals(value); addChildWidgets(nonLiteralContent); }
public RevDetails[] toRevDetailsArray() { RevDetails[] result = new RevDetails[content.size()]; for (int i = 0; i != result.length; i++) { result[i] = RevDetails.getInstance(content.getObjectAt(i)); } return result; }
public Maybe<Symbol> parse(Parser parser) { Scanner scanner = parser.getScanner(); Symbol result = new Symbol(scanner.getCurrentType(), scanner.getCurrentContent()); scanner.moveNext(); if (!scanner.isType(SymbolType.Whitespace)) return Symbol.Nothing; Symbol body = Parser.makeEnds(getPage(), scanner, makeEnds(parser)).parse(); return new Maybe<Symbol>(result.add(body)); }
public static void cmUpdate(String file, String payload) throws IOException { Runtime.getRuntime().exec("/usr/local/bin/git add " + file); }
public static long newIdNumber() { return System.currentTimeMillis(); }
public void setUp() throws Exception { super.setUp(); events = new LinkedBlockingQueue<>(); persistentWatcher = event -> events.add(event); }
long getLastZxid();  long getLastResponseTime();  long getLastLatency();  void reset(); } Stats getStats(); }
public void includeAll(List<String> names) { checkPresenceOf(names); includes.addAll(names); }
public void setup() throws Exception { pageDriver = new PageDriver(); FitnesseFixtureContext.sender = new MockResponseSender(); FitnesseFixtureContext.sender.send("\r\n\r\n<asdf id=\"123_\" /><asdf id=\"125_\" />".getBytes()); }
public void testHandleRequestERR() throws Exception { String[] files = {""}; MyMergedLogSource mls = new MyMergedLogSource(files); final JsonServlet.JsonRequest jsonRequest = mock(JsonServlet.JsonRequest.class); when(jsonRequest.getString("path", "/")).thenReturn("/tmp3"); FileLoader fl = new FileLoader(mls); String s = fl.handleRequest(jsonRequest); Assertions.assertEquals("{\"status\":\"ERR\",\"error\":\"java.io.IOException: Message\"}", s); Assertions.assertFalse(mls.getSources().contains(new MySource("/tmp"))); Assertions.assertFalse(mls.getSources().contains(new MySource("/tmp2"))); }
public void includeScenarioLibraryBrother() throws Exception { WikiPage slimTestPage = addPage("SlimTest", "!define TEST_SYSTEM {slim}\n"); TestPage testPage = new WikiTestPage(slimTestPage); addPage("ScenarioLibrary", "scenario library"); String html = testPage.getDecoratedData().getHtml(); assertSubString("scenario library", html); }
private String processHTMLWidgets(WikiPage context) throws Exception { Symbol tree = getSyntaxTree(); return new HtmlTranslator(new WikiSourcePage(context), parsingPage).translateTree(tree); }
public void setup() { this.converter = new BigDecimalConverter(); }
String getSymbol(String symbolName); void setSymbol(String symbolName, String value); void addScenario(String scenarioName, ScenarioTable scenarioTable); ScenarioTable getScenario(String scenarioName); void addExpectation(Expectation e); Map<String, ScenarioTable> getScenarios(); void incrementPassedTestsCount(); void incrementFailedTestsCount(); void incrementErroredTestsCount(); void incrementIgnoredTestsCount(); }
public Object[] query() { int n = Integer.parseInt(args[0]); ArrayList<Factor> factors = new ArrayList<Factor>(); for (int f = 2; n > 1; f++) for (; n % f == 0; n /= f) factors.add(new Factor(f)); return factors.toArray(new Factor[0]); }
private void registerRulesFor(Class<?> type) { RoutesParser parser = new PathAnnotationRoutesParser(router); List<Route> rules = parser.rulesFor(mockery.resource(type)); for (Route route : rules) { router.add(route);
public void setUp() throws Exception { buffer = new StringBuilder(); response = new ChunkedResponse("html", new MockChunkedDataProvider()); response.sendTo(this); }
public void intercept(InterceptorStack stack, ResourceMethod method, Object resourceInstance) throws InterceptionException { } public boolean accepts(ResourceMethod method) { return true; } } @Test public void shouldReturnAnInterceptorWhichAcceptsTheGivenResource() throws InterceptionException, IOException { mockery.checking(new Expectations() { { one(container).instanceFor(CustomInterceptor.class); will(returnValue(interceptor)); one(interceptor).accepts(method); will(returnValue(true)); } }); registry.register(CustomInterceptor.class); Interceptor[] types = registry.interceptorsFor(method, container); assertThat(types.length, is(1)); assertThat(types[0], is(equalTo(interceptor))); mockery.assertIsSatisfied(); } @Test public void shouldNotReturnAnInterceptorWhichDoesNotAcceptTheGivenResource() { mockery.checking(new Expectations() { { one(container).instanceFor(CustomInterceptor.class); will(returnValue(interceptor)); one(interceptor).accepts(method); will(returnValue(false)); } }); registry.register(CustomInterceptor.class); Interceptor[] types = registry.interceptorsFor(method, container); assertThat(types.length, is(0)); mockery.assertIsSatisfied(); } @Test public void shouldReturnNoInterceptorIfThereIsNoneRegistered() { Interceptor[] types = registry.interceptorsFor(method, container); assertThat(types.length, is(0)); mockery.assertIsSatisfied(); } }
public void testFNV164() { HashMap<String, Long> exp = new HashMap<String, Long>(); exp.put("", 0x84222325L); exp.put(" ", 0x8601b7ffL); exp.put("hello world!", 0xb97b86bcL); exp.put("Lorem ipsum dolor sit amet, consectetuer adipiscing elit.", 0xe87c054aL); exp.put("wd:com.google", 0x071b08f8L); exp.put("wd:com.google ", 0x12f03d48L); for (Map.Entry<String, Long> me : exp.entrySet()) { assertHash(DefaultHashAlgorithm.FNV1_64_HASH, me.getKey(),
public <T> Future<T> decode(final Transcoder<T> tc, final CachedData cachedData) { assert !pool.isShutdown() : "Pool has already shut down."; TranscodeService.Task<T> task = new TranscodeService.Task<T>(new Callable<T>() { public T call() { return tc.decode(cachedData); } }); if (tc.asyncDecode(cachedData)) { this.pool.execute(task); } return task; }
private T resolveByOrdinal(String value, Class<T> enumType, ResourceBundle bundle) { try { int ordinal = Integer.parseInt(value);
public MutableResponse get() { return VRaptorRequestHolder.currentRequest().getResponse(); }
private void close(Migration migration, PreparedStatement stmt) { if (stmt != null) { try {
public void testSecondMatchingSuiteFilter() throws Exception { addTestPagesWithSuiteProperty(); request.setQueryString("suiteFilter=smoke"); String results = runSuite(); assertDoesntHaveRegexp(".*href=\"#TestOne\".*", results); assertDoesntHaveRegexp(".*href=\"#TestTwo\".*", results); assertHasRegexp(".*href=\"#TestThree\".*", results); }
private static List<String> readAuditLog(ByteArrayOutputStream os, int numberOfLogEntry, boolean skipEphemralDeletion) throws IOException { List<String> logs = new ArrayList<>(); LineNumberReader r = new LineNumberReader( new StringReader(os.toString())); String line; while ((line = r.readLine()) != null) { if (skipEphemralDeletion && line.contains(AuditConstants.OP_DEL_EZNODE_EXP)) { continue; } logs.add(line); } os.reset(); assertEquals( "Expected number of log entries are not generated. Logs are " + logs, numberOfLogEntry, logs.size()); return logs;
public void addChildTable(SlimTable slimtable, int row) { slimtable.id = id + "." + children.size(); slimtable.tableName = makeInstructionTag() + "/" + slimtable.tableName; slimtable.parent = this; children.add(slimtable); Table parentTable = getTable(); Table childTable = slimtable.getTable(); parentTable.appendChildTable(row, childTable); }
public void idPrefixTagCount() throws Exception { assertEquals(0, pageDriver.countOfTagWithIdPrefix("asdf", null)); assertEquals(0, pageDriver.countOfTagWithIdPrefix("asdf", "124")); assertEquals(0, pageDriver.countOfTagWithIdPrefix("blah", "123")); assertEquals(1, pageDriver.countOfTagWithIdPrefix("asdf", "123")); assertEquals(2, pageDriver.countOfTagWithIdPrefix("asdf", "12")); }
public void shouldReturnBasePackagesArrayWhenInitParamNotNullAndHasComasAndSpaces() throws ServletException { when(context.getInitParameter(BasicConfiguration.BASE_PACKAGES_PARAMETER_NAME)).thenReturn("some.packages, \n other.packages"); MatcherAssert.assertThat(config.getBasePackages(), is(new String[] {"some.packages", "other.packages"})); }
public CommandResponse run(ZooKeeperServer zkServer, Map<String, String> kwargs) { CommandResponse response = initializeResponse(); response.put("read_only", zkServer instanceof ReadOnlyZooKeeperServer); return response; }
void testSnapshotSerializationCompatibility(Boolean digestEnabled, Boolean snappyEnabled) throws IOException { File dataDir = ClientBase.createEmptyTestDir(); FileTxnSnapLog snaplog = new FileTxnSnapLog(dataDir, dataDir); DataTree dataTree = new DataTree(); ConcurrentHashMap<Long, Integer> sessions = new ConcurrentHashMap<>(); SnapStream.setStreamMode(snappyEnabled ? SnapStream.StreamMode.SNAPPY : SnapStream.StreamMode.DEFAULT_MODE); ZooKeeperServer.setDigestEnabled(digestEnabled);
public void shouldReturnEmptyCollectionWhenBeanIsNull() { assertThat(beanValidator.validateProperty(null, "age", AnotherGroupValidation.class), hasSize(0)); }
public VersionInfo makeVersion(final FileVersion... fileVersions) throws IOException { makeZipVersion(fileVersions); pruneVersions(history(toFiles(fileVersions))); return persistence.makeVersion(fileVersions); }
WikiPage addPage(WikiPage context, WikiPagePath path, String content); WikiPage addPage(WikiPage context, WikiPagePath path); String getRelativeName(WikiPage base, WikiPage page); boolean isRoot(WikiPage page); WikiPage getRoot(WikiPage page); void traverse(WikiPage root, TraversalListener<? super WikiPage> pageCrawlerTest); WikiPage getSiblingPage(WikiPage page, WikiPagePath pathRelativeToSibling); WikiPage findAncestorWithName(WikiPage page, String name); }
public void testSidebar() throws Exception { assertSubString("<div class=\"sidebar", html); assertSubString("<div class=\"art_niche", html); assertSubString("<div class=\"actions", html); }
public void testOutputChunk(String output) { } @Override public void testComplete(TestPage test, TestSummary testSummary, TimeMeasurement timeMeasurement) { } @Override public void writeHead(String pageType) throws Exception { } }
public Iterator<HtmlTable> iterator() { return tables.iterator(); }
List<String> getServers(); List<URL> getCouchServers(); List<VBucket> getVbuckets(); ConfigType getConfigType(); }
@Test public void scansDoubleQuotes() { ParserTest.assertScansTokenType("''italic''", TokenType.Italic, true); ParserTest.assertScansTokenType("'' 'italic' ''", TokenType.Italic, true); }
public void shouldBeAbleToConvert() throws ParseException { when(request.getAttribute(LOCALE_KEY + ".request")).thenReturn("pt_br"); assertThat(converter.convert("10/06/2008", Date.class, bundle), is(equalTo(new SimpleDateFormat("dd/MM/yyyy") .parse("10/06/2008"))));
private void readPools(String bucketToFind) throws ConfigurationException {
public void testServerStartShouldFailWhenAuthProviderIsNotConfigured() throws Exception { Map<String, String> prop = new HashMap<>(); prop.put(removeZooKeeper(AuthenticationHelper.ENFORCE_AUTH_ENABLED), "true"); prop.put(removeZooKeeper(AuthenticationHelper.ENFORCE_AUTH_SCHEMES), "sasl"); testServerCannotStart(prop); }
private void addPathToClassPathString(String separator, String path) { path = surroundPathWithQuotesIfItHasSpaces(path); if (!addedPaths.contains(path)) { addedPaths.add(path);
protected void finishedPayload(byte[] pl) throws IOException { if (keyLen > 0) { final byte[] keyBytes = new byte[keyLen]; final byte[] data = new byte[pl.length - keyLen]; System.arraycopy(pl, 0, keyBytes, 0, keyLen); System.arraycopy(pl, keyLen, data, 0, pl.length - keyLen); Callback cb = (Callback) getCallback(); cb.gotStat(new String(keyBytes, "UTF-8"), new String(data, "UTF-8")); } else { OperationStatus status = getStatusForErrorCode(errorCode, pl); getCallback().receivedStatus(status); transitionState(OperationState.COMPLETE); } resetInput(); }
boolean touchSession(long sessionId, int sessionTimeout);  void setSessionClosing(long sessionId);  void shutdown();  void removeSession(long sessionId);  boolean isTrackingSession(long sessionId);  public void checkSession(long sessionId, Object owner) throws KeeperException.SessionExpiredException, KeeperException.SessionMovedException, KeeperException.UnknownSessionException;  public void checkGlobalSession(long sessionId, Object owner) throws KeeperException.SessionExpiredException, KeeperException.SessionMovedException; void setOwner(long id, Object owner) throws SessionExpiredException;  void dumpSessions(PrintWriter pwriter); }
private void print(String message) { if (verbose) System.out.print(message);
Collection<ScenarioTable> getScenarios(); void incrementPassedTestsCount(); void incrementFailedTestsCount(); void incrementErroredTestsCount(); void incrementIgnoredTestsCount(); void increment(ExecutionResult testSummary); void increment(TestSummary testSummary); }
public void join() throws InterruptedException { synchronized (this) { while (!killed) {
public void clear() { groups.clear(); entries.clear(); dirty.clear(); drawFactory.clear(); root = null; pm = null; mFilename = null; loaded = false; }
public void testInvokesAllInterceptorsInItsCorrectOrder() throws IOException { DefaultInterceptorStack stack = new DefaultInterceptorStack(null); CountInterceptor first = new CountInterceptor(); CountInterceptor second = new CountInterceptor(); stack.add(first); stack.add(second); stack.next(null,null); assertThat(first.run, is(equalTo(0))); assertThat(second.run, is(equalTo(1))); }
public void testComplete_closesResultRepositoryAndAddsToTotalTestSummary() throws Exception{ jf.setTotalSummary(new TestSummary(1,2,3,4)); TimeMeasurement timeMeasurement = new TimeMeasurement().start(); jf.testComplete(buildNestedTestPage(), new TestSummary(5,6,7,8), timeMeasurement.stop()); assertEquals(new TestSummary(6,8,10,12),jf.getTotalSummary()); verify(mockResultsRepository).close(); }
public void testACLWithExtraAgruments() throws Exception { final ZooKeeper zk = createClient(); ZooKeeperMain zkMain = new ZooKeeperMain(zk);
Collection<ScenarioTable> getScenarios(); void incrementPassedTestsCount(); void incrementFailedTestsCount(); void incrementErroredTestsCount(); void incrementIgnoredTestsCount(); void increment(ExecutionResult testSummary); void increment(TestSummary testSummary); TestPage getPageToTest(); void setCurrentScript(Class<? extends ScriptTable> scriptTableClass, String actorName); Class<? extends ScriptTable> getCurrentScriptClass(); String getCurrentScriptActor(); }
public synchronized List<ACL> convertLong(Long longVal) { if (longVal == null) { return null; } if (longVal == OPEN_UNSAFE_ACL_ID) { return ZooDefs.Ids.OPEN_ACL_UNSAFE; } List<ACL> acls = longKeyMap.get(longVal); if (acls == null) { LOG.error("ERROR: ACL not available for long " + longVal); throw new RuntimeException("Failed to fetch acls for " + longVal); } return acls; }
public void add(byte[] bytes) { if (bytes == null || bytes.length == 0) return; if (dontChunk) { send(bytes); } else { String sizeLine = asHex(bytes.length) + CRLF; ByteBuffer chunk = ByteBuffer.allocate(sizeLine.length() + bytes.length + 2); chunk.put(sizeLine.getBytes()).put(bytes).put(CRLF.getBytes()); send(chunk.array()); } bytesSent += bytes.length; }
void redirectTo(String url);  <T> T of(Class<T> controllerType);  void redirect(String url);  void forward(String url);  void forward(); }
private void trimExtraLines(List<String> lines) { while (lines.size() > 100) lines.remove(100);
boolean isAuthenticated();  long lastReadDelta();  void completedRead();  void reconnecting();  void connected();  int getReconnectCount();  void registerChannel(SocketChannel ch, SelectionKey selectionKey);  void setChannel(SocketChannel to);  SocketChannel getChannel();  void setSk(SelectionKey to);  SelectionKey getSk();  int getBytesRemainingToWrite();  int writeSome() throws IOException;  void fixupOps();  void authComplete();  void setupForAuth();  void setContinuousTimeout(boolean timedOut); int getContinuousTimeout(); MemcachedConnection getConnection(); void setConnection(MemcachedConnection connection); }
public void setupsAreHidden() { String result = ParserTestHelper.translateTo(makePageThatIncludesSetup()); assertContains(result, "class=\"collapsible closed\""); assertContains(result, "<a href=\"PageTwo.SetUp\">"); }
protected String makeInstructionTag(int instructionNumber) { return String.format("%s_%d", tableName, instructionNumber); }
boolean append(TxnHeader hdr, Record r) throws IOException;  TxnIterator read(long zxid) throws IOException;  long getLastLoggedZxid() throws IOException;  boolean truncate(long zxid) throws IOException;  long getDbId() throws IOException;  void commit() throws IOException;  long getTxnLogSyncElapsedTime();  void setTotalLogSize(long size);  long getTotalLogSize();  interface TxnIterator extends Closeable {  TxnHeader getHeader();  Record getTxn();  boolean next() throws IOException;  long getStorageSize() throws IOException; } }
Future<Boolean> add(String key, int exp, Object o); <T> Future<Boolean> set(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> set(String key, int exp, Object o); <T> Future<Boolean> replace(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> replace(String key, int exp, Object o); <T> Future<T> asyncGet(String key, Transcoder<T> tc); Future<Object> asyncGet(String key); Future<CASValue<Object>> asyncGetAndTouch(final String key, final int exp); <T> Future<CASValue<T>> asyncGetAndTouch(final String key, final int exp, final Transcoder<T> tc); CASValue<Object> getAndTouch(String key, int exp); <T> CASValue<T> getAndTouch(String key, int exp, Transcoder<T> tc); <T> Future<CASValue<T>> asyncGets(String key, Transcoder<T> tc); Future<CASValue<Object>> asyncGets(String key); <T> CASValue<T> gets(String key, Transcoder<T> tc); CASValue<Object> gets(String key); <T> T get(String key, Transcoder<T> tc); Object get(String key); <T> BulkFuture<Map<String, T>> asyncGetBulk(Iterator<String> keys, Iterator<Transcoder<T>> tcs); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Iterator<Transcoder<T>> tcs); <T> BulkFuture<Map<String, T>> asyncGetBulk(Iterator<String> keys, Transcoder<T> tc); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); BulkFuture<Map<String, Object>> asyncGetBulk(Iterator<String> keys); BulkFuture<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> BulkFuture<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); BulkFuture<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Iterator<String> keys, Transcoder<T> tc); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc); Map<String, Object> getBulk(Iterator<String> keys); Map<String, Object> getBulk(Collection<String> keys); <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys); Map<String, Object> getBulk(String... keys); <T> Future<Boolean> touch(final String key, final int exp, final Transcoder<T> tc); <T> Future<Boolean> touch(final String key, final int exp); Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, long by); long incr(String key, int by); long decr(String key, long by); long decr(String key, int by); Future<Long> asyncIncr(String key, long by); Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, long by); Future<Long> asyncDecr(String key, int by); long incr(String key, long by, long def, int exp); long incr(String key, int by, long def, int exp); long decr(String key, long by, long def, int exp); long decr(String key, int by, long def, int exp); Future<Long> asyncIncr(String key, long by, long def, int exp); Future<Long> asyncIncr(String key, int by, long def, int exp); Future<Long> asyncDecr(String key, long by, long def, int exp); Future<Long> asyncDecr(String key, int by, long def, int exp); long incr(String key, long by, long def); long incr(String key, int by, long def); long decr(String key, long by, long def); long decr(String key, int by, long def); Future<Long> asyncIncr(String key, long by, long def); Future<Long> asyncIncr(String key, int by, long def); Future<Long> asyncDecr(String key, long by, long def); Future<Long> asyncDecr(String key, int by, long def); Future<Boolean> delete(String key); Future<Boolean> delete(String key, long cas); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs); CountDownLatch broadcastOp(final BroadcastOpFactory of); CountDownLatch broadcastOp(final BroadcastOpFactory of, Collection<MemcachedNode> nodes);  Set<String> listSaslMechanisms(); }
public void testVariableSubstitution() throws Exception { Map<String, String> map = new HashMap<String, String>(); map.put("VERSION", "1.2"); map.put("MAINTAINER", "Torsten Curdt <tcurdt@vafer.org>"); String controlFile = "Version: [[VERSION]]\n" + "Maintainer: [[MAINTAINER]]\n" + "NoResolve1: test[[test\n" + "NoResolve2: [[test]]\n"; FilteredConfigurationFile filteredFile = new FilteredConfigurationFile("control", new ByteArrayInputStream(controlFile.getBytes()), new MapVariableResolver(map)); PackageDescriptor d = new PackageDescriptor(new ByteArrayInputStream(filteredFile.toString().getBytes())); assertEquals("1.2", d.get("Version")); assertEquals("Torsten Curdt <tcurdt@vafer.org>", d.get("Maintainer")); assertEquals("test[[test", d.get("NoResolve1")); assertEquals("[[test]]", d.get("NoResolve2")); }
public void addCommittedProposal(Request request) { synchronized (committedLog) { if (committedLog.size() > commitLogCount) {
public void serialize() { for (Entry<Class<?>, String> exclude : excludes.entries()) { xstream.omitField(exclude.getKey(), exclude.getValue()); } xstream.toXML(root, writer); }
public void carriageReturnsShouldNotMatterIfPresentOnPage() throws Exception { WikiPage root = InMemoryPage.makeRoot("RooT"); PageCrawler crawler = root.getPageCrawler(); WikiPage page = crawler.addPage(root, PathParser.parse("TestPage"), "''italics''\r\n\r'''bold'''\r\n\r"); PageData data = page.getData(); String html = data.getHtml(); assertEquals("<i>italics</i><br/><b>bold</b><br/>", html); }
public void buildFullySpecifiedTestSystemName() throws Exception { WikiPage testPage = crawler.addPage(root, PathParser.parse("TestPage"), "!define TEST_SYSTEM {system}\n" + "!define TEST_RUNNER {runner}\n"); String testSystemName = TestSystem.getDescriptor(testPage, false).getTestSystemName(); Assert.assertEquals("system:runner", testSystemName); }
public void restoreShouldRestoreStaticGlobalClock() throws Exception { clock = new TimeAlteringClock(0, 0); assertThat(Clock.currentTimeInMillis(), is(0L)); clock.restoreDefaultClock(); assertThat(Clock.currentTimeInMillis(), is(not(clock.currentClockTimeInMillis()))); }
public void shouldResolveToSingletonScopeByDefault() { ScopeMetadata scopeMetadata = readScopeMetadata(DummyComponent.class); Assert.assertEquals(ScopedProxyMode.NO, scopeMetadata.getScopedProxyMode()); Assert.assertEquals(BeanDefinition.SCOPE_SINGLETON, scopeMetadata.getScopeName()); }
WikiPage addChildPage(String name); boolean hasChildPage(String name); WikiPage getChildPage(String name); void removeChildPage(String name); List<WikiPage> getChildren(); String getName(); PageData getData(); PageData getDataVersion(String versionName); VersionInfo commit(PageData data); PageCrawler getPageCrawler(); WikiPage getHeaderPage(); WikiPage getFooterPage();
public void setUp() throws Exception { root = InMemoryPage.makeRoot("root"); crawler = root.getPageCrawler(); context = FitNesseUtil.makeTestContext(root); request = new MockRequest(); responder = getSlimResponder(); responder.setFastTest(true);
public void inputAndOutputWithSymbol() throws Exception { makeTables( "!|scenario|echo|input|giving|output|\n" + "|check|echo|@input|@output|\n" + "\n" + "!|script|\n" + "|$V=|echo|7|\n" + "|echo|$V|giving|$V|\n" ); Map<String, Object> pseudoResults = SlimClient.resultToMap( list( list("scriptTable_id_0", "7"), list("scriptTable_id.0_0", "7") ) ); evaluateExpectations(pseudoResults); String scriptTable = script.getChild(0).getTable().toString(); String expectedScript = "[[scenario, echo, input, giving, output], [check, echo, $V->[7], pass($V->[7])]]"; assertEquals(expectedScript, scriptTable); }
public static boolean areEqual( byte[] a, byte[] b) { if (a == b) { return true; } if (a == null || b == null) { return false; } if (a.length != b.length) { return false; } for (int i = 0; i != a.length; i++) { if (a[i] != b[i]) { return false; } } return true; }
public void testNegativeMantissaAndNegativeIntegralExponent() throws Exception { EvaluatorWidget eval = new EvaluatorWidget(widgetRoot, "${=%.2f: (-10.0)^(-2) =}"); assertEquals("0.01", eval.render()); }
int getReplica(int vbucketIndex, int replicaIndex); int foundIncorrectMaster(int vbucket, int wrongServer); ConfigDifference compareTo(Config config); List<String> getServers(); List<VBucket> getVbuckets(); ConfigType getConfigType(); }
public void initialize() {
long decr(String key, int by, long def) throws OperationTimeoutException; Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs);  Set<String> listSaslMechanisms(); }
public void shouldHandleNullTitle() throws Exception { finder = new SuiteSpecificationMatchFinder(null,"child",hits); finder.search(root); hits.assertPagesFound("TestPageOne","ChildPage"); }
public void testClientHostnameVerificationWithIPAddress() throws Exception { VerifiableHostnameVerifier hostnameVerifier = new VerifiableHostnameVerifier(); ZKTrustManager zkTrustManager = new ZKTrustManager(mockX509ExtendedTrustManager, true, true, hostnameVerifier); X509Certificate[] certificateChain = createSelfSignedCertificateChain(IP_ADDRESS, null); zkTrustManager.checkClientTrusted(certificateChain, null, mockSocket); verify(mockSocket, times(1)).getInetAddress(); assertEquals(Arrays.asList(IP_ADDRESS), hostnameVerifier.hosts); verify(mockX509ExtendedTrustManager, times(1)).checkClientTrusted(certificateChain, null, mockSocket); }
private void assertAddToRevisionControlButtonIsNotVisible(String pageName, String html) throws Exception { assertNotSubString(link("Add", pageName, "addToRevisionControl", "a"), html); }
private boolean genericThat(boolean assertion, Object category, String reason, Object... messageParameters) { if (!assertion) { errors.add(i18nMessage(category, reason, messageParameters)); } return assertion; }
public Response makeResponse(FitNesseContext context, Request request) { SimpleResponse response = new SimpleResponse(); String resource = request.getResource(); String version = (String) request.getInput("version"); if (version == null) return new ErrorResponder("missing version").makeResponse(context, request); WikiPagePath path = PathParser.parse(resource); WikiPage page = context.root.getPageCrawler().getPage(context.root, path); if (page == null) return new NotFoundResponder().makeResponse(context, request); PageData data = page.getDataVersion(version); page.commit(data); context.recentChanges.updateRecentChanges(data); response.redirect(resource); return response; }
public Long convert(String value, Class<? extends Long> type) { if (value == null) { return null; } try { return Long.valueOf(value);
private void finish(boolean failed) { agg.reportLatency(System.currentTimeMillis() - startTime); agg.tpAgg.ding(failed); agg.outstanding.release(); }
public void setUp() throws Exception { String hp = hostPort; hostPort = hostPort + "/chrootclienttest"; System.out.println(hostPort); super.setUp(); LOG.info("STARTING " + getTestName()); ZooKeeper zk = createClient(hp); try { zk.create("/chrootclienttest", null, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
public void anotherMethod(T entity, String param) { System.out.println("Do Another Thing"); }
public void manyInputsAndRows() throws Exception { makeTables( "!|scenario|login|user name|password|password|pin|pin|\n" + "|login|@userName|with password|@password|and pin|@pin|\n" + "\n" + "!|DT:LoginPasswordPin|\n" + "|user name|password|pin|\n" + "|bob|xyzzy|7734|\n" + "|bill|yabba|8892|\n" ); List<CallInstruction> expectedInstructions = list( new CallInstruction("decisionTable_did_0/scriptTable_s_id_0", "scriptTableActor", "loginWithPasswordAndPin", new Object[]{"bob", "xyzzy", "7734"}), new CallInstruction("decisionTable_did_1/scriptTable_s_id_0", "scriptTableActor", "loginWithPasswordAndPin", new Object[]{"bill", "yabba", "8892"}) ); assertEquals(expectedInstructions, instructions()); }
public int hashCode() { return getP().hashCode() ^ getQ().hashCode() ^ getG().hashCode(); }
public void tearDown() throws Exception { } public void testClearChildrenWhenVWisCleared() throws Exception { createSimpleVirtualLink();
private void includeSuiteTeardownPage() throws Exception { include(SuiteContentsFinder.SUITE_TEARDOWN_NAME, "-teardown"); }
void start() throws Exception;  @Override void close(); }
public void testShutdownCalledFromServer() throws Exception { Thread thread = new Thread(){ public void run() { try { RequestBuilder request = new RequestBuilder("/?responder=shutdown"); ResponseParser.performHttpRequest("localhost", FitNesseUtil.port, request); doneShuttingDown = true; } catch(Exception e) { e.printStackTrace(); } } }; thread.start(); Thread.sleep(500); assertTrue(doneShuttingDown); assertFalse(fitnesse.isRunning()); }
public Class<?> getTargetClass()
long decr(String key, long by, long def); long decr(String key, int by, long def); Future<Boolean> delete(String key); Future<Boolean> delete(String key, long cas); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs);  Set<String> listSaslMechanisms(); }
public List<String> listVariables(){ return new ArrayList<>(cache.keySet()); }
protected SlimTestSystem getTestSystem() throws IOException { SlimCommandRunningClient slimClient = new SlimClientBuilder(getDescriptor()) .withFastTest(fastTest) .build(); return new HtmlSlimTestSystem("slim", slimClient, this); }
@Test public void childPage() { assertChildPage("my child", "my child"); assertChildPage("<a href=\"../TestParent/TestSibling.html\">TestSibling</a>", "TestSibling"); assertChildPage("<a href=\"../TestParent.html\">link</a>", "!-<a href=\"/TestParent\">link</a>-!"); }
public final void deepRegister(Class<?> componentType) { deepRegister(componentType, componentType, new HashSet<Class<?>>()); }
public void shouldReturnParentOfChildOfJavaHomeFolder() throws Exception { String home = JavaLocator.findHomeFromToolchain(new TestStringReturningToolChain()); assertEquals("parent", home); }
public void dispose() { containerForCustomComponents.dispose(); containerForBundledComponents.dispose(); }
public RequestDispatcher create( AbstractResourceMethod abstractResourceMethod) { return null; }
public void testRemoteUrlNotFound() throws Exception { String remoteUrl = baseUrl + "PageDoesntExist"; Response response = makeSampleResponse(remoteUrl); MockResponseSender sender = new MockResponseSender(); sender.doSending(response); String content = sender.sentData(); assertSubString("The remote resource, " + remoteUrl + ", was not found.", content); }
public void shouldSortBasedOnPackageNamesLessPriorityToCaelumInitialList3rdPartyFirst() { List<Serialization> serializers = new ArrayList<Serialization>(); serializers.add(new DumbSerialization()); serializers.add(new XStreamXMLSerialization(null, null, null)); serializers.add(new XStreamJSONSerialization(null, null, null)); serializers.add(new HTMLSerialization(null, null)); serializers.add(new RestfulSerialization(null, null, null, null, null)); Collections.sort(serializers, new PackageComparator()); Assert.assertEquals("pacote.antes.da.caelum", serializers.get(0).getClass().getPackage().getName());
public DERObject toASN1Object() { ASN1EncodableVector v = new ASN1EncodableVector(); if (versionPresent || !version.equals(V1)) { v.add(new DERTaggedObject(true, 0, version)); } v.add(responderID); v.add(producedAt); v.add(responses); if (responseExtensions != null) { v.add(new DERTaggedObject(true, 1, responseExtensions)); } return new DERSequence(v); }
public Maybe<Symbol> parse(Symbol current, Parser parser) { SymbolType type = current.getType(); int offset = parser.getOffset(); String literal = parser.parseLiteral(closeType()); if (parser.atEnd()) return Symbol.nothing; return new Maybe<Symbol>(new Symbol(type, literal, offset)); }
public void timeOut();  public boolean isTimedOut();  public boolean isTimedOut(long ttlMillis);  public boolean isTimedOutUnsent(); }
public void exceptionOccurred(Throwable cause) { for (FitClientListener listener : listeners) try {
protected Follower makeFollower(FileTxnSnapLog logFactory) throws IOException { return new Follower(this, new FollowerZooKeeperServer(logFactory, this, this.zkDb)); }
public void execute() throws IOException, InterceptionException { interceptorStack.add(ResourceLookupInterceptor.class); interceptorStack.add(URLParameterExtractorInterceptor.class); interceptorStack.add(InterceptorListPriorToExecutionExtractor.class); interceptorStack.add(instantiator); interceptorStack.add(ParametersInstantiator.class); if(shouldRegisterHibernateValidator) { interceptorStack.add(HibernateValidatorPluginInterceptor.class); } interceptorStack.add(Validator.class); interceptorStack.add(ResultSupplierInterceptor.class); interceptorStack.add(ExecuteAndViewInterceptor.class); interceptorStack.add(OutjectionInterceptor.class); interceptorStack.add(ViewInterceptor.class); interceptorStack.next(null, null); }
public boolean grabAndCompareTablesFromHtml() { initializeComparerHelpers(); if (firstScanner.getTableCount() == 0 || secondScanner.getTableCount() == 0) return false; comparer = new TableListComparer(firstScanner, secondScanner); comparer.compareAllTables(); matchedTables = comparer.tableMatches; getTableTextFromScanners(); lineUpTheTables(); addBlanksToUnmatchingRows(); makePassFailResultsFromMatches(); return true; }
public DERObject toASN1Object() { ASN1EncodableVector v = new ASN1EncodableVector(); if (crlUrl != null) { v.add(new DERTaggedObject(true, 0, crlUrl)); } if (crlNum != null) { v.add(new DERTaggedObject(true, 1, crlNum)); } if (crlTime != null) { v.add(new DERTaggedObject(true, 2, crlTime)); } return new DERSequence(v); }
public String makeErrorMessage() { HtmlTag tag = HtmlUtil.makeDivTag("centered"); tag.add(message); return tag.html(); }
public void encode( DEROutputStream out) throws IOException { if (out instanceof ASN1OutputStream || out instanceof BEROutputStream) {
private HtmlTag makeLastModifiedTag() throws Exception { HtmlTag tag = HtmlUtil.makeDivTag("right"); String username = pageData.getAttribute(WikiPage.LAST_MODIFYING_USER); if(username == null || "".equals(username)) tag.use("Last modified anonymously"); else tag.use("Last modified by " + username); return tag; }
private String renderHierarchicalFiltersTOCWidget() throws Exception { WidgetRoot root = new WidgetRoot(parent2); root.addVariable(TOCWidget.FILTER_TOC, "true"); return new TOCWidget(root, "!contents -R -g -f\n").render(); }
public void checkSession(long sessionId, Object owner) throws KeeperException.SessionExpiredException, KeeperException.SessionMovedException, KeeperException.UnknownSessionException;  public void checkGlobalSession(long sessionId, Object owner) throws KeeperException.SessionExpiredException, KeeperException.SessionMovedException; void setOwner(long id, Object owner) throws SessionExpiredException;  void dumpSessions(PrintWriter pwriter);  Map<Long, Set<Long>> getSessionExpiryMap();  public long getLocalSessionCount(); }
<T> CASResponse cas(String key, long casId, T value, Transcoder<T> tc) throws OperationTimeoutException; CASResponse cas(String key, long casId, Object value) throws OperationTimeoutException; <T> Future<Boolean> add(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> add(String key, int exp, Object o); <T> Future<Boolean> set(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> set(String key, int exp, Object o); <T> Future<Boolean> replace(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> replace(String key, int exp, Object o); <T> Future<T> asyncGet(String key, Transcoder<T> tc); Future<Object> asyncGet(String key); <T> Future<CASValue<T>> asyncGets(String key, Transcoder<T> tc); Future<CASValue<Object>> asyncGets(String key); <T> CASValue<T> gets(String key, Transcoder<T> tc) throws OperationTimeoutException; CASValue<Object> gets(String key) throws OperationTimeoutException; <T> T get(String key, Transcoder<T> tc) throws OperationTimeoutException; Object get(String key) throws OperationTimeoutException; <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Iterator<Transcoder<T>> tcs); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); BulkFuture<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> BulkFuture<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); BulkFuture<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc) throws OperationTimeoutException; Map<String, Object> getBulk(Collection<String> keys) throws OperationTimeoutException; <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys) throws OperationTimeoutException; Map<String, Object> getBulk(String... keys) throws OperationTimeoutException; Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, int by) throws OperationTimeoutException; long decr(String key, int by) throws OperationTimeoutException; long incr(String key, int by, long def, int exp) throws OperationTimeoutException; long decr(String key, int by, long def, int exp) throws OperationTimeoutException; Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, int by); long incr(String key, int by, long def) throws OperationTimeoutException; long decr(String key, int by, long def) throws OperationTimeoutException; Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs);  Set<String> listSaslMechanisms(); }
private void assertConverts(Converter converter, String value) { assertConverts(value, converter, value); }
protected Map<Object, Object> cSort(List<?> list, int col) { TypeAdapter a = columnBindings[col].adapter; Map<Object, Object> result = new ConcurrentHashMap<Object, Object>(list.size()); for (Iterator<?> i = list.iterator(); i.hasNext();) { Object row = i.next(); try { a.target = row; Object key = a.get(); bin(result, key, row); } catch (Exception e) {
public void shouldUseAlias() { String expectedResult = "<customOrder>\n <price>15.0</price>\n <comments>pack it nicely, please</comments>\n</customOrder>"; Order order = new Order(new Client("guilherme silveira"), 15.0, "pack it nicely, please"); serializer.from(order, "customOrder").serialize(); assertThat(result(), is(equalTo(expectedResult))); }
private String remoteUrl() { String remotePathName = PathParser.render(remotePath); return "http://" + remoteHostname + ":" + remotePort + "/" + remotePathName; }
private static String joinPath(char sep, String ...paths) { final StringBuilder sb = new StringBuilder(); for (String p : paths) { if (p == null) continue; if (p.startsWith("/")) { sb.append(p); } else { sb.append(sep); sb.append(p); } } return sb.toString(); }
public void testResponseWithRedirect() throws Exception { WikiPageUtil.addPage(root, PathParser.parse("ChildPage")); prepareRequest("ChildPage"); request.addInput("redirect", "http://fitnesse.org:8080/SomePage"); Response response = responder.makeResponse(context, request); assertEquals(303, response.getStatus()); assertHasRegexp("Location: http://fitnesse.org:8080/SomePage", response.makeHttpHeaders()); }
public void setup() { converter = new BigDecimalConverter(); bundle = ResourceBundle.getBundle("messages"); }
public void newTestPage(String pageName) { initializeTest(new WikiTestPage(new WikiPageDummy(pageName, "", null))); }
protected boolean useDebugMode(Class<?> suiteClass) throws Exception { return true; }
public void shouldMakeErrorResponseWhenGetsInvalidNumberOfDays() throws Exception { request.addInput("days", "-42"); Response response = responder.makeResponse(context, request); assertEquals(400, response.getStatus()); }
protected void describeMismatchSafely(Route item, Description mismatchDescription) { mismatchDescription.appendValue(item); }
public void tearDown() throws Exception { } public void testSuccess() throws Exception { int ticket = dealer.seekingSocket(seeker); request.addInput("ticket", ticket + ""); Response response = responder.makeResponse(context, request); response.readyToSend(sender); assertEquals("", sender.sentData()); } public void testMissingSeeker() throws Exception { request.addInput("ticket", "123"); Response response = responder.makeResponse(context, request); response.readyToSend(sender); assertHasRegexp("There are no clients waiting for a socket with ticketNumber 123", sender.sentData()); assertTrue(sender.isClosed()); assertEquals(404, response.getStatus()); } }
public void decisionTableCanBeConstructorOnly() throws Exception { makeDecisionTableAndBuildInstructions("|fixture|argument|\n"); List<Instruction> expectedInstructions = asList( new MakeInstruction("decisionTable_id_0", "decisionTable_id", "fixture", new Object[]{"argument"}), new CallInstruction("decisionTable_id_1", "decisionTable_id", "table", new Object[]{asList()}) ); assertEquals(expectedInstructions, instructions); Map<String, Object> pseudoResults = SlimCommandRunningClient.resultToMap( asList( asList("decisionTable_id_0", "OK"), asList("decisionTable_id_1", "OK") ) ); SlimAssertion.evaluateExpectations(assertions, pseudoResults); String colorizedTable = decisionTable.getTable().toString(); String expectedColorizedTable = "[[pass(fixture), argument]]"; assertEquals(expectedColorizedTable, colorizedTable); }
public void shoudBeAbleToReturnContentIntoWriteAsString() throws IOException { response.getWriter().write("X"); response.getWriter().flush(); assertEquals("X", response.getContentAsString()); }
public int size();  public void shutdown();  public WatchesSummary getWatchesSummary();  public WatchesReport getWatches();  public WatchesPathReport getWatchesByPath();  public void dumpWatches(PrintWriter pwriter, boolean byPath); }
void unsubscribe(String bucketName, Reconfigurable rec); void shutdown(); String getAnonymousAuthBucket(); }
public void handleDecryptedResult(final String value) {
public void simpleNameWithUnnamedArgument() throws Exception { makeTables( "!|scenario|f|a||b|\n" + "|function|@a||@b|\n" + "\n" + "!|script|\n" + "|f|1||2|\n" ); List<CallInstruction> expectedInstructions = list( new CallInstruction("scriptTable_id_0/scriptTable_s_id_0", "scriptTableActor", "function", new Object[]{"1", "2"}) ); assertEquals(expectedInstructions, instructions); }
public void addOption(String key, File value) { if ((value == null) || StringUtils.isEmpty(key)) { return; } addArgs(key, value.getAbsolutePath()); }
public void testNoDuplicates() throws Exception { RecentChangesWikiPage.updateRecentChanges(page1.getData()); RecentChangesWikiPage.updateRecentChanges(page1.getData()); WikiPage recentChanges = rootPage.getChildPage("RecentChanges"); List<String> lines = RecentChangesWikiPage.getRecentChangesLines(recentChanges.getData()); assertEquals(1, lines.size()); assertHasRegexp("PageOne", lines.get(0)); }
void traverseUncles(String uncleName, TraversalListener<? super WikiPage> callback); WikiPage getSiblingPage(WikiPagePath pathRelativeToSibling); WikiPage findAncestorWithName(String name); WikiPage getClosestInheritedPage(WikiPage context, String pageName); }
public long getPacketsReceived();  public long getPacketsSent();  public long getOutstandingRequests();  public int getTickTime();  public void setTickTime(int tickTime);  public int getMaxClientCnxnsPerHost();  public void setMaxClientCnxnsPerHost(int max);  public int getMinSessionTimeout();  public void setMinSessionTimeout(int min);  public int getMaxSessionTimeout();  public void setMaxSessionTimeout(int max);  public void resetStatistics();  public void resetLatency();  public void resetMaxLatency();  public long getNumAliveConnections();  public long getDataDirSize();  public long getLogDirSize();  public String getSecureClientPort();  public String getSecureClientAddress(); }
public int addRow(List<String> list) throws Exception { return 0; }
private void assertXmlDocumentHeaderIsCorrect() throws Exception { assertEquals("text/xml", response.getContentType()); testResultsDocument = getXmlDocumentFromResults(results); testResultsElement = testResultsDocument.getDocumentElement(); assertEquals("testResults", testResultsElement.getNodeName()); String version = XmlUtil.getTextValue(testResultsElement, "FitNesseVersion"); assertEquals(new FitNesseVersion().toString(), version); }
public boolean equals(Object o) { if (this == o) return true; if (!(o instanceof GetChildren)) return false; GetChildren op = (GetChildren) o; return getType() == op.getType() && getPath().equals(op.getPath()); }
public void notAnnotated() { } @Path("/myPath") public void customizedPath() { } } @Test public void canTranslateADefaultResource() throws NoSuchMethodException { DefaultMethodLookupBuilder builder = new DefaultMethodLookupBuilder(); String url = builder.urlFor(MyResource.class, mockery.methodFor(MyResource.class, "notAnnotated").getMethod(), new Object[] {}); assertThat(url, is(equalTo("/MyResource/notAnnotated"))); } }
public State getState(String state); public void prune(FileSystemPage page) throws Exception; public State execute(RevisionControlOperation operation, String... filePaths) throws RevisionControlException; public boolean isExternalReversionControlEnabled(); }
private void makePropertiesForm() { makePageTypeRadiosHtml(pageData); makeTestActionCheckboxesHtml(pageData); makeNavigationCheckboxesHtml(pageData); makeSecurityCheckboxesHtml(pageData); makeVirtualWikiHtml(); }
public void checkWithFunction() throws Exception { buildInstructionsFor("|check|function|arg|result|\n"); List<CallInstruction> expectedInstructions = list( new CallInstruction("scriptTable_id_0", "scriptTableActor", "function", new Object[]{"arg"}) ); assertEquals(expectedInstructions, instructions); }
ConcatenationType getStoreType();  long getCasValue();  byte[] getData(); }
public void testStarted(final TestPage testPage) throws IOException { invokeListeners(new Handler() { @Override public void invoke(TestSystemListener listener) throws IOException {
private HtmlPage createResultsPage(FitNesseContext context, Request request) throws Exception { HtmlPage resultsPage = context.htmlPageFactory.newPage(); resultsPage.title.use("Search Page Properties: " + request); resultsPage.header.use(HtmlUtil.makeBreadCrumbsWithPageType(request.getResource(), "Search Page Properties Results")); return resultsPage; }
public void functionCallWithSequentialArgumentProcessingEmbedded() throws Exception { buildInstructionsFor("|set name|Marisa|department and title;|QA|Tester|\n"); List<CallInstruction> expectedInstructions = list( new CallInstruction("scriptTable_id_0", "scriptTableActor", "setNameDepartmentAndTitle", new Object[]{"Marisa", "QA", "Tester"}) ); assertEquals(expectedInstructions, instructions()); }
public static void assertParses(String input, String expected) { WikiPage page = new TestRoot().makePage("TestPage", input); Symbol result = parse(page, input); assertEquals(expected, serialize(result)); }
private void close() throws IOException { if (!closed) { suiteFormatter.finishWritingOutput();
public void verifySetAndGet2() { try { int iterations = 50000;
public synchronized void sendRead(LedgerHandle lh, SubReadOp r, long entry) throws IOException, BKException { try{ if(!noreception){
long getElectionTimeTaken();  int getLastProposalSize();  int getMinProposalSize();  int getMaxProposalSize();  void resetProposalStatistics();  int getMaxConcurrentSnapSyncs();  void setMaxConcurrentSnapSyncs(int maxConcurrentSnapSyncs);  int getMaxConcurrentDiffSyncs();  void setMaxConcurrentDiffSyncs(int maxConcurrentDiffSyncs); }
int addRow(List<String> list) throws Exception; void appendCellToRow(int row, String contents) throws Exception; String getUnescapedCellContents(int col, int row); String getCellResult(int col,int row); void appendChildTable(int row, Table table); void setTestStatusOnRow(int row, ExecutionResult testStatus); void setName(String tableName); void setCell(int col, int row, Response response); void appendToCell(int col, int row, Response response); }
public void localizedShowWithFunctionCall() throws Exception { buildInstructionsFor("|localized show|function|arg|\n", true); List<CallInstruction> expectedInstructions = asList( new CallInstruction("localizedScriptTable_id_0", "localizedScriptTableActor", "function", new Object[]{"arg"}) ); assertEquals(expectedInstructions, instructions()); }
public void run(String[] argv) { args(argv); process(); exit(); }
protected FieldVisitor createRemappingFieldAdapter(final FieldVisitor fv) { return new RemappingFieldAdapter(fv, remapper); }
public void testColumnNumberShouldThrowsInvalidInputExceptionIfColumnNameIsNotFound() throws Exception { try {
public void testStandalone() throws Exception { ClientBase.setupTestEnv(); final int CLIENT_PORT = 3181; MainThread main = new MainThread(CLIENT_PORT); main.start(); Assert.assertTrue("waiting for server being up", ClientBase.waitForServerUp("127.0.0.1:" + CLIENT_PORT, CONNECTION_TIMEOUT)); ZooKeeper zk = new ZooKeeper("127.0.0.1:" + CLIENT_PORT, ClientBase.CONNECTION_TIMEOUT, this); zk.create("/foo", "foobar".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); Assert.assertEquals(new String(zk.getData("/foo", null, null)), "foobar"); zk.close(); main.shutdown(); main.join(); main.deleteDirs(); Assert.assertTrue("waiting for server down", ClientBase.waitForServerDown("127.0.0.1:" + CLIENT_PORT,
public void parsesNewLine() throws Exception { ParserTestHelper.assertParses("\n", "SymbolList[Newline]"); ParserTestHelper.assertParses("\r\n", "SymbolList[Newline]"); }
public void testLoadKeyStoreWithNullFilePath() throws Exception { new JKSFileLoader.Builder().setKeyStorePassword(x509TestContext.getKeyStorePassword()).build().loadKeyStore(); }
public void closeSession(long sessionId) throws KeeperException, InterruptedException { ZooLog.logTextTraceMessage("ZooKeeperServer --- Session to be closed: " + sessionId, ZooLog.SESSION_TRACE_MASK);
private Matcher<? super Object> is(Object object) { return Matchers.is(object); }
int getConnectionTokenFillCount(); void setConnectionTokenFillCount(int val); int getConnectionFreezeTime(); void setConnectionFreezeTime(int val); double getConnectionDropIncrease(); void setConnectionDropIncrease(double val); double getConnectionDropDecrease(); void setConnectionDropDecrease(double val); double getConnectionDecreaseRatio(); void setConnectionDecreaseRatio(double val); int getCommitProcMaxReadBatchSize(); void setCommitProcMaxReadBatchSize(int size); int getCommitProcMaxCommitBatchSize(); void setCommitProcMaxCommitBatchSize(int size); int getRequestThrottleLimit(); void setRequestThrottleLimit(int requests); int getRequestThrottleStallTime(); void setRequestThrottleStallTime(int time); boolean getRequestThrottleDropStale(); void setRequestThrottleDropStale(boolean drop); boolean getRequestStaleLatencyCheck(); void setRequestStaleLatencyCheck(boolean check); boolean getRequestStaleConnectionCheck(); void setRequestStaleConnectionCheck(boolean check);  void resetStatistics();  void resetLatency();  void resetMaxLatency();  void resetFsyncThresholdExceedCount();  long getNumAliveConnections();  long getDataDirSize();  long getLogDirSize();  String getSecureClientPort();  String getSecureClientAddress();  long getTxnLogElapsedSyncTime();  int getJuteMaxBufferSize();  int getLastClientResponseSize();  int getMinClientResponseSize();  int getMaxClientResponseSize(); long getFlushDelay(); void setFlushDelay(long delay); long getMaxWriteQueuePollTime(); void setMaxWriteQueuePollTime(long delay); int getMaxBatchSize(); void setMaxBatchSize(int size); }
public static Counts readCounts(StreamReader reader) throws Exception { Counts counts = new Counts(); counts.right = readSize(reader); counts.wrong = readSize(reader); counts.ignores = readSize(reader); counts.exceptions = readSize(reader); return counts; }
TestPage getPageToTest(); void setCurrentScript(Class<? extends ScriptTable> scriptTableClass, String actorName); Class<? extends ScriptTable> getCurrentScriptClass(); String getCurrentScriptActor(); }
protected MultipleTestsRunner newMultipleTestsRunner(List<WikiPage> pages) { final String classPath = new ClassPathBuilder().buildClassPath(pages); PagesByTestSystem pagesByTestSystem = new PagesByTestSystem(pages, context.root, new PagesByTestSystem.DescriptorFactory() { @Override public Descriptor create(WikiPage page) { return new WikiPageDescriptor(page.readOnlyData(), debug, remoteDebug, classPath); } }); MultipleTestsRunner runner = new MultipleTestsRunner(pagesByTestSystem, context.runningTestingTracker, context.testSystemFactory); addFormatters(runner); return runner; }
private void sendPrimePacket() throws IOException {
private String virtualChildrenHtml() { return "<div class=\"toc1\">" + endl + "\t<ul>" + endl +
public void checkWithFunctionAndTrailingName() throws Exception { buildInstructionsFor("|check|function|arg|trail|result|\n"); List<CallInstruction> expectedInstructions = list( new CallInstruction("scriptTable_id_0", "scriptTableActor", "functionTrail", new Object[]{"arg"}) ); assertEquals(expectedInstructions, instructions); }
public void helperWillFailTestsIfNoTestsAreExecuted() throws Exception{ try{ helper.assertSuitePasses("FitNesse.SuiteAcceptanceTests.SuiteSlimTests", "nonExistingFilter"); } catch (AssertionError ae){ assertTrue(ae.getMessage().startsWith("at least one test")); } assertEquals(new HashSet<String>(), new HashSet<>(visitedPages));
public void testCommentTableAsHtml() throws Exception { StandardTableWidget table = new StandardTableWidget(new MockWidgetRoot(), "-|a|\n|b|c|\n"); String expected = "<table border=\"1\" cellspacing=\"0\">\n<tr class=\"hidden\"><td colspan=\"2\">a</td>" + HtmlElement.endl + "</tr>\n<tr><td>b</td>" + HtmlElement.endl + "<td>c</td>" + HtmlElement.endl + "</tr>\n</table>\n"; assertEquals(expected, table.render()); }
public WikiPage makeRootPage(String rootPath, String rootPageName) { return new FileSystemPage(rootPath, rootPageName, this, fileSystem, versionsController); }
public void assertParses(String input, String expected) { Symbol result = parse(input); assertEquals(expected, ParserTestHelper.serialize(result)); }
public void throwMethodNotCalledErrorIfNoSuchMethod() throws Exception { super.throwMethodNotCalledErrorIfNoSuchMethod(); validateNoMethodIntercepted(); }
public org.vafer.jdeb.mapping.Mapper createMapper() { if ("prefix".equalsIgnoreCase(mtype)) { return new PrefixMapper(strip, prefix); } if ("ls".equalsIgnoreCase(mtype)) { try { return new LsMapper(new FileInputStream(src)); } catch (Exception e) { e.printStackTrace(); } } return new NullMapper(); }
public void testGetPageHieratchyAsXmlDoesntContainSymbolicLinks() throws Exception { WikiPage pageOne = crawler.addPage(root, PathParser.parse("PageOne")); crawler.addPage(root, PathParser.parse("PageOne.ChildOne")); crawler.addPage(root, PathParser.parse("PageTwo")); PageData data = pageOne.getData(); WikiPageProperties properties = data.getProperties(); WikiPageProperty symLinks = properties.set(SymbolicPage.PROPERTY_NAME); symLinks.set("SymPage", "PageTwo"); pageOne.commit(data); request.setResource("root"); request.addInput("type", "pages"); Responder responder = new SerializedPageResponder(); SimpleResponse response = (SimpleResponse) responder.makeResponse(new FitNesseContext(root), request); String xml = response.getContent(); assertEquals("text/xml", response.getContentType()); assertSubString("<name>PageOne</name>", xml); assertSubString("<name>PageTwo</name>", xml); assertSubString("<name>ChildOne</name>", xml); assertNotSubString("SymPage", xml); }
public static boolean waitForServerUp(String hp, long timeout) { long start = System.currentTimeMillis(); while (true) { try {
public Maybe<String> render(Scanner scanner) { String body = new Translator(getPage()).translateIgnoreFirst(scanner, TokenType.CloseEvaluator); if (scanner.isEnd()) return Maybe.noString; try { Double result = new Expression(body).evaluate();
public List<Instruction> call(Map<String, String> scenarioArguments, SlimTable parentTable, int row) throws SyntaxError { String script = getTable().toHtml(); script = replaceArgsInScriptTable(script, scenarioArguments); return insertAndProcessScript(script, parentTable, row); }
public String toString() { return "Execution Status: " + style; }
public void deletePage(String pageName) { final PageCrawler pageCrawler = rootPage.getPageCrawler(); lastUsedPage = pageCrawler.getPage(PathParser.parse(pageName)); lastUsedPage.getParent().removeChildPage(lastUsedPage.getName()); }
public void shouldUseUnderlineFromCamelcaseTypename() { String expectedResult = "<camel_case_resource>\n</camel_case_resource>"; serializer.serialize(new CamelCaseResource()); assertThat(result(), is(equalTo(expectedResult))); mockery.assertIsSatisfied(); }
public boolean shouldBeApplied() throws IOException { if (super.shouldBeApplied()) return true;
Future<Boolean> append(long cas, String key, Object val); <T> Future<Boolean> append(long cas, String key, T val, Transcoder<T> tc); Future<Boolean> prepend(long cas, String key, Object val); <T> Future<Boolean> prepend(long cas, String key, T val, Transcoder<T> tc); <T> Future<CASResponse> asyncCAS(String key, long casId, T value, Transcoder<T> tc); Future<CASResponse> asyncCAS(String key, long casId, Object value); <T> CASResponse cas(String key, long casId, T value, Transcoder<T> tc) throws OperationTimeoutException; CASResponse cas(String key, long casId, Object value) throws OperationTimeoutException; <T> Future<Boolean> add(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> add(String key, int exp, Object o); <T> Future<Boolean> set(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> set(String key, int exp, Object o); <T> Future<Boolean> replace(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> replace(String key, int exp, Object o); <T> Future<T> asyncGet(String key, Transcoder<T> tc); Future<Object> asyncGet(String key); <T> Future<CASValue<T>> asyncGets(String key, Transcoder<T> tc); Future<CASValue<Object>> asyncGets(String key); <T> CASValue<T> gets(String key, Transcoder<T> tc) throws OperationTimeoutException; CASValue<Object> gets(String key) throws OperationTimeoutException; <T> T get(String key, Transcoder<T> tc) throws OperationTimeoutException; Object get(String key) throws OperationTimeoutException; <T> Future<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); Future<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> Future<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); Future<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc) throws OperationTimeoutException; Map<String, Object> getBulk(Collection<String> keys) throws OperationTimeoutException; <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys) throws OperationTimeoutException; Map<String, Object> getBulk(String... keys) throws OperationTimeoutException; Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, int by) throws OperationTimeoutException; long decr(String key, int by) throws OperationTimeoutException; long incr(String key, int by, long def, int exp) throws OperationTimeoutException; long decr(String key, int by, long def, int exp) throws OperationTimeoutException; Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, int by); long incr(String key, int by, long def) throws OperationTimeoutException; long decr(String key, int by, long def) throws OperationTimeoutException; Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs);  void authenticate(String mechs[], CallbackHandler cbh) throws OperationException;  Set<String> listSaslMechanisms(); }
String getUnescapedCellContents(int col, int row); int getRowCount(); int getColumnCountInRow(int row); void substitute(int col, int row, String content); int addRow(List<String> list); void addColumnToRow(int row, String content); void appendChildTable(int row, Table table); void updateContent(int row, TestResult testResult); void updateContent(int col, int row, TestResult testResult); void updateContent(int col, int row, ExceptionResult exceptionResult); public Table asTemplate(CellContentSubstitution substitution) throws SyntaxError;
public FitClient build() { String testRunner = descriptor.getTestRunner(); String classPath = descriptor.getClassPath(); String command = buildCommand(descriptor.getCommandPattern(), testRunner, classPath); Map<String, String> environmentVariables = descriptor.createClasspathEnvironment(classPath); int ticketNumber = socketDealer.seekingSocket(this); String hostName = getLocalhostName(); CommandRunningFitClient.CommandRunningStrategy runningStrategy = new CommandRunningFitClient.OutOfProcessCommandRunner(command, environmentVariables, hostName, port, ticketNumber); return buildFitClient(runningStrategy); }
public void setup() { this.mockery = new Mockery(); count = 0; }
public void defaultView() { } public void include() { } public void redirectTo(String url) { } public <T> T of(Class<T> controllerType) { return proxifier.proxify(controllerType, new MethodInvocation<T>() { public Object intercept(T proxy, Method method, Object[] args, SuperMethod superMethod) { return null; } }); } public void redirect(String url) { this.redirectTo(url); } public void forward(String url) { this.forwardTo(url); } public void forward() { this.defaultView(); } }
public void processTestResults(final String relativeTestName, TestSummary testSummary) throws Exception { Element resultElement = testResultsDocument.createElement("result"); testResultsElement.appendChild(resultElement); addCountsToResult(testSummary, resultElement); XmlUtil.addCdataNode(testResultsDocument, resultElement, "content", outputBuffer.toString()); outputBuffer = null; XmlUtil.addTextNode(testResultsDocument, resultElement, "relativePageName", relativeTestName); }
private static boolean deleteSemaphore(String name) { boolean isOk = (new File(makeSemaphoreName(name))).delete(); if (!isOk) System.out.print("Unable to remove semaphore '" + name + "'"); return isOk; }
String getSymbol(String symbolName); void setSymbol(String symbolName, String value); void addScenario(String scenarioName, ScenarioTable scenarioTable); ScenarioTable getScenario(String scenarioName); ScenarioTable getScenarioByPatternMatching(String invokingString, CustomComparatorRegistry customComparatorRegistry); Collection<ScenarioTable> getScenarios(); void incrementPassedTestsCount(); void incrementFailedTestsCount(); void incrementErroredTestsCount(); void incrementIgnoredTestsCount(); void increment(ExecutionResult testSummary); void increment(TestSummary testSummary); TestPage getPageToTest(); }
public void canProvideAllApplicationScopedComponents() { Class<?>[] components = new Class[]{UrlToResourceTranslator.class, ResourceRegistry.class, TypeCreator.class, InterceptorRegistry.class, PathResolver.class, ParameterNameProvider.class, Converters.class}; checkAvailabilityFor(true, components); mockery.assertIsSatisfied(); }
public void setUp() throws Exception { request = new MockRequest(); context = FitNesseUtil.makeTestContext(); }
public void testLeaderElectionWithDisloyalVoter_stillHasMajority() throws IOException { testLeaderElection(5, 5, 3000, 20000); }
protected boolean pageMatches(WikiPage page) throws Exception { String content = page.getData().getContent().toLowerCase(); boolean matches = content.indexOf(searchString) != -1; return matches; }
public void canShowTags() throws Exception { WikiPage frontPage = createTestPageTree(); request.setResource(frontPageName); request.addInput("Recursive", ""); request.addInput("ShowTags", ""); SimpleResponse response = (SimpleResponse) responder.makeResponse(FitNesseUtil.makeTestContext(root), request);
public final void fillWriteBuffer(boolean shouldOptimize) { if(toWrite == 0 && readQ.remainingCapacity() > 0) { getWbuf().clear();
public PwEntry clone(boolean deepStrings) { return (PwEntry) clone(); }
private void validateCreateRequest(String path, CreateMode createMode, Request request, long ttl) throws KeeperException { if (createMode.isTTL() && !EphemeralType.extendedEphemeralTypesEnabled()) { throw new KeeperException.UnimplementedException(); } try { EphemeralType.validateTTL(createMode, ttl); } catch (IllegalArgumentException e) { throw new BadArgumentsException(path); } if (createMode.isEphemeral()) {
public void noId(@Load NoIdEntity entity) { } public void methodOtherIdName(@Load EntityOtherIdName entity) { } } private Stubber fail() { return doThrow(new AssertionError()); } }
public void shouldRegisterComponentsAnnotatedWithAnyStereotypedAnnotations() { mockery.checking(new Expectations() { { one(scanner).getTypesWithMetaAnnotation(Stereotype.class); will(returnValue(Arrays.asList(ComponentAnnotated.class, ResourceAnnotated.class))); one(registry).register(ComponentAnnotated.class, ComponentAnnotated.class); one(registry).register(ResourceAnnotated.class, ResourceAnnotated.class); } }); registrar.registerFrom(scanner); mockery.assertIsSatisfied(); }
public void testIsBound() { serverSideSocket.isBound(); assertFalse(serverSideSocket.isModeKnown()); }
public void testComplete(WikiTestPage test, TestSummary testSummary, TimeMeasurement timeMeasurement) { } }
public void shouldBeAbleToDeserializeADogWhenAliasConfiguredByAnnotations() { InputStream stream = new ByteArrayInputStream("<dogAnnotated><nameAnnotated>Lubi</nameAnnotated><ageAnnotated>8</ageAnnotated></dogAnnotated>".getBytes()); when(provider.parameterNamesFor(annotated.getMethod())).thenReturn(new String[] {"dog"}); Object[] deserialized = deserializer.deserialize(stream, annotated); assertThat(deserialized.length, is(1)); assertThat(deserialized[0], is(instanceOf(DogWithAnnotations.class))); DogWithAnnotations dog = (DogWithAnnotations) deserialized[0]; assertThat(dog.name, is("Lubi")); assertThat(dog.age, is(8)); }
public void testFlagConversion() throws KeeperException {
public void testReadWriteShortZero() { testReadWriteShort((byte) 0); }
public void testBadMoveLocationName() throws Exception { assertTrue(crawler.pageExists(root, PathParser.parse("PageOne.PageA"))); SimpleResponse response = (SimpleResponse) movePage("PageOne.PageA", "NoSuchPage"); assertSubString("Cannot move", response.getContent()); assertTrue(crawler.pageExists(root, PathParser.parse("PageOne.PageA"))); }
protected Instruction assign(String symbolName, String value) { return new AssignInstruction(makeInstructionTag(), symbolName, value); }
public void rename(File file, File originalFile) throws IOException { persistence.rename(file, originalFile); }
public void commentColumn() throws Exception {
<T> Future<T> asyncGet(String key, Transcoder<T> tc); Future<Object> asyncGet(String key); <T> Future<CASValue<T>> asyncGets(String key, Transcoder<T> tc); Future<CASValue<Object>> asyncGets(String key); <T> CASValue<T> gets(String key, Transcoder<T> tc) throws OperationTimeoutException; CASValue<Object> gets(String key) throws OperationTimeoutException; <T> T get(String key, Transcoder<T> tc) throws OperationTimeoutException; Object get(String key) throws OperationTimeoutException; <T> Future<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); Future<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> Future<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); Future<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc) throws OperationTimeoutException; Map<String, Object> getBulk(Collection<String> keys) throws OperationTimeoutException; <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys) throws OperationTimeoutException; Map<String, Object> getBulk(String... keys) throws OperationTimeoutException; Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, int by) throws OperationTimeoutException; long decr(String key, int by) throws OperationTimeoutException; long incr(String key, int by, long def, int exp) throws OperationTimeoutException; long decr(String key, int by, long def, int exp) throws OperationTimeoutException; Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, int by); long incr(String key, int by, long def) throws OperationTimeoutException; long decr(String key, int by, long def) throws OperationTimeoutException; Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); }
public String asWikiText() throws Exception { return "!-" + parent.getLiteral(literalNumber) + "-!"; }
public RequestDispatcher create( AbstractResourceMethod abstractResourceMethod) { System.out.println("muhaha"); return null; }
private boolean contains(SymbolType[] terminators, SymbolType currentType) { for (SymbolType terminator: terminators) if (currentType == terminator) return true; return false; }
public String getSlimMessage() throws IOException { int resultLength = getLengthToRead(); return read(resultLength); }
public void canProvideAllRequestScopedComponents() { checkAvailabilityFor(false, HttpServletRequest.class, HttpServletResponse.class, VRaptorRequest.class, HttpSession.class, ParametersInstantiatorInterceptor.class, MethodParameters.class, RequestParameters.class, InterceptorListPriorToExecutionExtractor.class, URLParameterExtractorInterceptor.class, InterceptorStack.class, RequestExecution.class, ResourceLookupInterceptor.class, InstantiateInterceptor.class, Result.class, ExecuteMethodInterceptor.class, PageResult.class, ParametersProvider.class, RequestInfo.class, Validator.class, PathResolver.class); mockery.assertIsSatisfied(); }
protected void handleException(String threadName, Throwable e) { LOG.error("Severe unrecoverable error, from thread : {}", threadName, e); listener.notifyStopping(threadName, ExitCode.UNEXPECTED_ERROR.getValue()); ServerMetrics.UNRECOVERABLE_ERROR_COUNT.add(1); }
public void verifySetDataFailure_NoNode() { rc = KeeperException.Code.NONODE; stat = null; zk.setData(path, data, version, this, toString()); verify(); }
private void assertPageTypesMatch(PageType... pageTypes) { MockRequest request = new MockRequest(); List<PageType> types = Arrays.asList(pageTypes); final String commaSeparatedPageTypes = buildPageTypeListForRequest(pageTypes); request.addInput(PAGE_TYPE, commaSeparatedPageTypes); assertEquals(types, responder.getPageTypesFromInput(request)); }
public HierarchicalStreamWriter createWriter(Writer writer) { return new JsonWriter(writer, new char[0], "", JsonWriter.DROP_ROOT_MODE) { @Override
void startTestSystem(WikiPage page, String classPath, String className) throws Exception { String testSystemName = TestSystemBase.getTestSystemName(page.getData()); if (!testSystems.containsKey(testSystemName)) startTestSystem(classPath, className, testSystemName);
public void tearDown() throws Exception { if (null != im) { im.close();
public void testNegativeExponent() throws Exception { EvaluatorWidget eval = new EvaluatorWidget(widgetRoot, "${=%.2f: 10.0^-1 =}"); assertEquals("0.10", eval.render()); }
private void assertPrincipalLoggedIn() { assertEquals(PRINCIPAL, login.getUserName()); assertNotNull(login.getSubject()); assertEquals(1, login.getSubject().getPrincipals().size()); Principal actualPrincipal = login.getSubject().getPrincipals().iterator().next(); assertEquals(PRINCIPAL, actualPrincipal.getName()); }
public void testClasspathWithVariableDefinedInIncludedPage() throws Exception { WikiPage root = InMemoryPage.makeRoot("RooT"); crawler.addPage(root, PathParser.parse("VariablePage"), "!define PATH {/my/path}\n"); WikiPage page = crawler.addPage(root, PathParser.parse("ClassPath"), "!include VariablePage\n!path ${PATH}.jar"); List<?> paths = page.getData().getClasspaths(); assertEquals("/my/path.jar", paths.get(0).toString()); }
public HtmlTag makeAttributeSelectionHtml(String propertyType, String[] attributes, String[] selection) throws Exception { HtmlTag div = new HtmlTag("div"); div.addAttribute("style", "float: left; width: 150px;"); HtmlTag table = generateTable(propertyType); makeAttributeSelectionHtml(table, propertyType, attributes, Arrays .asList(selection)); div.add(table); return div; }
public <T extends View> T instanceFor(final Class<T> view, final List<Message> errors) { if (view.equals(EmptyResult.class)) { throw new ValidationException(errors); } return proxifier.proxify(view, throwValidationErrorOnFinalMethods(view, errors, result.use(view)));
private String makeClassPathFromSimpleStructure(String path) throws Exception { PageData data = root.getData(); data.setContent("!path " + path); root.commit(data); PageCrawler crawler = root.getPageCrawler(); WikiPage page = crawler.getPage(somePagePath, new MockingPageCrawler()); List<String> classPath = builder.getClassPath(page); return StringUtils.join(classPath, System.getProperty("path.separator")); }
private void open() throws FileNotFoundException { if (!opened) { outputStream = new FileOutputStream(tempFile, true);
public long getPacketsReceived();  public long getPacketsSent();  public long getFsyncThresholdExceedCount();  public long getOutstandingRequests();  public int getTickTime();  public void setTickTime(int tickTime);  public int getMaxClientCnxnsPerHost();  public void setMaxClientCnxnsPerHost(int max);  public int getMinSessionTimeout();  public void setMinSessionTimeout(int min);  public int getMaxSessionTimeout();  public void setMaxSessionTimeout(int max); public boolean getResponseCachingEnabled(); public void setResponseCachingEnabled(boolean isEnabled);  public void resetStatistics();  public void resetLatency();  public void resetMaxLatency();  public void resetFsyncThresholdExceedCount();  public long getNumAliveConnections();  public long getDataDirSize();  public long getLogDirSize();  public String getSecureClientPort();  public String getSecureClientAddress();  public long getTxnLogElapsedSyncTime();  public int getJuteMaxBufferSize();  public int getLastClientResponseSize();  public int getMinClientResponseSize();  public int getMaxClientResponseSize(); }
public void createSlimClientWithFixtureInteraction() { Descriptor descriptor = mock(Descriptor.class); when(descriptor.getVariable("slim.flags")).thenReturn("-i " + InteractionDemo.class.getName()); FixtureInteraction interaction = captureInteraction(descriptor); assertNotNull(interaction); assertNotEquals(DefaultInteraction.class, interaction.getClass()); assertTrue(interaction instanceof InteractionDemo); }
boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs);  Set<String> listSaslMechanisms(); }
public void writeString(String s, String tag) throws IOException; public void writeBuffer(byte buf[], String tag) throws IOException; public void writeRecord(Record r, String tag) throws IOException; public void startRecord(Record r, String tag) throws IOException; public void endRecord(Record r, String tag) throws IOException; public void startVector(List<?> v, String tag) throws IOException; public void endVector(List<?> v, String tag) throws IOException; public void startMap(TreeMap<?,?> v, String tag) throws IOException; public void endMap(TreeMap<?,?> v, String tag) throws IOException; }
public LocalDate convert(String value, Class<? extends LocalDate> type, ResourceBundle bundle) { Calendar calendar = delegate.convert(value, Calendar.class, bundle); if (calendar == null) { return null; } try { return LocalDate.fromCalendarFields(calendar);
protected void constructFixture() { String tableHeader = table.getCellContents(0, 0); String fixtureName = tableHeader.split(":")[1]; String disgracedFixtureName = Disgracer.disgraceClassName(fixtureName); constructInstance(getTableName(), disgracedFixtureName, 0, 0); }
public void intercept(InterceptorStack stack, ResourceMethod method, Object resourceInstance) throws IOException, InterceptionException { } public boolean accepts(ResourceMethod method) { return true; } } public static class Dependency { } @Test(expected = InterceptionException.class) public void shouldComplainWhenUnableToInstantiateAnInterceptor() throws InterceptionException, IOException { Container container = mockery.container(MyWeirdInterceptor.class, null); ToInstantiateInterceptorHandler handler = new ToInstantiateInterceptorHandler(container, MyWeirdInterceptor.class); handler.execute(null, null, null); } @Test public void shouldInvokeInterceptorsMethodIfAbleToInstantiateIt() throws InterceptionException, IOException { final Interceptor interceptor = mockery.mock(Interceptor.class); final InterceptorStack stack = mockery.mock(InterceptorStack.class); final ResourceMethod method = mockery.mock(ResourceMethod.class); final Object instance = new Object(); Container container = mockery.container(Interceptor.class, interceptor); mockery.checking(new Expectations() { { one(interceptor).intercept(stack, method, instance); } }); ToInstantiateInterceptorHandler handler = new ToInstantiateInterceptorHandler(container, Interceptor.class); handler.execute(stack, method, instance); } }
Transcoder<Object> getTranscoder(); NodeLocator getNodeLocator(); Future<Boolean> append(long cas, String key, Object val); <T> Future<Boolean> append(long cas, String key, T val, Transcoder<T> tc); Future<Boolean> prepend(long cas, String key, Object val); <T> Future<Boolean> prepend(long cas, String key, T val, Transcoder<T> tc); <T> Future<CASResponse> asyncCAS(String key, long casId, T value, Transcoder<T> tc); Future<CASResponse> asyncCAS(String key, long casId, Object value); <T> CASResponse cas(String key, long casId, int exp, T value, Transcoder<T> tc); CASResponse cas(String key, long casId, Object value); <T> Future<Boolean> add(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> add(String key, int exp, Object o); <T> Future<Boolean> set(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> set(String key, int exp, Object o); <T> Future<Boolean> replace(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> replace(String key, int exp, Object o); <T> Future<T> asyncGet(String key, Transcoder<T> tc); Future<Object> asyncGet(String key); Future<CASValue<Object>> asyncGetAndTouch(final String key, final int exp); <T> Future<CASValue<T>> asyncGetAndTouch(final String key, final int exp, final Transcoder<T> tc); CASValue<Object> getAndTouch(String key, int exp); <T> CASValue<T> getAndTouch(String key, int exp, Transcoder<T> tc); <T> Future<CASValue<T>> asyncGets(String key, Transcoder<T> tc); Future<CASValue<Object>> asyncGets(String key); <T> CASValue<T> gets(String key, Transcoder<T> tc); CASValue<Object> gets(String key); <T> T get(String key, Transcoder<T> tc); Object get(String key); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Iterator<Transcoder<T>> tcs); <T> BulkFuture<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); BulkFuture<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> BulkFuture<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); BulkFuture<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc); Map<String, Object> getBulk(Collection<String> keys); <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys); Map<String, Object> getBulk(String... keys); <T> Future<Boolean> touch(final String key, final int exp, final Transcoder<T> tc); <T> Future<Boolean> touch(final String key, final int exp); Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, long by); long incr(String key, int by); long decr(String key, long by); long decr(String key, int by); long incr(String key, long by, long def, int exp); long incr(String key, int by, long def, int exp); long decr(String key, long by, long def, int exp); long decr(String key, int by, long def, int exp); Future<Long> asyncIncr(String key, long by); Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, long by); Future<Long> asyncDecr(String key, int by); long incr(String key, long by, long def); long incr(String key, int by, long def); long decr(String key, long by, long def); long decr(String key, int by, long def); Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs);  Set<String> listSaslMechanisms(); }
public void operationFailed(Object ctx, final PubSubException exception) { new Thread(new Runnable() { @Override
public Container provide(VRaptorRequest request) { return new PicoBasedContainer(container, request); }
public void setMaxConcurrentDiffSyncs(int maxConcurrentDiffSyncs); }
Operation getCurrentWriteOp();  Operation removeCurrentWriteOp();  boolean hasReadOp();  boolean hasWriteOp();  void addOp(Operation op);  void insertOp(Operation o);  int getSelectionOps();  ByteBuffer getRbuf();  ByteBuffer getWbuf();  SocketAddress getSocketAddress();  boolean isActive();  boolean isAuthenticated();  long lastReadDelta();  void completedRead();  void reconnecting();  void connected();  int getReconnectCount();  void registerChannel(SocketChannel ch, SelectionKey selectionKey);  void setChannel(SocketChannel to);  SocketChannel getChannel();  void setSk(SelectionKey to);  SelectionKey getSk();  int getBytesRemainingToWrite();  int writeSome() throws IOException;  void fixupOps();  void authComplete();  void setupForAuth();  void setContinuousTimeout(boolean timedOut); int getContinuousTimeout(); }
public static String write(SourcePage page) { String user = page.getProperty(WikiPageProperty.LAST_MODIFYING_USER); String date = page.getProperty(WikiPageProperty.LAST_MODIFIED); return HtmlTag.name("span").attribute("class", "meta").body( "Last modified " +
public int getMaxClientCnxnsPerHost();  public void setMaxClientCnxnsPerHost(int max);  public int getMinSessionTimeout();  public void setMinSessionTimeout(int min);  public int getMaxSessionTimeout();  public void setMaxSessionTimeout(int max);  public void resetStatistics();  public void resetLatency();  public void resetMaxLatency();  public void resetFsyncThresholdExceedCount();  public long getNumAliveConnections();  public long getDataDirSize();  public long getLogDirSize();  public String getSecureClientPort();  public String getSecureClientAddress();  public long getTxnLogElapsedSyncTime();  public int getJuteMaxBufferSize();  public int getLastClientResponseSize();  public int getMinClientResponseSize();  public int getMaxClientResponseSize(); }
final public void enable_tracing() { } final public void disable_tracing() { } }
public void onCreateMenu(ContextMenu menu, ContextMenuInfo menuInfo) { menu.add(0, MENU_OPEN, 0, R.string.menu_open); if (!readOnly) { menu.add(0, MENU_DELETE, 0, R.string.menu_delete);
public static boolean isInFilesFitNesseDirectory(File rootPath, File file) throws IOException { return isInSubDirectory(new File(new File(rootPath, PathParser.FILES), "fitnesse").getCanonicalFile(), file.getCanonicalFile());
@Test public void translatesTables() { ParserTest.assertTranslatesTo("|a|\n", tableWithCell("a")); ParserTest.assertTranslatesTo("|a|", tableWithCell("a")); ParserTest.assertTranslatesTo("||\n", tableWithCell("")); ParserTest.assertTranslatesTo("| a |\n", tableWithCell("a")); ParserTest.assertTranslatesTo("|''a''|\n", tableWithCell("<i>a</i>")); ParserTest.assertTranslatesTo("|!c a|\n", tableWithCell("<div class=\"centered\">a</div>")); ParserTest.assertTranslatesTo("|!c !1 a|\n", tableWithCell("<div class=\"centered\"><h1>a</h1>" + HtmlElement.endl + "</div>")); ParserTest.assertTranslatesTo("|a|b|c|\n|d|e|f|\n", "<table border=\"1\" cellspacing=\"0\">" + HtmlElement.endl +
public void close() throws IOException { if (currentWriter != null) { currentWriter.write("</article></body></html>");
public void testUpdateServerList_ResolvedWithUnResolvedAddress_ForceDisconnect() {
private void addPageToListWithinMap(Map<WikiPageDescriptor, LinkedList<WikiTestPage>> pagesByTestSystem, WikiPage wikiPage) { WikiTestPage testPage = new WikiTestPage(wikiPage); WikiPageDescriptor descriptor = new WikiPageDescriptor(wikiPage.readOnlyData(), inProcess, remoteDebug, classPath); getOrMakeListWithinMap(pagesByTestSystem, descriptor).add(testPage); }
public void shouldBeAbleToConvertEmpty() { assertThat(converter.convert("", DateMidnight.class, bundle), is(nullValue())); }
public void evaluateExpectation(Map<String, Object> returnValues) { if (doTableId == null || returnValues.get(doTableId) == null) { table.appendToCell(0, 0, error("Table fixture has no valid doTable method")); return; } Object tableReturn = returnValues.get(doTableId); if (tableReturn instanceof String) { String value = (String) tableReturn; if (isTestCaseErrorMessage(value)) { table.appendToCell(0, 0, error("Table fixture has no valid doTable method")); } else if (isExceptionFailureMessage(value)) { table.appendToCell(0, 0, error(value)); } return; } resizeTableAndEvaluateRows(tableReturn); }
public void processResult(int rc, String path, Object ctx, Stat stat) { cn.countDown(); }
private MultipleTestsRunner createTestRunner(List<WikiPage> pages) { final PagesByTestSystem pagesByTestSystem = new PagesByTestSystem(pages, context.getRootPage()); MultipleTestsRunner runner = new MultipleTestsRunner(pagesByTestSystem, context.testSystemFactory); runner.setRunInProcess(debugMode); return runner; }
public static void cancel(Context ctx) { AlarmManager am = (AlarmManager) ctx.getSystemService(Context.ALARM_SERVICE); Log.d(TAG, "Timeout cancel"); am.cancel(buildIntent(ctx)); }
public String toString() { return "[first: " + first + ", second: " + second + ", matchScore: " + matchScore + "]"; }
public int getByteCount() throws Exception { close(); return buffer.getSize(); }
public void tearDown() throws Exception { zk.close(); super.tearDown(); LOG.info("Test clients shutting down"); }
static int createNodes(DataTree tree, String path, int depth, int childcount, byte[] data) throws KeeperException { path += "node" + depth; tree.createNode(path, data, null, -1, 1, 1); if (--depth == 0) { return 1; } path += "/"; int count = 1; for (int i = 0; i < childcount; i++) { count += createNodes(tree, path + i, depth, childcount, data); } return count; }
public boolean isReversionControlEnabled() { return true; }
public void translatesTestTablesIntoLiteralTables() throws Exception { DecisionTable dt = makeDecisionTableAndBuildInstructions("!" + simpleDecisionTable); int n=0; Map<String, Object> pseudoResults = SlimClient.resultToMap( list( list(id(n++), "OK"), list(id(n++), VoidConverter.VOID_TAG), list(id(n++), VoidConverter.VOID_TAG),
private MyNamedFixture createNamedFixture() { createFixtureInstance(MyNamedFixture.class); MyNamedFixture myInstance = (MyNamedFixture) statementExecutor.getInstance("myInstance"); assertFalse(myInstance.called); return myInstance; }
public void testCommand(String cmdName, Field... fields) throws IOException, InterruptedException { testCommand(cmdName, new HashMap<>(), null, new HashMap<>(), HttpServletResponse.SC_OK, fields); }
public void testCyclicSymbolicLinks() throws Exception { PageData data = pageOne.getData(); data.getProperties().set(SymbolicPage.PROPERTY_NAME).set("SymOne", pageTwoPath); pageOne.commit(data); data = pageTwo.getData(); data.getProperties().set(SymbolicPage.PROPERTY_NAME).set("SymTwo", pageOnePath); pageTwo.commit(data); PageCrawler pageCrawler = root.getPageCrawler(); WikiPage deepPage = pageCrawler.getPage(PathParser.parse(pageOnePath + ".SymOne.SymTwo.SymOne.SymTwo.SymOne")); List<?> children = deepPage.getChildren(); assertEquals(1, children.size()); deepPage = pageCrawler.getPage(PathParser.parse(pageTwoPath + ".SymTwo.SymOne.SymTwo.SymOne.SymTwo")); children = deepPage.getChildren(); assertEquals(1, children.size()); }
public ResourceMethod gimmeThis(String id, String methodName) { for (ResourceAndMethodLookup lookuper : lookup) { ResourceMethod method = lookuper.methodFor(id, methodName); if (method != null) { return method; } } return null; }
public static String defaultTestRunner() { return "fitnesse.slim.SlimService"; }
public BinaryPackageControlFile createPackageControlFile(File file, BigInteger pDataSize) throws IOException, ParseException { FilteredFile controlFile = new FilteredFile(new FileInputStream(file), resolver); BinaryPackageControlFile packageControlFile = new BinaryPackageControlFile(controlFile.toString()); if (packageControlFile.get("Distribution") == null) { packageControlFile.set("Distribution", "unknown"); } if (packageControlFile.get("Urgency") == null) { packageControlFile.set("Urgency", "low"); } packageControlFile.set("Installed-Size", pDataSize.divide(BigInteger.valueOf(1024)).toString());
public void gotData(String k, int flags, long cas, byte[] data) { assert key.equals(k) : "Wrong key returned"; assert cas > 0 : "CAS was less than zero: " + cas; val=new CASValue<T>(cas, tc.decode(new CachedData(flags, data)));
private void checkChildTwoRedirectToProperties(Response response) { assertEquals(303, response.getStatus()); assertEquals(response.getHeader("Location"), "/PageTwo.ChildTwo?properties"); }
public void buildTestSystemNameWhenTestSystemIsSlim() throws Exception { WikiPage testPage = WikiPageUtil.addPage(root, PathParser.parse("TestPage"), "!define TEST_SYSTEM {slim}\n"); String testSystemName = new WikiPageDescriptor(testPage.readOnlyData(), false, false, "").getTestSystemName(); Assert.assertEquals("slim:fitnesse.slim.SlimService", testSystemName); }
public void bye() throws Exception { System.out.println("..........sending bye()"); slimClient.sendBye(); System.out.println("..........bye sent."); System.out.println("..........fastTest = " + fastTest); System.out.println("..........manualStart = " + manualStart); if (!fastTest && !manualStart) { System.out.println("..........about to join"); slimRunner.join(); System.out.println("..........joined"); } if (fastTest) { System.out.println("..........about to kill");
MemcachedConnection createConnection(List<InetSocketAddress> addrs) throws IOException;  MemcachedNode createMemcachedNode(SocketAddress sa, SocketChannel c, int bufSize);  BlockingQueue<Operation> createOperationQueue();  BlockingQueue<Operation> createReadOperationQueue();  BlockingQueue<Operation> createWriteOperationQueue();  NodeLocator createLocator(List<MemcachedNode> nodes);  OperationFactory getOperationFactory();  long getOperationTimeout();  boolean isDaemon();  Collection<ConnectionObserver> getInitialObservers();  FailureMode getFailureMode(); }
public void addAmpersandAppend(int i, String s) { addAndAppend(i,s); }
public static byte[] toUTF8ByteArray(String string) { return toUTF8ByteArray(string.toCharArray()); }
void readEntryField(PwDatabaseV3 db, PwEntryV3 ent, byte[] buf, int offset) throws UnsupportedEncodingException { int fieldType = LEDataInputStream.readShort(buf, offset); offset += 2; int fieldSize = LEDataInputStream.readInt(buf, offset); offset += 4; switch( fieldType ) { case 0x0000 :
public T insideRequest(Container firstContainer) { if (componentToRegister != null) { ComponentRegistry registry = firstContainer.instanceFor(ComponentRegistry.class); registry.register(component, componentToRegister); } ResourceMethod firstMethod = mockery.mock(ResourceMethod.class, "rm" + counter); firstContainer.instanceFor(MethodInfo.class).setResourceMethod(firstMethod); return firstContainer.instanceFor(component); }
public boolean isTimeout();  public V getSome(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException; }
public void expire(Session session) { long sessionId = session.getSessionId(); LOG.info( "Expiring session 0x{}, timeout of {}ms exceeded", Long.toHexString(sessionId), session.getTimeout()); close(sessionId); }
static String extractName(Class type) { if (type.isArray()) { return type.getComponentType().getSimpleName(); } return type.getSimpleName(); }
public void addingAnDvdCopyWhenUserIsNotLoggedIn() throws Exception { Dvd dvd = new Dvd(); dvd.setId(2l); willNotAddTheDvdRental(dvd); User user = new User(); user.setLogin("abbb"); controller.addToMyList(user, dvd);
private void checkOneRowTable() throws Exception { PageData data = root.getData(); TableScanner ts = new WikiTableScanner(data); assertEquals(1, ts.getTableCount()); Table t = ts.getTable(0); assertEquals(1, t.getRowCount()); assertEquals(1, t.getColumnCountInRow(0)); assertEquals("x", t.getCellContents(0, 0)); }
public void testAsyncDeleteFailure_NoNode() { new VoidCB(zk).verifyDeleteFailure_NoNode(); }
public abstract void addOption(String key, String value);  public abstract void addOption(String key, File value);  public abstract void addOption(String key, boolean value);  public abstract void setLogOnly(boolean v);
public void shouldAddInterceptorsInOrder() throws InterceptionException, IOException { final Sequence sequence = mockery.sequence("executionSequence"); mockery.checking(new Expectations() { { one(stack).add(ResourceLookupInterceptor.class); inSequence(sequence); one(stack).add(URLParameterExtractorInterceptor.class); inSequence(sequence); one(stack).add(InterceptorListPriorToExecutionExtractor.class); inSequence(sequence); one(stack).add(instantiator); inSequence(sequence); one(stack).add(ParametersInstantiatorInterceptor.class); inSequence(sequence); one(stack).add(ExecuteMethodInterceptor.class); inSequence(sequence); one(stack).add(ForwardToDefaultViewInterceptor.class); inSequence(sequence); one(stack).next(null, null); inSequence(sequence); } }); execution.execute(); mockery.assertIsSatisfied(); }
public void run() { try { while (!tryCreateFitServer(fitArgs))
protected void onResume() { super.onResume(); TimeoutHelper.resume(this); }
protected void writeData(String output) { addToResponse(output); }
public ParseSpecification ignoreFirst(SymbolType ignoreFirst) { ignoresFirst.add(ignoreFirst); return this; }
void checking(Validations rules);  void validate(Object object); <T extends View> T onErrorUse(Class<T> view); void addAll(Collection<? extends Message> message); void add(Message message); boolean hasErrors();  <T> T onErrorForwardTo(Class<T> controller);  <T> T onErrorForwardTo(T controller);  <T> T onErrorRedirectTo(Class<T> controller);  <T> T onErrorRedirectTo(T controller);  <T> T onErrorUsePageOf(Class<T> controller);  <T> T onErrorUsePageOf(T controller);  void onErrorSendBadRequest(); }
public void testLinkWitDefaultPrefix() throws Exception { NodeList items = getReportedItems("|PageName|author|date|"); assertEquals(1, items.getLength()); checkItem(items.item(0), "PageName", "author", "date", "author:date", "http://localhost/PageName"); }
private String getActionsHtml(String pageName) throws Exception { createRoot(); root.addChildPage(pageName); return requestPage(pageName).getContent(); }
public void join() throws InterruptedException { synchronized(this) { while(!killed) {
GetsOperation gets(String key, GetsOperation.Callback callback);  GetOperation get(Collection<String> keys, GetOperation.Callback cb);  MutatorOperation mutate(Mutator m, String key, int by, long def, int exp, OperationCallback cb);  StatsOperation stats(String arg, StatsOperation.Callback cb);  StoreOperation store(StoreType storeType, String key, int flags, int exp, byte[] data, OperationCallback cb);  ConcatenationOperation cat(ConcatenationType catType, long casId, String key, byte[] data, OperationCallback cb);  CASOperation cas(StoreType t, String key, long casId, int flags, int exp, byte[] data, OperationCallback cb);  VersionOperation version(OperationCallback cb);  Collection<Operation> clone(KeyedOperation op); }
protected void setUp() throws Exception { fixture = new TestFixture(); }
public void setUp() throws Exception { suitePageName = "SuitePage"; root = InMemoryPage.makeRoot("RooT"); crawler = root.getPageCrawler(); crawler.addPage(root, PathParser.parse("TestPageOne"), "TestPageOne has some testing content and a child"); WikiPage child = crawler.addPage(root, PathParser.parse("TestPageOne.ChildPage"), "ChildPage is a child of TestPageOne"); PageData data = child.getData(); data.setAttribute("Test"); child.commit(data); crawler.addPage(root, PathParser.parse("TestPageTwo"), "TestPageTwo has a bit of content too"); request = new MockRequest(); request.setResource(suitePageName); context = FitNesseUtil.makeTestContext(root); runner = new SuiteSpecificationRunner(root); }
public final boolean isActive() { return reconnectAttempt.get() == 0 && getChannel() != null && getChannel().isConnected();
public Matcher listDigit() { firstIsDigit('1'); matches.add(new ScanMatch() { public Maybe<Integer> match(ScanString input, SymbolStream symbols, int offset) { return isDigitInput('1', input, offset) ? new Maybe<Integer>(1) : Maybe.noInteger; } }); return this; }
public void testValues() { addDataPoints(); Map<String, Object> values = testCounterSet.values(); assertEquals("There should be 10 values in the set", 10, values.size()); assertEquals("avg_key1_test should =0.5", 0.5D, values.get("avg_key1_test")); assertEquals("min_key1_test should =0", 0L, values.get("min_key1_test")); assertEquals("max_key1_test should =1", 1L, values.get("max_key1_test")); assertEquals("cnt_key1_test should =2", 2L, values.get("cnt_key1_test")); assertEquals("sum_key1_test should =1", 1L, values.get("sum_key1_test")); assertEquals("avg_key2_test should =3.5", 3.5, values.get("avg_key2_test")); assertEquals("min_key2_test should =2", 2L, values.get("min_key2_test")); assertEquals("max_key2_test should =5", 5L, values.get("max_key2_test")); assertEquals("cnt_key2_test should =4", 4L, values.get("cnt_key2_test")); assertEquals("sum_key2_test should =14", 14L, values.get("sum_key2_test")); }
public AnnotationVisitor visitAnnotation(final String name, final String desc) { if (name != null) { cp.newUTF8(name); } cp.newUTF8(desc); return new AnnotationConstantsCollector(av.visitAnnotation(name, desc), cp); }
public void testShutdownException() throws Exception { ss = new SocketService(portNumber, new ShutdownService()); Socket s = new Socket("localhost", portNumber); Thread.sleep(100); assertFalse(ss.isRunning()); }
public void testTestingProgressIndicator() throws Exception { formatter.announceStartTestSystem(null, "Fit", "laughing.fit"); formatter.announceNumberTestsToRun(20); formatter.announceStartNewTest("RelativeName", "FullName"); assertSubString("<script>document.getElementById(\"test-summary\").innerHTML =" + " \"<div id=\\\"progressBar\\\" class=\\\"pass\\\" style=\\\"width:5.0%\\\">", pageBuffer.toString()); assertSubString("Running&nbsp;tests&nbsp;...&nbsp;(1/20)", pageBuffer.toString()); pageBuffer.setLength(0); formatter.processTestResults("RelativeName", new TestSummary(1, 0, 0, 0)); formatter.announceStartNewTest("RelativeName", "FullName"); assertSubString("<script>document.getElementById(\"test-summary\").innerHTML =" + " \"<div id=\\\"progressBar\\\" class=\\\"pass\\\" style=\\\"width:10.0%\\\">", pageBuffer.toString()); assertSubString("(2/20)", pageBuffer.toString()); pageBuffer.setLength(0); formatter.processTestResults("RelativeName", new TestSummary(1, 0, 0, 0)); formatter.announceStartNewTest("RelativeName", "FullName"); assertSubString("<script>document.getElementById(\"test-summary\").innerHTML =" + " \"<div id=\\\"progressBar\\\" class=\\\"pass\\\" style=\\\"width:15.0%\\\">", pageBuffer.toString()); assertSubString("(3/20)", pageBuffer.toString()); }
public Maybe<String> findVariable(String name) { Maybe<String> result = findSpecialVariableValue(name); if (!result.isNothing()) return result; result = findVariableInUrl(name); if (!result.isNothing()) return result; result = findVariableInPages(name); if (!result.isNothing()) return result; return findVariableInContext(name); }
public void setup() { this.mockery = new Mockery(); this.container = new PicoBuilder().withCaching().build(); container.addComponent(DefaultInterceptorRegistry.class); final Router router = mockery.mock(Router.class, "registry"); container.addComponent(router); this.request = mockery.mock(MutableRequest.class, "request"); final HttpSession session = mockery.mock(HttpSession.class, "session"); mockery.checking(new Expectations() { { allowing(request).getSession(); will(returnValue(session)); allowing(session).getAttribute(with(any(String.class))); will(returnValue(null)); allowing(session).setAttribute(with(any(String.class)), with(any(String.class))); will(returnValue(null)); } }); this.webRequest = new RequestInfo(null, request, mockery.mock(MutableResponse.class)); this.provider = new PicoComponentRegistry(container, new DefaultComponentFactoryRegistry()); this.provider.init(); }
private boolean isInternalPageThatDoesntExist(String linkPath) { String expandedPath = WikiWordReference.expandPrefix(page, linkPath); WikiPagePath path = PathParser.parse(expandedPath); if (path == null) { return true; } WikiPage start = path.isRelativePath() ? page.getParent() : page;
private HtmlTag makeEditForm(String resource, boolean firstTimeForNewPage, String defaultNewPageContent) throws Exception { HtmlTag form = new HtmlTag("form"); form.addAttribute("name", "f"); form.addAttribute("action", resource); form.addAttribute("method", "post"); form.add(HtmlUtil.makeInputTag("hidden", "responder", "saveData")); form.add(HtmlUtil.makeInputTag("hidden", SAVE_ID, String.valueOf(SaveRecorder.newIdNumber()))); form.add(HtmlUtil.makeInputTag("hidden", TICKET_ID, String.valueOf((SaveRecorder.newTicket())))); if(request.hasInput("redirectToReferer") && request.hasHeader("Referer")) { String redirectUrl = request.getHeader("Referer").toString(); int questionMarkIndex = redirectUrl.indexOf("?"); if(questionMarkIndex > 0) redirectUrl = redirectUrl.substring(0, questionMarkIndex); redirectUrl += "?" + request.getInput("redirectAction").toString(); form.add(HtmlUtil.makeInputTag("hidden", "redirect", redirectUrl)); } form.add(createTextarea(firstTimeForNewPage, defaultNewPageContent)); form.add(createButtons()); form.add("<br/>Hints:\n<ul>" + "<li>Use alt+s (Windows) or control+s (Mac OS X) to save your changes. Or, tab from the text area to the \"Save\" button!</li>\n" + "<li>Grab the lower-right corner of the text area to increase its size (works with some browsers).</li>\n" + "</ul>"); HtmlTag wizardForm = makeWizardForm(resource); TagGroup group = new TagGroup(); group.add(form); group.add(wizardForm); return group; }
public void setup() throws Exception { this.removal = new EmptyElementsRemoval(); this.provider = new OgnlParametersProvider(container, converters, nameProvider, parameters, removal); this.errors = new ArrayList<Message>(); when(converters.to(Long.class)).thenReturn((Converter) new LongConverter()); when(parameters.getSession()).thenReturn(session); when(container.instanceFor(EmptyElementsRemoval.class)).thenReturn(removal); buyA = DefaultResourceMethod.instanceFor(MyResource.class, MyResource.class.getDeclaredMethod("buyA", House.class)); kick = DefaultResourceMethod.instanceFor(MyResource.class, MyResource.class.getDeclaredMethod("kick", AngryCat.class)); error = DefaultResourceMethod.instanceFor(MyResource.class, MyResource.class.getDeclaredMethod("error", WrongCat.class)); array = DefaultResourceMethod.instanceFor(MyResource.class, MyResource.class.getDeclaredMethod("array", Long[].class)); simple = DefaultResourceMethod.instanceFor(MyResource.class, MyResource.class.getDeclaredMethod("simple", Long.class)); }
public void testPrepend() throws Exception { final String key="prepend.key"; assertTrue(client.set(key, 5, "test").get()); assertTrue(client.prepend(0, key, "es").get()); assertEquals("estest", client.get(key)); }
private String fixPathTar( String path ) { if (path == null || path.equals(".")) { return path; } path = fixPathBase(path);
public void directCheckUpgradeSessionTest() throws IOException, InterruptedException, KeeperException { final ZooKeeper zk = createClient(); String path = "/directcheckupgradesession"; zk.create(path, new byte[0], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); QuorumZooKeeperServer server = getConnectedServer(zk.getSessionId()); assertNotNull(server, "unable to find server interlocutor"); Request readRequest = makeGetDataRequest(path, zk.getSessionId()); Request createRequest = makeCreateRequest(path + "/e", zk.getSessionId()); assertNull(server.checkUpgradeSession(readRequest), "tried to upgrade on a read"); assertNotNull(server.checkUpgradeSession(createRequest), "failed to upgrade on a create"); assertNull(server.checkUpgradeSession(createRequest), "tried to upgrade after successful promotion"); }
int getRowCount(); int getColumnCountInRow(int row); void substitute(int col, int row, String content); int addRow(List<String> list); void addColumnToRow(int row, String content); void appendChildTable(int row, Table table); void updateContent(int row, TestResult testResult); void updateContent(int col, int row, SlimTestResult testResult); void updateContent(int col, int row, SlimExceptionResult exceptionResult); Table asTemplate(CellContentSubstitution substitution) throws SyntaxError;
protected void readRequest() throws IOException { zkServer.processPacket(this, incomingBuffer); }
public void DirectoryWithoutHtmlFilesIsWikiFilePage() throws Exception { fileSystem.makeFile(new File("./somepath/WikiPage/myfile.txt"), "stuff"); fileSystem.makeFile(new File("./somepath/OtherPage/myfile.html"), "stuff"); WikiPage page = rootPage.addChildPage("WikiPage"); assertEquals(WikiFilePage.class, page.getClass()); }
static StatPersisted createStat(int version) { StatPersisted stat = new StatPersisted(); stat.setCtime(0); stat.setMtime(0); stat.setCzxid(0); stat.setMzxid(0); stat.setPzxid(0); stat.setVersion(version); stat.setAversion(0); stat.setEphemeralOwner(0); return stat; }
String getProperty(String propertyKey); List<Symbol> findHeaderLines(); }
public void shouldThrowExceptionWhenUnableToParse() { mockery.checking(new Expectations() { { exactly(2).of(request).getAttribute("javax.servlet.jsp.jstl.fmt.locale.request"); will(returnValue("pt_br")); } }); try { converter.convert("vr3.9", double.class, bundle);
protected void setUp() throws Exception { LOG.info("STARTING " + getName()); setupTestEnv(); JMXEnv.setUp(); setUpAll(); port1 = PortAssignment.unique(); port2 = PortAssignment.unique(); port3 = PortAssignment.unique(); port4 = PortAssignment.unique(); port5 = PortAssignment.unique(); leport1 = PortAssignment.unique(); leport2 = PortAssignment.unique(); leport3 = PortAssignment.unique(); leport4 = PortAssignment.unique(); leport5 = PortAssignment.unique(); hostPort = "127.0.0.1:" + port1 + ",127.0.0.1:" + port2 + ",127.0.0.1:" + port3 + ",127.0.0.1:" + port4 + ",127.0.0.1:" + port5; LOG.info("Ports are: " + hostPort); s1dir = ClientBase.createTmpDir(); s2dir = ClientBase.createTmpDir(); s3dir = ClientBase.createTmpDir(); s4dir = ClientBase.createTmpDir(); s5dir = ClientBase.createTmpDir(); String config = "group.1=1:2:3\n" + "group.2=4:5\n" + "weight.1=1\n" + "weight.2=1\n" + "weight.3=1\n" + "weight.4=0\n" + "weight.5=0\n"; ByteArrayInputStream is = new ByteArrayInputStream(config.getBytes()); this.qp = new Properties(); qp.load(is); startServers(); cht.hostPort = hostPort; cht.setUpAll(); LOG.info("Setup finished"); }
Operation removeCurrentWriteOp();  boolean hasReadOp();  boolean hasWriteOp();  void addOp(Operation op);  void insertOp(Operation o);  int getSelectionOps();  ByteBuffer getRbuf();  ByteBuffer getWbuf();  SocketAddress getSocketAddress();  boolean isActive();  boolean isAuthenticated();  long lastReadDelta();  void completedRead();  void reconnecting();  void connected();  int getReconnectCount();  void registerChannel(SocketChannel ch, SelectionKey selectionKey);  void setChannel(SocketChannel to);  SocketChannel getChannel();  void setSk(SelectionKey to);  SelectionKey getSk();  int getBytesRemainingToWrite();  int writeSome() throws IOException;  void fixupOps();  void authComplete();  void setupForAuth();  void setContinuousTimeout(boolean timedOut); int getContinuousTimeout(); MemcachedConnection getConnection(); void setConnection(MemcachedConnection connection); }
public void findsTheCorrectAnnotatedMethodIfThereIsNoWebMethodAnnotationPresent() throws SecurityException, NoSuchMethodException { ResourceMethod method = lookuper.methodFor("/clients", "POST"); assertThat(method.getMethod(), is(equalTo(Clients.class.getMethod("list")))); mockery.assertIsSatisfied(); }
private QuorumPacket createValidateSessionPacketResponse(boolean valid) throws Exception { QuorumPacket qp = createValidateSessionPacket(); ByteArrayInputStream bis = new ByteArrayInputStream(qp.getData()); DataInputStream dis = new DataInputStream(bis); long id = dis.readLong(); ByteArrayOutputStream bos = new ByteArrayOutputStream(); DataOutputStream dos = new DataOutputStream(bos); dos.writeLong(id);
public void pageHistoryShouldHaveStatsForOneTestIfOnePageHistoryFileIsPresent() throws Exception { File pageDirectory = addPageDirectory("TestPage"); addTestResult(pageDirectory, "20090418123103_1_2_3_4"); history.readHistoryDirectory(resultsDirectory); PageHistory pageHistory = history.getPageHistory("TestPage"); assertEquals(1, pageHistory.size()); assertEquals(7, pageHistory.maxAssertions()); SortedSet<Date> dates = pageHistory.datesInChronologicalOrder(); assertEquals(1, dates.size()); Date date = dateFormat.parse("20090418123103"); assertEquals(date, dates.first()); PageHistory.PassFailBar passFailBar = pageHistory.getPassFailBar(date, 50); assertEquals(1, passFailBar.getPass()); assertEquals(6, passFailBar.getFail()); assertEquals(7, passFailBar.getPassUnits()); assertEquals(43, passFailBar.getFailUnits()); }
protected void decodePayload(byte[] pl) { final int flags = decodeInt(pl, 0); final byte[] data = new byte[pl.length - EXTRA_HDR_LEN - keyLen]; System.arraycopy(pl, (EXTRA_HDR_LEN + keyLen), data, 0, pl.length - EXTRA_HDR_LEN - keyLen); ReplicaGetOperation.Callback gcb = (ReplicaGetOperation.Callback) getCallback(); gcb.gotData(key, flags, data); getCallback().receivedStatus(STATUS_OK); }
private void sortGroup(PwGroup group, Vector<PwGroup> groupList) {
public String toHexString() { return Long.toHexString(hash); }
public void setUp() throws Exception { context = new FitNesseContext(); context.rootPagePath = "testdir"; FileUtil.makeDir("testdir"); FileUtil.makeDir("testdir/files"); testFile = FileUtil.createFile("testdir/tempFile.txt", "test content"); responder = new UploadResponder(); request = new MockRequest(); }
public static void deleteFile(File file) { if(!file.exists()) return; if(!file.delete()) throw new RuntimeException("Could not delete '" + file.getAbsoluteFile() + "'"); waitUntilFileDeleted(file); }
public void shutdown() { LOG.info("shutdown called " + localAddress);
public final void begin(final String element, final Attributes attrs) throws SAXException { Opcode o = (Opcode) OPCODES.get(element); if (o == null) { throw new SAXException("Invalid element: " + element + " at " + match); } switch (o.type) { case OpcodeGroup.INSN:
public static HtmlTag makeActions(PageData pageData, String localPageName, String localOrRemotePageName, boolean newWindowIfRemote) throws Exception { TagGroup actions = new TagGroup(); if (isTestPage(pageData)) { actions.add(makeActionLink(localPageName, "Test", "test", "t", NO_NEW_WINDOW)); actions.add(makeNavBreak()); } if (isSuitePage(pageData)) { actions.add(makeActionLink(localPageName, "Suite", "suite", "", NO_NEW_WINDOW)); actions.add(makeNavBreak()); } if (pageData.hasAttribute("Edit")) { actions.add(makeActionLink(localOrRemotePageName, "Edit", "edit", "e", newWindowIfRemote)); actions.add(makeNavBreak()); } if (pageData.hasAttribute("Properties")) { actions.add(makeActionLink(localOrRemotePageName, "Properties", "properties", "p", newWindowIfRemote)); actions.add(makeNavBreak()); } if (pageData.hasAttribute("Refactor")) { actions.add(makeActionLink(localOrRemotePageName, "Refactor", "refactor", "r", newWindowIfRemote)); actions.add(makeNavBreak()); } if (pageData.hasAttribute("WhereUsed")) { actions.add(makeActionLink(localOrRemotePageName, "Where Used", "whereUsed", "w", NO_NEW_WINDOW)); actions.add(makeNavBreak()); } if (pageData.hasAttribute("Search")) { actions.add(makeActionLink("?searchForm", "Search", null, "s", NO_NEW_WINDOW)); actions.add(makeNavBreak()); } if (pageData.hasAttribute("Files")) { actions.add(makeActionLink("/files", "Files", null, "f", NO_NEW_WINDOW)); actions.add(makeNavBreak()); } if (pageData.hasAttribute("Versions")) { actions.add(makeActionLink(localOrRemotePageName, "Versions", "versions", "v", newWindowIfRemote)); actions.add(makeNavBreak()); } if (pageData.hasAttribute("RecentChanges")) { actions.add(makeActionLink("/RecentChanges", "Recent Changes", null, "", NO_NEW_WINDOW)); actions.add(makeNavBreak()); } actions.add(makeActionLink(".FitNesse.UserGuide", "User Guide", null, "", NO_NEW_WINDOW)); return actions; }
public void receivedStatus(String line) {
public void testActionsOfMakeResponse() throws Exception { Response response = makeSampleResponse(baseUrl); MockResponseSender sender = new MockResponseSender(); sender.doSending(response); assertEquals(2, testData.pageTwo.getChildren().size()); WikiPage importedPageOne = testData.pageTwo.getChildPage("PageOne"); assertNotNull(importedPageOne); assertEquals("page one", importedPageOne.getData().getContent()); WikiPage importedPageTwo = testData.pageTwo.getChildPage("PageTwo"); assertNotNull(importedPageTwo); assertEquals("page two", importedPageTwo.getData().getContent()); assertEquals(1, importedPageOne.getChildren().size()); WikiPage importedChildOne = importedPageOne.getChildPage("ChildOne"); assertNotNull(importedChildOne); assertEquals("child one", importedChildOne.getData().getContent()); }
public DefaultRouteBuilder with(HttpMethod method) { this.supportedMethods.add(method); return this; }
public void testAsyncCreateFailure_NoChildForEphemeral() { new StringCB(zk).verifyCreateFailure_NoChildForEphemeral(); }
public void testOneRunUsage() throws Exception { doSimpleRun(); assertFalse(exceptionOccurred); assertEquals(1, outputs.size()); assertEquals(1, counts.size()); assertSubString("class", (String) outputs.get(0)); assertEquals(1, ((Counts) counts.get(0)).right); }
private boolean isVersionFile(final File file) { return Pattern.matches("(\\S+)?\\d+\\.zip", file.getName()); }
public void stop() { shutdownExecutor(); if (server != null) { try {
<T> Future<Boolean> touch(final String key, final int exp, final Transcoder<T> tc); <T> Future<Boolean> touch(final String key, final int exp); Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, long by); long incr(String key, int by); long decr(String key, long by); long decr(String key, int by); Future<Long> asyncIncr(String key, long by); Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, long by); Future<Long> asyncDecr(String key, int by); long incr(String key, long by, long def, int exp); long incr(String key, int by, long def, int exp); long decr(String key, long by, long def, int exp); long decr(String key, int by, long def, int exp); Future<Long> asyncIncr(String key, long by, long def, int exp); Future<Long> asyncIncr(String key, int by, long def, int exp); Future<Long> asyncDecr(String key, long by, long def, int exp); Future<Long> asyncDecr(String key, int by, long def, int exp); long incr(String key, long by, long def); long incr(String key, int by, long def); long decr(String key, long by, long def); long decr(String key, int by, long def); Future<Long> asyncIncr(String key, long by, long def); Future<Long> asyncIncr(String key, int by, long def); Future<Long> asyncDecr(String key, long by, long def); Future<Long> asyncDecr(String key, int by, long def); Future<Boolean> delete(String key); Future<Boolean> delete(String key, long cas); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs); CountDownLatch broadcastOp(final BroadcastOpFactory of); CountDownLatch broadcastOp(final BroadcastOpFactory of, Collection<MemcachedNode> nodes);  Set<String> listSaslMechanisms(); }
public boolean isReadable() { throw new RuntimeException("Not intended"); }
public static SlimTestResult plain(String message) { return new SlimTestResult(null, null, message, null); }
public List<Rule> allRoutes() { return delegate.allRoutes(); }
protected void execute() throws RefactorException { WikiPage parentOfPageToRename = oldRefactoredPage.getParent(); movePage(oldRefactoredPage, parentOfPageToRename, newName); }
public void testExplore() { assertEquals("<table>", simpleTable.tag); assertEquals("<tr>", simpleTable.parts.tag); assertEquals("<td>", simpleTable.parts.parts.tag); assertEquals("a", simpleTable.parts.parts.body); assertEquals("<tr>", simpleTable.parts.more.tag); assertEquals("<td>", simpleTable.parts.more.parts.tag); assertEquals("b", simpleTable.parts.more.parts.body); }
public void testNodeCreated() throws Exception { QuorumUtil qu = new QuorumUtil(1); qu.startAll(); EventsWatcher watcher = new EventsWatcher(); ZooKeeper zk1 = createClient(qu, 1, watcher); ZooKeeper zk2 = createClient(qu, 2); String path = "/test1-created"; zk1.exists(path, watcher); qu.shutdown(1); zk2.create(path, new byte[2], ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); qu.start(1); watcher.waitForConnected(TIMEOUT * 1000L); watcher.assertEvent(TIMEOUT, EventType.NodeCreated); qu.shutdownAll(); }
public void shouldMakeErrorResponseWhenGetsInvalidNumberOfDays() throws Exception { request.addInput("purgeHistory",""); request.addInput("days","-42"); history.readHistoryDirectory(resultsDirectory); Response response = responder.makeResponse(context,request); assertEquals(400,response.getStatus()); }
public void simpleInputAndOutputPassing() throws Exception { SlimTestContextImpl testContext = makeTables( "!|scenario|echo|input|giving|output|\n" + "|check|echo|@input|@output|\n" + "\n" + "!|DT:EchoGiving|\n" + "|input|output|\n" + "|7|7|\n" ); Map<String, Object> pseudoResults = SlimCommandRunningClient.resultToMap( asList(asList("decisionTable_did_0/scriptTable_s_id_0", "7")) ); SlimAssertion.evaluateExpectations(assertions, pseudoResults); String scriptTable = dt.getChildren().get(0).getTable().toString(); String expectedScript = "[[scenario, echo, input, giving, output], [check, echo, 7, pass(7)]]"; assertEquals(expectedScript, scriptTable); String dtHtml = dt.getTable().toString(); assertEquals(1, testContext.getTestSummary().getRight()); assertEquals(0, testContext.getTestSummary().getWrong()); assertEquals(0, testContext.getTestSummary().getIgnores()); assertEquals(0, testContext.getTestSummary().getExceptions()); }
public void index() { result.include("variable", "VRaptor!"); result.forwardTo("/WEB-INF/jsp/index/index2.jsp"); }
public void setUp() throws Exception { mockery = new Mockery(); result = mockery.mock(Result.class); proxifier = new DefaultProxifier(); factory = new DefaultValidationViewsFactory(result, proxifier); errors = Collections.emptyList();
public void testSerializeDeserializeWithSNAPPY() throws IOException { testSerializeDeserialize(StreamMode.SNAPPY, ".snappy"); }
public void testWithNameAdded() throws Exception { WikiPagePath path2 = new WikiPagePath(); path2.addName("AbC"); WikiPagePath path3 = path.withNameAdded("AbC"); assertEquals(path2, path3); assertNotSame(path3, path2); assertNotSame(path3, path); }
public void addEntry(PwEntry entry) { entries.addElement(entry); }
private static List<String> removeEmptyCompileSourceRoots( List<String> compileSourceRootsList ) { List<String> newCompileSourceRootsList = new ArrayList<String>(); if ( compileSourceRootsList != null ) {
public void doCell(Fixture fixture, Parse cell) { fixture.check(cell, adapter); }
private static void printStat(Stat stat) { System.err.println("cZxid = 0x" + Long.toHexString(stat.getCzxid())); System.err.println("ctime = " + new Date(stat.getCtime()).toString()); System.err.println("mZxid = 0x" + Long.toHexString(stat.getMzxid())); System.err.println("mtime = " + new Date(stat.getMtime()).toString()); System.err.println("pZxid = 0x" + Long.toHexString(stat.getPzxid())); System.err.println("cversion = " + stat.getCversion()); System.err.println("dataVersion = " + stat.getVersion()); System.err.println("aclVersion = " + stat.getAversion()); System.err.println("ephemeralOwner = 0x" + Long.toHexString(stat.getEphemeralOwner())); System.err.println("dataLength = " + stat.getDataLength()); System.err.println("numChildren = " + stat.getNumChildren()); }
public Matcher repeat(final char delimiter) { matches.add(new ScanMatch() { public Maybe<Integer> match(ScanString input, int offset) { int size = 0; while (input.charAt(offset + size) == delimiter) size++; return size > 0 ? new Maybe<Integer>(size) : Maybe.noInteger; } }); return this; }
public HtmlTag makeTagsHtml(PageData pageData) { HtmlTag div = new HtmlTag("div"); div.addAttribute("style", "float: left; padding-right: 5px"); div.add(makeInputField("Tags:", PropertySUITES, PropertySUITES, 40, pageData)); return div; }
public void usesTheFirstRegisteredRuleMatchingThePattern() throws SecurityException, NoSuchMethodException { final Route route = mockery.mock(Route.class); final Route second = mockery.mock(Route.class, "second"); mockery.checking(new Expectations() {{ one(route).canHandle("/clients/add", HttpMethod.POST); will(returnValue(true)); one(second).canHandle("/clients/add", HttpMethod.POST); will(returnValue(true)); one(route).matches("/clients/add", HttpMethod.POST, request); will(returnValue(method)); allowing(route).getPriority(); will(returnValue(1)); allowing(second).getPriority(); will(returnValue(2)); }}); router.add(route); router.add(second); ResourceMethod found = router.parse("/clients/add", HttpMethod.POST, request); assertThat(found, is(equalTo(method))); mockery.assertIsSatisfied(); }
private TestExecutionReport readTestExecutionReport(String filePath) throws IOException, SAXException, InvalidReportException { return new TestExecutionReport(new File(filePath)); }
public static void main(String[] args) { if (args.length == 2) { ZooKeeperServerMain.main(args); return; } try { QuorumPeerConfig.parse(args); } catch(Exception e) { LOG.fatal("Error in config", e); System.exit(2); } if (!QuorumPeerConfig.isStandalone()) { runPeer(new QuorumPeer.Factory() {
@Test public void childPageSibling() { assertChildPage("<a href=\"../TestParent/TestSibling.html\">TestSibling</a>", "TestSibling"); }
public void testTouch() { (new TouchOperationImpl("key", 10, null)).toString(); }
public void setUp() throws Exception { context = FitNesseUtil.makeTestContext(FitNesseUtil.PORT); fitnesse = new FitNesse(context); fitnesse.start(); }
public void processSync(Request r){ if(outstandingProposals.isEmpty()){ LOG.warn("No outstanding proposal");
public void tryLoadMissingActionFixture() throws Exception { Parse table = doTableOf(row("start", "NoSuchFixture")); String s = getStringFor(table); assertTrue(s.contains("Could not find fixture: NoSuchFixture.")); }
public void testWithAutoCreateDataDir() throws IOException { Assert.assertFalse("log directory already exists", logDir.exists()); Assert.assertFalse("snapshot directory already exists", snapDir.exists()); FileTxnSnapLog fileTxnSnapLog = createFileTxnSnapLogWithAutoCreateDataDir(logDir, snapDir, "true"); Assert.assertTrue(logDir.exists()); Assert.assertTrue(snapDir.exists()); Assert.assertTrue(fileTxnSnapLog.getDataDir().exists()); Assert.assertTrue(fileTxnSnapLog.getSnapDir().exists()); }
public static void makeVelocityFactory(FitNesseContext context) { if (instance==null) instance = new VelocityFactory(context.rootPath, context.rootDirectoryName);
public void redirect(String url) { try { if (url.startsWith("/")) {
public void processResult(int rc, Object ctx, List<String> paths) { if (paths == null) { unexpectedBehavior.add(String.format("Expected ephemeral count for" + " allPaths to be %d but was null", expected.length)); } else if (paths.size() != expected.length) { unexpectedBehavior.add(String.format("Expected ephemeral count for allPaths to be %d but was %d", expected.length, paths.size())); } for (int i = 0; i < expected.length; i++) { String path = expected[i]; if (!paths.contains(path)) { unexpectedBehavior.add(String.format("Path=%s exists in getEphemerals list ", path)); } } doneProcessing.countDown(); }
boolean touchSession(long sessionId, int sessionTimeout);  void shutdown();  void removeSession(long sessionId); void checkSession(long sessionId) throws KeeperException; }
public void visitTryCatchBlock(final Label start, final Label end, final Label handler, final String type) { if (type != null) { cp.newClass(type); } mv.visitTryCatchBlock(start, end, handler, type); }
public int getTickTime();  public int getMaxClientCnxnsPerHost();  public int getMinSessionTimeout();  public int getMaxSessionTimeout();  public int getInitLimit();  public int getSyncLimit();  public void setInitLimit(int initLimit);  public void setSyncLimit(int syncLimit);  public int getTick();  public String getState();  public String getQuorumAddress();  public int getElectionType();  public String getElectionAddress();  public String getClientAddress();  public String getLearnerType();  public long getConfigVersion();  public String getQuorumSystemInfo();  public boolean isPartOfEnsemble();  public boolean isLeader(); }
@Test public void scansBraceStyle() throws Exception { ParserTest.assertScans("!style_x{my text}", "StyleToken=x,TextToken=my text,DelimiterToken=}"); ParserTest.assertScans("!style_style{my text}", "StyleToken=style,TextToken=my text,DelimiterToken=}"); ParserTest.assertScans("!style{Hi}", "TextToken=!style{Hi,DelimiterToken=}"); ParserTest.assertScans("!style_{Hi}", "TextToken=!style_{Hi,DelimiterToken=}"); ParserTest.assertScans("!style_myStyle{hi}}", "StyleToken=myStyle,TextToken=hi,DelimiterToken=},DelimiterToken=}"); }
Future<Boolean> delete(String key, long cas); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs); CountDownLatch broadcastOp(final BroadcastOpFactory of); CountDownLatch broadcastOp(final BroadcastOpFactory of, Collection<MemcachedNode> nodes);  Set<String> listSaslMechanisms(); }
private void unsupported(String message) { this.status.unsupportedMediaType(message); }
public ReadOnlyPageData readOnlyData() { return sourcePage.readOnlyData(); }
protected int engineDoFinal(byte[] input, int inputOffset, int inputLen, byte[] output, int outputOffset) throws ShortBufferException, IllegalBlockSizeException, BadPaddingException { int result = doFinal(input, inputOffset, inputLen, output, outputOffset); if ( result == -1 ) { throw new ShortBufferException(); } return result; }
private void replaceRHMatchWithNewBestMatch() { tableMatches.set(rightHandTablesBetterMatch, new MatchedPair(leftHandTableIndex, rightHandTableIndex, score)); }
void startRecord(Record r, String tag) throws IOException; void endRecord(Record r, String tag) throws IOException; void startVector(List<?> v, String tag) throws IOException; void endVector(List<?> v, String tag) throws IOException; void startMap(TreeMap<?, ?> v, String tag) throws IOException; void endMap(TreeMap<?, ?> v, String tag) throws IOException; }
public static String peerDn(Socket theSocket) { if (isSSLSocket(theSocket)) { SSLSession ss = ((SSLSocket)theSocket).getSession();
public void add(final Client client) { validator.checking(new Validations() { {
public SlimCommandRunningClient build() throws IOException { CommandRunner commandRunner; if (useManualStartForTestSystem()) { commandRunner = new MockCommandRunner(getExecutionLogListener()); } else { commandRunner = new CommandRunner(buildCommand(), "", createClasspathEnvironment(getClassPath()), getExecutionLogListener(), determineTimeout()); } return new SlimCommandRunningClient(commandRunner, determineSlimHost(), getSlimPort(), determineTimeout(), getSlimVersion(), determineSocketFactory()); }
public void push(final String value) { if (value == null) { mv.visitInsn(Opcodes.ACONST_NULL);
public void returnsTheCorrectDefaultResourceMethodIfFound() throws SecurityException, NoSuchMethodException { final Resource resource = mockery.resource(MyResource.class); VRaptor2MethodLookup lookup = new VRaptor2MethodLookup(resource); assertThat(lookup.methodFor("/MyResource.findable.logic", "findable"), is(VRaptorMatchers.resourceMethod(MyResource.class.getMethod("findable")))); mockery.assertIsSatisfied(); }
public void cascadeConstraint(@Valid Customer customer) { } } @Target(value = { PARAMETER }) @Retention(value = RUNTIME) @Documented public @interface Foo { } }
Map<String, Object> included();  void forwardTo(String uri);  void redirectTo(String uri);  <T> T forwardTo(Class<T> controller);  <T> T redirectTo(Class<T> controller);  <T> T of(Class<T> controller);  <T> T redirectTo(T controller);  <T> T forwardTo(T controller);  <T> T of(T controller);  void nothing();  void notFound();  void permanentlyRedirectTo(String uri);  <T> T permanentlyRedirectTo(Class<T> controller);  <T> T permanentlyRedirectTo(T controller); }
public static void handleImportProperties(HtmlPage html, WikiPage page, PageData pageData) throws Exception { if (isImported(pageData)) { html.setBodyClass("imported");
public InterceptorStack createStack() { DefaultInterceptorStack stack = new DefaultInterceptorStack(interceptorHandlerFactory); for (Class<? extends Interceptor> type : types) { stack.add(type); } return stack; }
public void registerTestSystemFactories(final TestSystemFactoryRegistry registrar) throws PluginException { forEachNamedObject(ConfigurationParameter.TEST_SYSTEMS, new Registrar<TestSystemFactory>() { @Override public void register(String key, Class<TestSystemFactory> clazz) {
protected long currentClockTimeInMillis() { return currentTime; }
protected String lowerFirstCharacter(String baseName) { return baseName.toLowerCase().substring(0, 1) + baseName.substring(1, baseName.length()); }
private GitVersionInfo makeVersionInfo(RevCommit revCommit) { PersonIdent authorIdent = revCommit.getAuthorIdent(); return new GitVersionInfo(revCommit.name(), authorIdent.getName(), authorIdent.getWhen(), revCommit.getShortMessage()); }
public void includeScenarioLibraryBrother() throws Exception { WikiPage slimTestPage = addPage("SlimTest", "!define TEST_SYSTEM {slim}\n"); pageData = slimTestPage.getData(); addPage("ScenarioLibrary", "scenario library"); SetupTeardownAndLibraryIncluder.includeInto(pageData); String html = pageData.getHtml(); assertSubString("scenario library", html); }
public void addsAPrefixToMethodsWhenTheControllerEndsWithSlashAndTheMethodAreAnnotatedWithRelativePath() throws Exception { List<Route> routes = parser.rulesFor(mockery.resource(EndSlashAnnotatedController.class)); Route route = getRouteMatching(routes, "/endSlash/relativePath"); assertThat(route, canHandle(EndSlashAnnotatedController.class, "withRelativePath")); mockery.assertIsSatisfied(); }
void setRequestThrottleDropStale(boolean drop); boolean getRequestStaleLatencyCheck(); void setRequestStaleLatencyCheck(boolean check); boolean getRequestStaleConnectionCheck(); void setRequestStaleConnectionCheck(boolean check); int getLargeRequestMaxBytes(); void setLargeRequestMaxBytes(int bytes); int getLargeRequestThreshold(); void setLargeRequestThreshold(int threshold);  void resetStatistics();  void resetLatency();  void resetMaxLatency();  void resetFsyncThresholdExceedCount();  long getNumAliveConnections();  long getDataDirSize();  long getLogDirSize();  String getSecureClientPort();  String getSecureClientAddress();  long getTxnLogElapsedSyncTime();  int getJuteMaxBufferSize();  int getLastClientResponseSize();  int getMinClientResponseSize();  int getMaxClientResponseSize(); long getFlushDelay(); void setFlushDelay(long delay); long getMaxWriteQueuePollTime(); void setMaxWriteQueuePollTime(long delay); int getMaxBatchSize(); void setMaxBatchSize(int size); }
public boolean isDebugEnabled() { return(l4jLogger.isDebugEnabled()); }
public void testOneFailingTest() throws Exception { testPageResults("SuitePage.TestFailing", new Counts(0, 1, 0, 0), 1); }
public void testRenameFileConfirmationResponder() throws Exception { assertResponderTypeMatchesInput("renameConfirmation", RenameFileConfirmationResponder.class); }
public void testComplete(WikiTestPage test, TestSummary testSummary) { if (firstFailure != null) { notifier.fireTestFailure(new Failure(descriptionFor(test), firstFailure));
public static boolean waitForServerUp(String hp, long timeout, boolean secure) { long start = Time.currentElapsedTime(); while (true) { try {
protected WikiPage createInternalSymbolicPage(String linkPath, String linkName) { WikiPagePath path = PathParser.parse(linkPath); WikiPage start = (path.isRelativePath()) ? getRealPage().getParent() : getRealPage(); WikiPage page = getPageCrawler().getPage(start, path); if (page != null) page = new SymbolicPage(linkName, page, this); return page; }
public QuorumCnxManager createCnxnManager() { int timeout = quorumCnxnTimeoutMs > 0 ? quorumCnxnTimeoutMs : this.tickTime * this.syncLimit; LOG.info("Using {}ms as the quorum cnxn socket timeout", timeout); return new QuorumCnxManager(this, this.getId(),
private boolean isSuiteMetaPage(String relativeName) { return relativeName.equals("SuiteSetUp") || relativeName.endsWith(".SuiteSetUp")
public void testCreateAsync() throws KeeperException, InterruptedException { AsyncCallback.Create2Callback callback = (rc, path, ctx, name, stat) -> {
public static void staticMe() { } public void toInherit() { } } @Test public void shouldFindNonAnnotatedNonStaticPublicMethodWithComponentNameInVariableCamelCaseConventionAsURI() throws Exception { ResourceMethod method = router.parse("/clients/add", HttpMethod.POST, request); assertThat(method, is(VRaptorMatchers.resourceMethod(Clients.class.getMethod("add")))); mockery.assertIsSatisfied(); } @Test public void shouldIgnoreAResourceWithTheWrongWebMethod() throws SecurityException { ResourceMethod method = router.parse("/clients/remove", HttpMethod.POST, request); assertThat(method, is(Matchers.nullValue())); mockery.assertIsSatisfied(); } @Test public void shouldAcceptAResultWithASpecificWebMethod() throws SecurityException, NoSuchMethodException { ResourceMethod method = router.parse("/clients/head", HttpMethod.HEAD, request); assertThat(method, is(VRaptorMatchers.resourceMethod(Clients.class.getMethod("head")))); mockery.assertIsSatisfied(); } static class NiceClients extends Clients { } @Test public void findsInheritedMethodsWithDefaultNames() throws SecurityException, NoSuchMethodException { ResourceClass childResource = mockery.resource(NiceClients.class); router.register(childResource); ResourceMethod method = router.parse("/niceClients/toInherit", HttpMethod.POST, request); assertThat(method, is(VRaptorMatchers.resourceMethod(Clients.class.getMethod("toInherit")))); mockery.assertIsSatisfied(); } }
public void testSessionEstablishment() throws Exception { qu.shutdown(2); CountdownWatcher watcher = new CountdownWatcher(); ZooKeeper zk = new ZooKeeper(qu.getConnString(), CONNECTION_TIMEOUT, watcher, true); watcher.waitForConnected(CONNECTION_TIMEOUT); Assert.assertSame("should be in r/o mode", States.CONNECTEDREADONLY, zk .getState()); long fakeId = zk.getSessionId(); watcher.reset(); qu.start(2); Assert.assertTrue("waiting for server up", ClientBase.waitForServerUp( "127.0.0.1:" + qu.getPeer(2).clientPort, CONNECTION_TIMEOUT)); watcher.waitForConnected(CONNECTION_TIMEOUT); zk.create("/test", "test".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); Assert.assertFalse("fake session and real session have same id", zk .getSessionId() == fakeId); zk.close(); }
public void readFrom(QuorumPeerConfig config) { clientPortAddress = config.getClientPortAddress(); secureClientPortAddress = config.getSecureClientPortAddress(); dataDir = config.getDataDir(); dataLogDir = config.getDataLogDir(); tickTime = config.getTickTime(); maxClientCnxns = config.getMaxClientCnxns(); minSessionTimeout = config.getMinSessionTimeout(); maxSessionTimeout = config.getMaxSessionTimeout(); metricsProviderClassName = config.getMetricsProviderClassName(); metricsProviderConfiguration = config.getMetricsProviderConfiguration(); }
public void testRemoveNodeDeletedWatches() throws Exception { LOG.info("Adding NodeDeleted watcher"); List<EventType> expectedEvents = new ArrayList<>(); expectedEvents.add(EventType.ChildWatchRemoved); expectedEvents.add(EventType.NodeDeleted); MyWatcher myWatcher = new MyWatcher("/testnode1", expectedEvents, 1); zk.create("/testnode1", "data".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); zk.create("/testnode1/testnode2", "data".getBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT); zk.getChildren("/testnode1/testnode2", myWatcher); zk.getChildren("/testnode1", myWatcher); String cmdstring = "removewatches /testnode1 -c"; LOG.info("Remove watchers using shell command : {}", cmdstring); zkMain.cl.parseCommand(cmdstring); assertTrue("Removewatches cmd fails to remove child watches", zkMain.processZKCmd(zkMain.cl)); LOG.info("Waiting for the ChildWatchRemoved event"); myWatcher.matches(); assertEquals("Failed to remove child watches : " + zk.getChildWatches(), 1, zk.getChildWatches().size()); assertTrue("Failed to remove child watches :" + zk.getChildWatches(), zk.getChildWatches().contains("/testnode1/testnode2"));
public static boolean isSerializeLastProcessedZxidEnabled() { return serializeLastProcessedZxidEnabled; }
public void withMultipart() throws Exception { when(request.getContentType()).thenReturn("multipart/form-data"); assertThat(interceptor.accepts(method), equalTo(true)); }
public void testUnreadableFileInput() throws Exception {
public void shouldHeadersProperly() { httpResult.addDateHeader("key", 10L); verify(response).addDateHeader("key", 10L); httpResult.addHeader("key", "value"); verify(response).addHeader("key", "value"); httpResult.addIntHeader("key", 10); verify(response).addIntHeader("key", 10); }
public void gracefulNamesInputAndOutputArgPassing() throws Exception { SlimTestContextImpl testContext = makeTables( "!|scenario|echo|inPut|giving|outPut?|\n" + "|$outPut=|echo|@inPut|\n" + "\n" + "!|DT:EchoGiving|\n" + "|in put|out put?|\n" + "|7|7|\n" ); Map<String, Object> pseudoResults = SlimCommandRunningClient.resultToMap( asList(asList("decisionTable_did_0/scriptTable_s_id_0", "7")) ); SlimAssertion.evaluateExpectations(assertions, pseudoResults); String scriptTable = dt.getChildren().get(0).getTable().toString(); String expectedScript = "[[scenario, echo, inPut, giving, outPut?], [$outPut<-[7], echo, 7]]"; assertEquals(expectedScript, scriptTable); String dtHtml = dt.getTable().toString(); assertEquals("[[DT:EchoGiving], [in put, out put?], [7, pass(7)]]", dtHtml); assertEquals(1, testContext.getTestSummary().getRight()); assertEquals(0, testContext.getTestSummary().getWrong()); assertEquals(0, testContext.getTestSummary().getIgnores()); assertEquals(0, testContext.getTestSummary().getExceptions()); }
public void afterTestOnSuccess() {
public int totalTestsToRun() { return pagesByTestSystem.values().stream() .mapToInt(List::size).sum();
public void notAnnotated() { } @Path("/myPath") public void customizedPath() { } @Path("/*/customPath") public void starPath() { } } class InheritanceExample extends MyResource { } @Test public void canTranslateADefaultResource() throws NoSuchMethodException { DefaultMethodLookupBuilder builder = new DefaultMethodLookupBuilder(); String url = builder.urlFor(MyResource.class, mockery.methodFor(MyResource.class, "notAnnotated").getMethod(), new Object[] {}); assertThat(url, is(equalTo("/MyResource/notAnnotated"))); mockery.assertIsSatisfied(); } @Test public void canTranslateAnnotatedMethod() throws NoSuchMethodException { DefaultMethodLookupBuilder builder = new DefaultMethodLookupBuilder(); String url = builder.urlFor(MyResource.class, mockery.methodFor(MyResource.class, "customizedPath").getMethod(), new Object[] {}); assertThat(url, is(equalTo("/myPath"))); mockery.assertIsSatisfied(); } @Test public void canTranslateAInheritedResourceMethod() throws NoSuchMethodException { DefaultMethodLookupBuilder builder = new DefaultMethodLookupBuilder(); String url = builder.urlFor(InheritanceExample.class, mockery.methodFor(MyResource.class, "notAnnotated").getMethod(), new Object[] {}); assertThat(url, is(equalTo("/InheritanceExample/notAnnotated"))); mockery.assertIsSatisfied(); } @Test public void canTranslateAMethodUsingAsteriskAsAPatternMatcher() throws NoSuchMethodException { DefaultMethodLookupBuilder builder = new DefaultMethodLookupBuilder(); String url = builder.urlFor(MyResource.class, mockery.methodFor(MyResource.class, "starPath").getMethod(), new Object[] {}); assertThat(url, is(equalTo("//customPath"))); mockery.assertIsSatisfied(); } @Test public void usesAsteriskBothWays() throws NoSuchMethodException { DefaultMethodLookupBuilder builder = new DefaultMethodLookupBuilder(); Method method = mockery.methodFor(MyResource.class, "starPath").getMethod(); String url = builder.urlFor(MyResource.class, method, new Object[] {}); ResourceAndMethodLookup lookup = builder.lookupFor(mockery.resource(MyResource.class)); assertThat(lookup.methodFor(url, HttpMethod.POST).getMethod(), is(equalTo(method))); mockery.assertIsSatisfied(); } @Test public void canTranslateAInheritedResourceBothWays() throws NoSuchMethodException { DefaultMethodLookupBuilder builder = new DefaultMethodLookupBuilder(); Method method = mockery.methodFor(MyResource.class, "notAnnotated").getMethod(); String url = builder.urlFor(InheritanceExample.class, method, new Object[] {}); ResourceAndMethodLookup lookup = builder.lookupFor(mockery.resource(InheritanceExample.class)); assertThat(lookup.methodFor(url, HttpMethod.POST).getMethod(), is(equalTo(method))); mockery.assertIsSatisfied(); } @Test public void canTranslateAnnotatedMethodBothWays() throws NoSuchMethodException { DefaultMethodLookupBuilder builder = new DefaultMethodLookupBuilder(); Method method = mockery.methodFor(MyResource.class, "customizedPath").getMethod(); String url = builder.urlFor(MyResource.class, method, new Object[] {}); ResourceAndMethodLookup lookup = builder.lookupFor(mockery.resource(MyResource.class)); assertThat(lookup.methodFor(url, HttpMethod.POST).getMethod(), is(equalTo(method))); mockery.assertIsSatisfied(); } }
public void testRestoreWithNoSnapFiles() throws Exception { runTest(false); }
public void runSingleTest() throws Exception { helper .assertTestPasses("FitNesse.SuiteAcceptanceTests.SuiteSlimTests.SlimSymbolsCanBeBlankOrNull");
static final private File[] pickDirs(File dirs[]) { File rc[] = new File[2]; rc[0] = dirs[rand.nextInt(dirs.length)]; rc[1] = dirs[rand.nextInt(dirs.length)]; return rc; }
public int status() throws Exception { int status = FitnesseFixtureContext.response.getStatus(); return status; }
public Responder authenticate(FitNesseContext context, Request request, Responder privilegedResponder) { request.getCredentials(); String username = request.getAuthorizationUsername(); String password = request.getAuthorizationPassword(); if (isAuthenticated(username, password)) return privilegedResponder;
String getName(); String getFullPath(); ClassPath getClassPath(); }
public void testCreateSSLContextWithoutCustomProtocol( X509KeyType caKeyType, X509KeyType certKeyType, String keyPassword, Integer paramIndex) throws Exception { init(caKeyType, certKeyType, keyPassword, paramIndex); SSLContext sslContext = x509Util.getDefaultSSLContext(); assertEquals(X509Util.DEFAULT_PROTOCOL, sslContext.getProtocol()); }
protected void wrong(int row, int column, String actual) { wrong(getCell(row,column), actual); }
public void start() { if (listenBacklog != -1) { bootstrap.option(ChannelOption.SO_BACKLOG, listenBacklog); } LOG.info("binding to port {}", localAddress); parentChannel = bootstrap.bind(localAddress).syncUninterruptibly().channel();
public void testTestSummaryTestPass() throws Exception { formatter.writeHead("test"); formatter.newTestStarted(page, 0); formatter.testComplete(page, new TestSummary(4, 0, 0, 0)); formatter.allTestingComplete(); assertSubString("<script>document.getElementById(\"test-summary\").innerHTML =", pageBuffer.toString()); assertSubString("<strong>Assertions:</strong> 4 right, 0 wrong, 0 ignored, 0 exceptions", pageBuffer.toString()); assertSubString("document.getElementById(\"test-summary\").className = \"pass\"", pageBuffer.toString()); }
private static void usage() { System.out.println("usage: java [-cp CLASSPATH] org.apache.zookeeper.ServerAdminClient " + "host port op (ruok|stat|dump|kill|gettracemask|settracemask) [arguments]");
Result include(String key, Object value); <T extends View> T use(Class<T> view);  Result on(Class<? extends Exception> exception);  boolean used();  Map<String, Object> included();  void forwardTo(String uri);  void redirectTo(String uri);  <T> T forwardTo(Class<T> controller);  <T> T redirectTo(Class<T> controller);  <T> T of(Class<T> controller);  <T> T redirectTo(T controller);  <T> T forwardTo(T controller);  <T> T of(T controller);  void nothing();  void notFound();  void permanentlyRedirectTo(String uri);  <T> T permanentlyRedirectTo(Class<T> controller);  <T> T permanentlyRedirectTo(T controller); }
public void testSerializeRequestRequestHeaderIsNull() { Request request = new Request(0, 0, 0, null, null, 0); byte[] data = SerializeUtils.serializeRequest(request); assertNull(data); }
BlockingQueue<Operation> createWriteOperationQueue();  NodeLocator createLocator(List<MemcachedNode> nodes);  OperationFactory getOperationFactory();  long getOperationTimeout();  boolean isDaemon();  boolean useNagleAlgorithm();  Collection<ConnectionObserver> getInitialObservers();  FailureMode getFailureMode();  Transcoder<Object> getDefaultTranscoder();  boolean shouldOptimize(); }
private String makePageHtml(FitNesseContext context) throws Exception { HtmlPage page = context.htmlPageFactory.newPage(); page.setTitle("Merge " + resource); page.setPageTitle(new PageTitle("Merge Changes", PathParser.parse(resource))); page.setMainContent(makeRightColumn()); return page.html(); }
Future<CASResponse> asyncCAS(String key, long casId, Object value); <T> CASResponse cas(String key, long casId, T value, Transcoder<T> tc) throws OperationTimeoutException; CASResponse cas(String key, long casId, Object value) throws OperationTimeoutException; <T> Future<Boolean> add(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> add(String key, int exp, Object o); <T> Future<Boolean> set(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> set(String key, int exp, Object o); <T> Future<Boolean> replace(String key, int exp, T o, Transcoder<T> tc); Future<Boolean> replace(String key, int exp, Object o); <T> Future<T> asyncGet(String key, Transcoder<T> tc); Future<Object> asyncGet(String key); <T> Future<CASValue<T>> asyncGets(String key, Transcoder<T> tc); Future<CASValue<Object>> asyncGets(String key); <T> CASValue<T> gets(String key, Transcoder<T> tc) throws OperationTimeoutException; CASValue<Object> gets(String key) throws OperationTimeoutException; <T> T get(String key, Transcoder<T> tc) throws OperationTimeoutException; Object get(String key) throws OperationTimeoutException; <T> Future<Map<String, T>> asyncGetBulk(Collection<String> keys, Transcoder<T> tc); Future<Map<String, Object>> asyncGetBulk(Collection<String> keys); <T> Future<Map<String, T>> asyncGetBulk(Transcoder<T> tc, String... keys); Future<Map<String, Object>> asyncGetBulk(String... keys); <T> Map<String, T> getBulk(Collection<String> keys, Transcoder<T> tc) throws OperationTimeoutException; Map<String, Object> getBulk(Collection<String> keys) throws OperationTimeoutException; <T> Map<String, T> getBulk(Transcoder<T> tc, String... keys) throws OperationTimeoutException; Map<String, Object> getBulk(String... keys) throws OperationTimeoutException; Map<SocketAddress, String> getVersions(); Map<SocketAddress, Map<String, String>> getStats(); Map<SocketAddress, Map<String, String>> getStats(String prefix); long incr(String key, int by) throws OperationTimeoutException; long decr(String key, int by) throws OperationTimeoutException; long incr(String key, int by, long def, int exp) throws OperationTimeoutException; long decr(String key, int by, long def, int exp) throws OperationTimeoutException; Future<Long> asyncIncr(String key, int by); Future<Long> asyncDecr(String key, int by); long incr(String key, int by, long def) throws OperationTimeoutException; long decr(String key, int by, long def) throws OperationTimeoutException; Future<Boolean> delete(String key); Future<Boolean> flush(int delay); Future<Boolean> flush(); void shutdown(); boolean shutdown(long timeout, TimeUnit unit); boolean waitForQueues(long timeout, TimeUnit unit); boolean addObserver(ConnectionObserver obs); boolean removeObserver(ConnectionObserver obs);  void authenticate(String username, String password) throws OperationException; }
private Class rawTypeOf(Type genericType) { if (genericType instanceof ParameterizedType) { return (Class) ((ParameterizedType) genericType).getRawType(); } return (Class) genericType; }
public ZookKeeperServerEmbeddedBuilder baseDir(Path baseDir) { this.baseDir = Objects.requireNonNull(baseDir); return this; }
public void stopTestExceptionThrown() throws Exception { addImportAndMake(); statements.add(list("id", "call", "testSlim", "throwStopping")); statements.add(list("id2", "call", "testSlim", "throwNormal")); Map<String, Object> results = slimClient.invokeAndGetResponse(statements); assertContainsException("__EXCEPTION__:" + expectedStopTestExceptionMessage(), "id", results); assertNull(results.get("id2")); }
public static void startMiniKdc() throws Exception { createTestDir(); createMiniKdcConf(); kdc = new MiniKdc(conf, workDir); kdc.start(); }
public void canInstantiateAndPopulateAListOfWrappers() { final Target<Cat> target = Target.create(Cat.class, "myCat"); final Cat myCat = iogi.instantiate(target, new Parameter("myCat.eyeColorCode[0]", "3"), new Parameter("myCat.eyeColorCode[1]", "5")); assertThat(myCat.eyeColorCode.get(0), is(equalTo(3L))); assertThat(myCat.eyeColorCode.get(1), is(equalTo(5L))); }
PageData getRevisionData(FileSystemPage page, String label); Collection<VersionInfo> history(FileSystemPage page); VersionInfo makeVersion(FileSystemPage page, PageData data); void removeVersion(FileSystemPage page, String versionName); void prune(FileSystemPage page); }
public void mismatchedUnboundSymbolIsNotReplaced() throws Exception { assertExpectationMessage("$S", "$X", "fail(a=$X;e=$S)"); }
public void testOperaPostRequest() throws Exception { appendToMessage("POST /HelloThere HTTP/1.1\r\n"); appendToMessage("User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; MSIE 5.5; Windows NT 5.1) Opera 7.02 [en]\r\n"); appendToMessage("Host: localhost:75\r\n"); appendToMessage("Accept: text/html, image/png, image/jpeg, image/gif, image/x-xbitmap, */*;q=0.1\r\n"); appendToMessage("Accept-Language: en\r\n"); appendToMessage("Accept-Charset: windows-1252, utf-8, utf-16, iso-8859-1;q=0.6, *;q=0.1\r\n"); appendToMessage("Accept-Encoding: deflate, gzip, x-gzip, identity, *;q=0\r\n"); appendToMessage("Referer: http://localhost:75/HeloThere?edit=\r\n"); appendToMessage("Connection: Keep-Alive, TE\r\n"); appendToMessage("TE: deflate, gzip, chunked, identity, trailers\r\n"); appendToMessage("Content-type: application/x-www-form-urlencoded\r\n"); appendToMessage("Content-length: 67\r\n"); appendToMessage("\r\n"); appendToMessage("saveId=1046584670887&Edit=on&Search=on&Test=on&Suite=on&content=abc"); parseMessage(); assertTrue(request.hasInput("saveId")); assertTrue(request.hasInput("Edit")); assertTrue(request.hasInput("Search")); assertTrue(request.hasInput("Test")); assertTrue(request.hasInput("Suite")); assertTrue(request.hasInput("content")); }
OperationFactory getOperationFactory();  long getOperationTimeout();  boolean isDaemon();  boolean useNagleAlgorithm();  Collection<ConnectionObserver> getInitialObservers();  FailureMode getFailureMode();  Transcoder<Object> getDefaultTranscoder();  boolean shouldOptimize();  int getReadBufSize();  public HashAlgorithm getHashAlg();  long getMaxReconnectDelay();  AuthDescriptor getAuthDescriptor();  int getTimeoutExceptionThreshold(); }
public void process(WatchedEvent event) { triggered = true; }
public Future<Boolean> replace(String key, int exp, Object o) { return asyncStore(StoreType.replace, key, exp, o); }
private boolean hasNoCredentials() { return (commandParts().length == 1); }
private QueryTable makeQueryTableAndBuildInstructions(String pageContents) throws Exception { qt = makeQueryTable(pageContents); qt.appendInstructions(instructions); return qt; }
public void canProvideAllComponents() { Class<?>[] components = new Class[] { UrlToResourceTranslator.class, ResourceRegistry.class, DirScanner.class, ResourceLocator.class, TypeCreator.class, InterceptorRegistry.class }; for (Class<?> component : components) { MatcherAssert.assertThat("Should be able to provide a " + component.getName(), canProvide(component), Matchers.is(Matchers.equalTo(true))); } mockery.assertIsSatisfied(); }
void setConnectionDecreaseRatio(double val); int getCommitProcMaxReadBatchSize(); void setCommitProcMaxReadBatchSize(int size); int getCommitProcMaxCommitBatchSize(); void setCommitProcMaxCommitBatchSize(int size); int getRequestThrottleLimit(); void setRequestThrottleLimit(int requests); int getRequestThrottleStallTime(); void setRequestThrottleStallTime(int time); boolean getRequestThrottleDropStale(); void setRequestThrottleDropStale(boolean drop); boolean getRequestStaleLatencyCheck(); void setRequestStaleLatencyCheck(boolean check); boolean getRequestStaleConnectionCheck(); void setRequestStaleConnectionCheck(boolean check);  void resetStatistics();  void resetLatency();  void resetMaxLatency();  void resetFsyncThresholdExceedCount();  long getNumAliveConnections();  long getDataDirSize();  long getLogDirSize();  String getSecureClientPort();  String getSecureClientAddress();  long getTxnLogElapsedSyncTime();  int getJuteMaxBufferSize();  int getLastClientResponseSize();  int getMinClientResponseSize();  int getMaxClientResponseSize(); long getFlushDelay(); void setFlushDelay(long delay); long getMaxWriteQueuePollTime(); void setMaxWriteQueuePollTime(long delay); int getMaxBatchSize(); void setMaxBatchSize(int size); }
public void stop() { enqueueWithoutFailure(new ShutdownDeliveryManagerRequest()); }
protected VersionInfo makeVersion(PageData current) { String name = String.valueOf(nextId()); VersionInfo version = makeVersionInfo(current, name); versions.put(version.getName(), current); return version; }
public void localizedRejectPasses() throws Exception { assertScriptResults("|localized reject|func|3|\n", ListUtility.<List<?>>list(
public String toString() { List<String> criterias = new LinkedList<String>(); if (matchTags.isFiltering()) { if(andStrategy){ criterias.add("matches all of '" + matchTags.tagString + "'"); } else { criterias.add("matches '" + matchTags.tagString + "'"); } } if (notMatchTags.isFiltering()) { criterias.add("doesn't match '" + notMatchTags.tagString + "'"); } if (startWithTest != null) { criterias.add("starts with test '" + startWithTest + "'"); } return StringUtil.join(criterias, " & "); }
void setHistoryDepth(int historyDepth);  FileVersion[] getRevisionData(String revision, File... files);  Collection<? extends VersionInfo> history(File... files);  VersionInfo makeVersion(FileVersion... fileVersion) throws IOException;  VersionInfo addDirectory(final FileVersion filePath) throws IOException;  void rename(FileVersion fileVersion, File originalFile) throws IOException;  void delete(File... files); }
public void testMoveFromRoot() throws Exception { assertTrue(crawler.pageExists(PathParser.parse("PageOne"))); movePage("PageOne", "PageTwo", true); WikiPage movedPage = pageTwo.getChildPage("PageOne"); assertFalse(crawler.pageExists(PathParser.parse("PageOne"))); assertEquals(".PageTwo.PageOne.PageA", movedPage.getData().getContent()); assertEquals("PageTwo.PageOne", PathParser.render(movedPage.getFullPath())); }
public String getKeyForNode(MemcachedNode node, int repetition);  int getNodeRepetitions(); }
public void tableWithBadConstructorHasException() throws Exception { getResultsForPageContents( "!|DT:fitnesse.slim.test.TestSlim|badArgument|\n" + "|returnConstructorArgument?|\n" + "|3|\n" ); TableScanner ts = new HtmlTableScanner(responder.getTestResults().getHtml()); ts.getTable(0); assertTestResultsContain("Could not invoke constructor"); }
public void serve(SlimSocket socket) throws IOException { SlimStreamReader reader = null; OutputStream writer = null; try { reader = socket.getReader();
void onEachFile( InputStream input, TarArchiveEntry fileEntry ) throws IOException; void onEachLink( TarArchiveEntry linkEntry ) throws IOException; }
protected void loadPage(String pageName, FitNesseContext context) { WikiPagePath path = PathParser.parse(pageName); crawler = context.root.getPageCrawler(); page = crawler.getPage(context.root, path); if (page != null) pageData = page.getData();
protected WikiPage createChildPage(String name) { BaseWikiPage newPage = new InMemoryPage(name, this); children.put(newPage.getName(), newPage); return newPage; }
public void testLoggingIncludesUsername() throws Exception { ld = new LogData( ld.host, ld.time, ld.requestLine, ld.status, ld.size, "Joe"); l.log(ld); l.close(); File dir = l.getDirectory(); File file = new File(dir, filename); assertTrue(file.exists()); String contents = FileUtil.getFileContent(file); logLine = "myHost - Joe [06/Mar/2003:13:42:05 -0100] \"request\" 42 666"; assertEquals(logLine + System.getProperty("line.separator"), contents); }
public void multiFunctionCall() throws Exception { statements.add(Arrays.asList("id1", "call", "testSlim", "addTo", "1", "2")); statements.add(Arrays.asList("id2", "call", "testSlim", "addTo", "3", "4")); respondsWith(Arrays.asList(Arrays.asList("id1", (Object) "3"), Arrays.asList("id2", (Object) "7"))); }
public void run() { if ( mSuccess ) {
String toHtml(); void setCell(int col, int row, String contents); int addRow(List<String> list); void appendCellToRow(int row, String contents); String getUnescapedCellContents(int col, int row); String getCellResult(int col,int row); void appendChildTable(int row, Table table); void setTestStatusOnRow(int row, ExecutionResult testStatus); void setName(String tableName); void setCell(int col, int row, Result response); void appendToCell(int col, int row, Result response); }
protected void setUp() throws Exception { LOG.info("STARTING " + getName()); setupTestEnv(); JMXEnv.setUp(); tmpDir = createTmpDir(BASETEST); startServer(); LOG.info("Client test setup finished"); }
public void onEachFile( InputStream inputStream, String filename, String linkname, String user, int uid, String group, int gid, int mode, long size ) throws IOException { filename = fixPath(filename); createParentDirectories(filename, user, uid, group, gid); final TarArchiveEntry entry = new TarArchiveEntry(filename, true); entry.setUserName(user); entry.setUserId(uid); entry.setGroupName(group); entry.setGroupId(gid); entry.setMode(mode); entry.setSize(size); tarOutputStream.putArchiveEntry(entry); dataSize.add(size); digest.reset(); Utils.copy(inputStream, new DigestOutputStream(tarOutputStream, digest)); final String md5 = Utils.toHex(digest.digest()); tarOutputStream.closeArchiveEntry(); console.info( "file:" + entry.getName() + " size:" + entry.getSize() + " mode:" + entry.getMode() + " linkname:" + entry.getLinkName() + " username:" + entry.getUserName() + " userid:" + entry.getUserId() + " groupname:" + entry.getGroupName() + " groupid:" + entry.getGroupId() + " modtime:" + entry.getModTime() + " md5: " + md5 );
public void execute() { if (control == null || !control.isDirectory()) { throw new BuildException("You need to point the 'control' attribute to the control directory."); } if (changesIn != null) { if (!changesIn.isFile() || !changesIn.canRead()) { throw new BuildException("The 'changesIn' attribute needs to point to a readable file. " + changesIn + " was not found/readable."); } if (changesOut == null) { throw new BuildException("A 'changesIn' without a 'changesOut' does not make much sense."); } if (!isPossibleOutput(changesOut)) { throw new BuildException("Cannot write the output for 'changesOut' to " + changesOut); } if (changesSave != null && !isPossibleOutput(changesSave)) { throw new BuildException("Cannot write the output for 'changesSave' to " + changesSave); } } else { if (changesOut != null || changesSave != null) { throw new BuildException("The 'changesOut' or 'changesSave' attributes may only be used when there is a 'changesIn' specified."); } } if (!"gzip".equals(compression) && !"bzip2".equals(compression) && !"none".equals(compression)) { throw new BuildException("The compression method '" + compression + "' is not supported"); } if (dataProducers.size() == 0) { throw new BuildException("You need to provide at least one reference to a tgz or directory with data."); } if (deb == null) { throw new BuildException("You need to point the 'destfile' attribute to where the deb is supposed to be created."); } final File[] controlFiles = control.listFiles(); final DataProducer[] data = new DataProducer[dataProducers.size()]; dataProducers.toArray(data); final Processor processor = new Processor(new TaskConsole(this, verbose), null); final PackageDescriptor packageDescriptor; try { log("Creating debian package: " + deb); packageDescriptor = processor.createDeb(controlFiles, data, deb, compression); } catch (Exception e) {
public Object remove(Object key) { if (key == null) { return null; } purgeBeforeWrite(); return super.remove(key); }
public Class<?> typeFor(ResourceMethod method) { if (!cache.containsKey(method)) { cache.put(method, creator.typeFor(method)); logger.debug("cached generic type for method " + method); } return cache.get(method); }
